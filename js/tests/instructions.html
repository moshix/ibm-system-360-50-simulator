<!DOCTYPE html>
<html>
<!--
Test instructions on the 360 simulator.
-->
<head>
  <meta charset="utf-8">
  <title>Instruction unittests</title>
  <link rel="stylesheet" href="qunit-2.9.2.css" >
  <script src="data.js"></script>
  <script src="../utils.js"></script>
  <script src="../disasm.js"></script>
  <script src="../decode.js"></script>
  <script src="../engine.js"></script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>

  <script src="qunit-2.9.2.js"></script>
  <script>

QUnit.config.collapse = false; // Expand all failures

// Log test name to console
QUnit.testStart(function(test) {
  var module = test.module ? test.module : '';
  console.log('-----' + module + " " + test.name + "-----");
});

// Override alert so simulator will stop if an error is hit.
// https://stackoverflow.com/questions/1729501/javascript-overriding-alert
(function(proxied) {
window.alert = function() {
  running = 0; // Stop the simulator
  throw(arguments[0]);
  console.log('stopping ' + arguments[0]);
  return proxied.apply(this, arguments);
};
})(window.alert);

var state;

// Read or write register
function reg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][0x30 + num];
  } else {
    state['LS'][0x30 + num] = data;
  }
}

// Read or write half FP register
function fpreg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][0x20 + num];
  } else {
    state['LS'][0x20 + num] = data;
  }
}

// Convert words to halfwords
function hw(words) {
  var result = [];
  for (var i = 0; i < words.length; i++) {
    result.push(words[i] >>> 16);
    result.push(words[i] & 0xffff);
  }
  return result;
}

var running;
// Load instruction(s) into memory at 0x400 and execute.
function execute(instr, assert, desired) {
  command = disasm(hw(instr));
  console.log(command);
  assert.equal(command.replace(/ /g, ''), desired.replace(/ /g, '', desired));
  // Load instruction into memory
  for (var i = 0; i < instr.length; i++) {
    state['MS'][0x400 + i * 4] = instr[i];
  }
  state['IAR'] = 0x400;
  state['ROAR'] = 0x0197;
  running = 1;
  executeInstr();
}

// Execute one instruction
function executeInstr(instr) {
  for (var count = 0; count < 100; count++) {
    // Log micro-instruction
    var saddr = fmtAddress(state['ROAR']);
    console.log(decode(saddr, testdata[saddr]).join('\n'));
    // Execute micro-instruction
    cycle(state, testdata[saddr]);
    if (!running) { // emulator problem bailout
      alert('Bailing out');
      return;
    }

    // Check validity
    var keys = Object.keys(state);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (typeof state[key] == 'number' && state[key] < 0) {
        alert('Negative value for state ' + key + ' ' + state[key]);
      }
    }

    console.log('L: ' + state['L'].toString(16) +
      ', R: ' + state['R'].toString(16) +
      ', M: ' + state['M'].toString(16) +
      ', T: ' + state['T'].toString(16) +
      ', F: ' + state['F'].toString(16) +
      ', H: ' + state['H'].toString(16) +
      ', J: ' + state['J'].toString(16) +
      ', U: ' + state['U'].toString(16) +
      ', V: ' + state['V'].toString(16) +
      ', W: ' + state['W'].toString(16) +
      ', LB: ' + state['LB'].toString(16) +
      ', MB: ' + state['MB'].toString(16) +
      ', MD: ' + state['MD'].toString(16) +
      ', G1: ' + state['G1'].toString(16) +
      ', G2: ' + state['G2'].toString(16) +
      ', IAR: ' + state['IAR'].toString(16) +
      ', LSAR: ' + state['LSAR'].toString(16) +
      ', SGNS: ' + state['LSGNS'] + ' ' + state['RSGNS'] +
      ', S: ' + state['S'] +
      ', BS: ' + state['BS'] +
      ', CR: ' + state['CR']);
    // Check if done
    if (count > 5 && [0x149, 0x14a, 0x14c, 0x14e, 0x184, 0x185, 0x187, 0x188, 0x189, 0x19b].includes(state['ROAR'])) {
      return;
    }
    if (count > 8 && [0x148].includes(state['ROAR'])) {
      return;
    }
    if (state['TRAP']) {
      console.log("********** TRAP **********");
      throw('TRAP');
      return;
    }
    if ([0x218, 0x195, 0x19c, 0x1b0, 0x1b4, 0x1b8, 0x1b1, 0x1b3, 0x1b5, 0x1b7, 0x10e, 0x10f].includes(state['ROAR'])) {
      console.log('********** Exception ' + state['ROAR'].toString(16) + ' **********');
      console.log('IAR: ' + state['IAR']);
      throw('Exception');
      return;
    }
  }
  throw('Count exceeded');
}

QUnit.module("Instructions", function(hooks) {
  hooks.beforeEach(function(assert) {
    state = createState();
  });

  QUnit.test( "Load LR", function(assert) {
    reg(1, 0x12345678);
    execute([0x18310000], assert, 'LR 3,1');
    assert.equal(reg(3), 0x12345678);
  });

  QUnit.test( "Load L", function(assert) {
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x12345678;
    execute([0x58345984], assert, 'L 3,984(4,5)');
    // L 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0x12345678);
  });
  QUnit.test( "Load and Test LTR", function(assert) {
    reg(4, 0xcdef1234);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0xcdef1234);
    assert.equal(state['CR'], 1); // Negative

    reg(4, 0);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero

    reg(4, 0x12345678);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR negative", function(assert) {
    reg(4, 0x1000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0xfffff000);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Complement LCR positive", function(assert) {
    reg(4, 0xffffffff);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR zero", function(assert) {
    reg(4, 0);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement LCR overflow", function(assert) {
    state['PROGMASK'] = 0; // Disable overflow interrupt
    reg(4, 0x80000000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Load Positive LPR", function(assert) {
    reg(4, 0xffffffff);
    execute([0x10340000], assert, 'LPR 3,4');
    // LPR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Negative LNR positive", function(assert) {
    reg(4, 0x12345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xedcba988);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR negative", function(assert) {
    reg(4, 0xc2345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xc2345678);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR 0", function(assert) {
    reg(4, 0);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "AR add", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000005);
    execute([0x1a120000], assert, 'AR 1,2');
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x1234567d);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "AR two adds", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    reg(3, 0x00000010);
    execute([0x1a121a31], assert, 'AR 1,2');
    executeInstr(); // Run the second instruction
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x12345679);
    assert.equal(reg(3), 0x12345689);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "AR add-negative", function(assert) {
    reg(1, 0x81234567);
    reg(2, 0x00000001);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x81234568);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "AR add-zero", function(assert) {
    reg(1, 0x00000002);
    reg(2, 0xfffffffe);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "AR add-overflow-trap-disabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 0; // Disable overflow interrupt
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "AR add-overflow-trap-enabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 8; // Enable overflow interrupt
    assert.throws(function() {
      execute([0x1a120000], assert, 'AR 1,2');
      console.log('no throw');
    });
  });

  QUnit.test( "add A", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5a156200], assert, 'A 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x34567890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000202);
    state['MS'][0x500] = 0x34567890; // Only 7890 used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x7890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH sign extend", function(assert) {
    reg(1, 1);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xfffe1234; // only fffe (-2) used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0xffffffff); // -1
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Add Logical ALR (i.e. unsigned) - zero no carry ", function(assert) {
    reg(1, 0);
    reg(2, 0);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero, no carry
  });

  QUnit.test( "Add Logical ALR - non-zero no carry ", function(assert) {
    reg(1, 0xffff0000);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0xffff0002);
    assert.equal(state['CR'], 1); // Nonzero, no carry
  });

  QUnit.test( "Add Logical ALR - zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Zero and carry
  });


  QUnit.test( "Add Logical ALR - not zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000003);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 1);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "Add Logical AL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xf0000000;
    execute([0x5e156200], assert, 'AL 1,200(5,6)');
    assert.equal(reg(1), 0x02345678);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "SR subtract", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x1b120000], assert, 'SR 1,2');
    assert.equal(reg(1), 0x12345677);
  });

  QUnit.test( "Subtract S", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x5b156200], assert, 'S 1,200(5,6)');
    assert.equal(reg(1), 0x00045678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Halfword SH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x4b156200], assert, 'SH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 - 0x1230);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Logical SLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x1f120000], assert, 'SLR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Difference is zero (carry)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0xffffffff);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x111111111;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), 0xeeeeeeee);
    assert.equal(state['CR'], 3); // Non-zero, carry (no borrow)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x23456789;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), (0x12345678 - 0x23456789) >>> 0);
    assert.equal(state['CR'], 1); // Non-zero, no carry (borrow)
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0x12345678); // Unchanged
    assert.equal(state['CR'], 0); // Operands are equal
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0xfffffffe); // -2
    reg(2, 0xfffffffd); // -3
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0xfffffffe); // Unchanged
    assert.equal(state['CR'], 2); // First operand is high
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 2);
    reg(2, 3);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 2); // Unchanged
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "Compare C", function(assert) {
    reg(1, 0xf0000000);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12345678;
    execute([0x59156200], assert, 'C 1,200(5,6)');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "multiply MR: 28×19", function(assert) {
    reg(3, 28);
    reg(4, 19);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 28 * 19);
  });

  // Pseudo-random number generator from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript

  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  var rand = mulberry32(1);

  QUnit.test( "multiply MR: random", function(assert) {
    for (var i = 0; i < 100; i++) {
      var n1 = Math.trunc(rand() * 1000);
      var n2 = Math.trunc(rand() * 1000);
      if (n1 * n2 >= 0x10000) continue;
      if (n1 == 6) continue
      reg(3, n1);
      reg(4, n2);
      execute([0x1c240000], assert, 'MR 2,4');
      assert.equal(reg(2), 0, n1 + '×' + n2);
      assert.equal(reg(3), n1 * n2, n1 + '×' + n2);
    }
  });

  QUnit.test( "multiply MR: large", function(assert) {
    reg(3, 0x12345678);
    reg(4, 0x34567890);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3b8c7b8);
    assert.equal(reg(3), 0x3248e380);
  });

  QUnit.test( "multiply MR: larger", function(assert) {
    reg(3, 0x7fffffff);
    reg(4, 0x7fffffff);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3fffffff);
    assert.equal(reg(3), 0x00000001);
  });

  QUnit.test( "multiply MR: negative", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0xfffffffb); // -5
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 20);
  });

  QUnit.test( "multiply MR: negative, positive", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0x0000000a); // 10
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0xffffffff);
    assert.equal(reg(3), (-40) >>> 0);
  });

  QUnit.test( "Multiply M", function(assert) {
    reg(3, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5c256200], assert, 'M 2,200(5,6)');
    assert.equal(reg(2), 0x03b8c7b8); // High 32-bits
    assert.equal(reg(3), 0x3248e380); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH - small", function(assert) {
    reg(3, 4);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x00000003; // 3
    execute([0x4c356202], assert, 'MH 3,202(5,6)');
    assert.equal(reg(3), 12); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH", function(assert) {
    reg(3, 0x00000015); // 21
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xffd91111; // -39
    execute([0x4c356200], assert, 'MH 3,200(5,6)');
    assert.equal(reg(3), 0xfffffccd); // Low 32-bits
  });

  QUnit.test( "Divide DR big", function(assert) {
    reg(2, 0x00112233);
    reg(3, 0x44556677);
    reg(4, 0x12345678); // 0x1122334455667788 / 0x12345678
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    console.log('Quotient' + reg(3).toString(16));
    console.log('Remainder' + reg(2).toString(16));
    assert.equal(reg(2), 0x11b3d5f7); // Remainder
    assert.equal(reg(3), 0x00f0f0f0); // Quotient
  });

  QUnit.test( "Divide DR", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, 0x00000234);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), Math.floor(0x112345678 / 0x234)); // Quotient
  });

  QUnit.test( "Divide DR negative", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, (-0x00000234) >>> 0);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), (-Math.floor(0x112345678 / 0x234)) >>> 0); // Quotient
  });

  QUnit.test( "Divide D - overflow", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x23456789;
    assert.throws(function() {
      execute([0x5d256200], assert, 'D 2,200(5,6)');
    });
  });

  QUnit.test( "Divide D", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x73456789;
    execute([0x5d256200], assert, 'D 2,200(5,6)');
    assert.equal(reg(2), 0x50c0186a); // Remainder
    assert.equal(reg(3), 0x286dead6); // Quotient
  });

  QUnit.test( "Shift Left Single SLA", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2, i.e. 2.
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA extrabits", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2fc1], assert, 'SLA 1,fc1(2)'); // shift value is 6 bits, fc ignored
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0", function(assert) {
    reg(1, 0x12345678);
    execute([0x8b100000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0 negative", function(assert) {
    reg(1, 0x92345678);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x92345678); // Should be unchanged
    assert.equal(state['CR'], 1); // Negative
  });


  QUnit.test( "Shift Left Single SLA 0 zero", function(assert) {
    reg(1, 0);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Shift Left Single SLA: positive overflow", function(assert) {
    reg(1, 0x10000000);
    reg(2, 2); // Shift by 2 still fits
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x40000000);
    assert.equal(state['CR'], 2); // Positive

    reg(1, 0x10000000);
    reg(2, 3); // Shift by 3 overflows
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x00000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out by 32", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000020); // Shift by 32 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out negative", function(assert) {
    reg(1, 0x80000000);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: negative overflow", function(assert) {
    reg(1, 0x80000000);
    reg(2, 21); // Shift by 2 should overflow
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative-overflow", function(assert) {
    reg(1, 0x80000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0x80000004); // Keep the sign
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative", function(assert) {
    reg(1, 0xf0000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0xc0000004); // Keep the sign
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.skip( "Add Decimal AD", function(assert) {
    // add 12+ and 34+
    // Stored as 12a 34f (plus is a, c, e, f; minus is b, d)
    state['MS'][0x100] = 0x0012a000;
    state['MS'][0x104] = 0x034f0000;
    // 
    reg(1, 2);
    reg(2, 5);
    // First operand at 0x102, length 2. Second operand at 105, length 2.
    execute([0xfa221100, 0x21000000], assert, 'AD 100(2,1),100(2,2)');
    assert.equal(reg(4), 0x12344455);
    assert.equal(state['MS'][0x100],  0x046f0000); // result is 46
    assert.equal(state['MS'][0x104],  0x034f0000); // Unchanged
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Positive (FP long) LPDR", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x9abcdef0);
    execute([0x20400000], assert, 'LPDR 4,0');
    assert.equal(fpreg(4), 0x02345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Load Negative (FP long) LNDR", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x21400000], assert, 'LNDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Load and Test (FP) LTDR - positive", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x12345678);
    assert.equal(fpreg(5), 0x9abcdef0);
    assert.equal(state['CR'], 2); // Greater than zero
  });

  QUnit.test( "Load and Test (FP) LTDR - negative", function(assert) {
    fpreg(0, 0x92345678);
    fpreg(1, 0x9abcdef0);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
    assert.equal(state['CR'], 1); // Less than zero
  });

  QUnit.test( "Load and Test (FP) LTDR - zero negative", function(assert) {
    fpreg(0, 0xff000000);
    fpreg(1, 0x00000000);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0xff000000);
    assert.equal(fpreg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load and Test (FP) LTDR - zero positive", function(assert) {
    fpreg(0, 0x1f000000);
    fpreg(1, 0x00000000);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x1f000000);
    assert.equal(fpreg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement (FP long) LCDR", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x23400000], assert, 'LCDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.skip( "Halve (FP) HDR", function(assert) {
  });

  QUnit.test( "Load (FP long) LDR - bad register", function(assert) {
    assert.throws(function() {
      execute([0x28410000], assert, 'LDR 4,1');
    });
  });

  QUnit.test( "Load (FP long) LDR - bad register", function(assert) {
    assert.throws(function() {
      execute([0x28140000], assert, 'LDR 1,4');
    });
  });

  QUnit.skip( "Compare (FP) CDR", function(assert) {
  });

  QUnit.skip( "Add N (FP) ADR", function(assert) {
  });

  QUnit.skip( "Subtract N (FP) SDR", function(assert) {
  });

  QUnit.skip( "Multiply (FP) MDR", function(assert) {
  });

  QUnit.skip( "Divide (FP) DDR", function(assert) {
  });

  QUnit.skip( "Add U (FP) AWR", function(assert) {
  });

  QUnit.skip( "Subtract U (FP) SWR", function(assert) {
  });

  QUnit.skip( "Subtract U (FP) SWR", function(assert) {
  });

  QUnit.test( "Load Positive (FP short) LPER", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x30400000], assert, 'LPER 4,0');
    assert.equal(fpreg(0), 0x82345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x02345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load Negative (FP short) LNER -neg", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x31400000], assert, 'LNER 4,0');
    assert.equal(fpreg(0), 0x82345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x82345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load Negative (FP short) LNER -pos", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x31400000], assert, 'LNER 4,0');
    assert.equal(fpreg(0), 0x12345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load and Test (FP short) LTER - zero", function(assert) {
    fpreg(0, 0x12000000);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0x12000000);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x12000000);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load and Test (FP short) LTER - negative", function(assert) {
    fpreg(0, 0xc2345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0xc2345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0xc2345678);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load and Test (FP short) LTER - positive", function(assert) {
    fpreg(0, 0x00000001);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0x00000001);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x00000001);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement (FP short) LCER", function(assert) {
    fpreg(2, 0x12345678);
    fpreg(3, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x33420000], assert, 'LCER 4,2');
    assert.equal(fpreg(2), 0x12345678);
    assert.equal(fpreg(3), 0x33333333);
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load (FP short) LER", function(assert) {
    fpreg(2, 0x12345678); // Source
    fpreg(3, 0x9abcdef0);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0xaabbccdd);
    execute([0x38420000], assert, 'LER 4,2');
    assert.equal(fpreg(2), 0x12345678);
    assert.equal(fpreg(3), 0x9abcdef0);
    assert.equal(fpreg(4), 0x12345678);
    assert.equal(fpreg(5), 0xaabbccdd);
  });

  QUnit.test( "Load (FP short) LER - bad register", function(assert) {
    assert.throws(function() {
      execute([0x38120000], assert, 'LER 1,2');
    });
  });

  QUnit.test( "Load (FP short) LER - bad register", function(assert) {
    assert.throws(function() {
      execute([0x38410000], assert, 'LER 4,1');
    });
  });

  QUnit.skip("Compare (FP short) CER ", function(assert) {
  });

  QUnit.skip("Add N (FP short) ALR ", function(assert) {
  });

  QUnit.skip("Subtract N (FP short) SER ", function(assert) {
  });

  QUnit.skip("Multiply N (FP short) MER ", function(assert) {
  });

  QUnit.skip("Divide N (FP short) DER ", function(assert) {
  });

  QUnit.skip("Add U (FP short) AUR ", function(assert) {
  });

  QUnit.skip("Subtract U (FP short) SUR ", function(assert) {
  });

  QUnit.skip("Store STH ", function(assert) {
  });

  QUnit.skip("Load Address LA ", function(assert) {
  });

  QUnit.skip("Store Character STC", function(assert) {
  });

  QUnit.skip("Insert Character IC", function(assert) {
  });

  QUnit.skip("Execute EX", function(assert) {
  });

  QUnit.test( "Branch and link BAL", function(assert) {
    reg(3, 0x12300000);
    reg(4, 0x00045600);
    state['ILC'] = 0; // overwritten with 2
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x45134078], assert, 'BAL 1,78(3,4)');
    assert.equal(reg(1), 0xba000404); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.skip("Branch on Count BCT", function(assert) {
  });

  QUnit.skip("Branch/Condition BC", function(assert) {
  });

  QUnit.test( "Load Halfword LH sign-extend", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8765, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH sign-extend unaligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x202);
    state['MS'][0x1b84] = 0x07658321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8321, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH halfword aligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345986], assert, 'LH 3,986(4,5)');
    // LH 3, 986(4, 5): load R3 with mem[986+R4+R45)
    assert.equal(reg(3), 0x00004321, reg(3).toString(16));
  });

  QUnit.skip("Compare CH", function(assert) {
  });

  QUnit.skip("Add AH", function(assert) {
  });

  QUnit.skip("Subtract SH", function(assert) {
  });

  QUnit.skip("Multiply MH", function(assert) {
  });

  QUnit.test( "Convert to Binary CVB: princ op", function(assert) {
    // Example from Principles of Operation p122
    reg(5, 50); // Example seems to have addresses in decimal?
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 25594); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: bad sign", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x00255941; // 1 is not a valid sign
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  // Needs DC0 to support correction properly
  QUnit.skip( "Convert to Binary CVB: bad digit", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: doubleword unaligned", function(assert) {
    reg(5, 0);
    reg(6, 0);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756034], assert, 'CVB 7,34(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756031], assert, 'CVB 7,31(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000214;
    state['MS'][1004] = 0x8000000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.equal(reg(7), 2148000000); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: big overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x12345678;
    state['MS'][1004] = 0x4800000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: large", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000021;
    state['MS'][1004] = 0x2345678f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 212345678); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: negative", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594d; // d is negative
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), (-25594) >>> 0); // Note: decimal, not hex
  });

  // QE900/073C, CLF 112
  QUnit.test( "Convert to Binary CVB", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567f; // Decimal 1234567+
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), 1234567); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB neg", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567b; // Decimal 1234567-
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), (-1234567) >>> 0); // Note: decimal, not hex
  });

  QUnit.skip( "Convert to Decimal CVD", function(assert) {
  });

  QUnit.skip( "Store ST", function(assert) {
  });

  QUnit.skip( "AND N", function(assert) {
  });

  QUnit.skip( "Compare Logical CL", function(assert) {
  });

  QUnit.skip( "OR O", function(assert) {
  });

  QUnit.skip( "Exclusive OR X", function(assert) {
  });

  QUnit.skip( "Load L", function(assert) {
  });

  QUnit.skip( "Compare C", function(assert) {
  });

  QUnit.skip( "Compare C", function(assert) {
  });

  QUnit.skip("Add A", function(assert) {
  });

  QUnit.skip("Subtract C", function(assert) {
  });

  QUnit.skip("Multiply M", function(assert) {
  });

  QUnit.skip("Divide D", function(assert) {
  });

  QUnit.skip("Add Logical AL", function(assert) {
  });

  QUnit.skip("Subtracdt Logical SL", function(assert) {
  });

  QUnit.skip("Store (FP long) STD", function(assert) {
  });

  QUnit.skip("Load (FP long) LD", function(assert) {
  });

  QUnit.skip("Compare (FP long) CD", function(assert) {
  });

  QUnit.skip("Add N (FP long )AD", function(assert) {
  });

  QUnit.skip("Subtract N (FP long) SD", function(assert) {
  });

  QUnit.skip("Multiply (FP long) MD", function(assert) {
  });

  QUnit.skip("Divide (FP long) DD", function(assert) {
  });

  QUnit.skip("Add U (FP long) AW", function(assert) {
  });

  QUnit.skip("Subtract U (FP long) SW", function(assert) {
  });

  QUnit.skip("Store (FP short) STE", function(assert) {
  });

  QUnit.skip("Load (FP short) LE", function(assert) {
  });

  QUnit.skip("Compare (FP short) CE", function(assert) {
  });

  QUnit.skip("Add N (FP short )AE", function(assert) {
  });

  QUnit.skip("Subtract N (FP short) SE", function(assert) {
  });

  QUnit.skip("Multiply (FP short) ME", function(assert) {
  });

  QUnit.skip("Divide (FP short) DE", function(assert) {
  });

  QUnit.skip("Add U (FP short) AU", function(assert) {
  });

  QUnit.skip("Subtract U (FP short) SU", function(assert) {
  });

  QUnit.skip("Set System Mask SSM", function(assert) {
  });

  QUnit.test("Load PSW LPSW", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x9a123450; // Branch to 123450
    execute([0x82003100], assert, 'LPSW 100(3)');
    assert.equal(state['SYSMASK'], 0x12);
    assert.equal(state['KEY'], 0x3);
    assert.equal(state['AMWP'], 0x4);
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0xa);
    assert.equal(state['IAR'], 0x123450);
  });

  QUnit.skip( "Diagnose", function(assert) {
    reg(2, 3); // Counter
    execute([0x83123456], assert, 'diagnose');
  });

  QUnit.skip("Write Direct WRD", function(assert) {
  });

  QUnit.skip("Read Direct RDD", function(assert) {
  });

  QUnit.skip("Branch/High BXH", function(assert) {
  });

  QUnit.skip("Branch/Low-Equal BXLE", function(assert) {
  });

  QUnit.test( "Shift Left Single SLL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x891f2100], assert, 'SLL 1,100(2)');
    assert.equal(reg(1), 0x11a2b3c0);
  });

  QUnit.test( "Shift Right Single SRL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x881f2100], assert, 'SRL 1,100(2)');
    assert.equal(reg(1), 0x82345678 >>> 3);
  });

  QUnit.skip("Shift Right S SRA", function(assert) {
  });

  QUnit.skip("Shift Left S SLA", function(assert) {
  });

  QUnit.skip("Shift Right DL SRDL", function(assert) {
  });

  QUnit.skip("Shift Left DL SLDL", function(assert) {
  });

  QUnit.skip("Shift Right D SRDA", function(assert) {
  });

  QUnit.skip("Shift Left D SLDA", function(assert) {
  });

  QUnit.skip("Store Multiple STM", function(assert) {
  });

  QUnit.skip("Test Under Mask TM", function(assert) {
  });

  QUnit.test("Move immediate MVI", function(assert) {
    reg(1, 0x123456);
    state['CR'] = 2;
    state['MS'][0x123464] = 0x12345678;
    execute([0x92421010], assert, 'MVI 10(1),42');
    assert.equal(state['MS'][0x123464], 0x12344278);
    assert.equal(state['CR'], 2); // Unchanged
  });

  QUnit.test("AND immediate NI", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x94f01010], assert, 'NI 10(1),f0');
    assert.equal(state['MS'][0x123464], 0x12345078);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("AND immediate NI - zero", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x94001010], assert, 'NI 10(1),0');
    assert.equal(state['MS'][0x123464], 0x12340078);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test("Compare Logical immediate CLI - equal", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x95561010], assert, 'CLI 10(1),56');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test("Compare Logical immediate CLI - low", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x95ff1010], assert, 'CLI 10(1),ff');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test("Compare Logical immediate CLI - all", function(assert) {
    for (var i = 0; i < 256; i++) {
      reg(1, 0x123456);
      state['MS'][0x123464] = 0x12345678;
      execute([0x95001010 | (i << 16)], assert, 'CLI 10(1),' + i.toString(16));
      if (i == 0x56) {
        assert.equal(state['CR'], 0); // Equal
      } else if (i < 0x56) {
        assert.equal(state['CR'], 2); // First operand is high
      } else {
        assert.equal(state['CR'], 1); // First operand is low
      }
    }
  });

  QUnit.test("OR immediate OI", function(assert) {
    reg(1, 2);
    state['MS'][0x1000] = 0x12345678;
    execute([0x96421fff], assert, 'OI fff(1),42');
    assert.equal(state['MS'][0x1000], 0x12765678);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("Exclusive OR immediate XI", function(assert) {
    reg(0, 0x100); // Not used
    state['MS'][0x120] = 0x12345678;
    execute([0x970f0123], assert, 'XI 123(0),f');
    assert.equal(state['MS'][0x120], 0x12345677);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.skip("Start I/O SIO", function(assert) {
  });

  QUnit.skip("Test I/O TIO", function(assert) {
  });

  QUnit.skip("Halt I/O HIO", function(assert) {
  });

  QUnit.skip("Test Channel TCH", function(assert) {
  });

  QUnit.skip("Move Numeric MVN", function(assert) {
  });

  QUnit.test( "Move MVC", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x200] = 0x11223344;
    execute([0xd2030100, 0x02000000], assert, 'MVC 100(3,0),200(0)'); // Move 4 bytes from 200 to 100
    assert.equal(state['MS'][0x100], 0x11223344);
    assert.equal(state['MS'][0x200], 0x11223344); // Unchanged
  });

  QUnit.test( "Move MVC 2", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x104] = 0xabcdef01;
    reg(1, 2);
    reg(2, 0);
    execute([0xd2011100, 0x01050000], assert, 'MVC 100(1,1),105(0)'); // Move 2 bytes from 105 to 102
    assert.equal(state['MS'][0x100], 0x1234cdef);
    assert.equal(state['MS'][0x104], 0xabcdef01); // Unchanged
  });

  QUnit.skip("Move Zone MVZ", function(assert) {
  });

  QUnit.skip("AND NC", function(assert) {
  });

  QUnit.skip("Compare Logical CLC", function(assert) {
  });

  QUnit.skip("OR OC", function(assert) {
  });

  QUnit.skip("Exclusive OR XC", function(assert) {
  });

  QUnit.skip("Translate TR", function(assert) {
  });

  QUnit.skip("Translate and Test TRT", function(assert) {
  });

  QUnit.skip("Edit ED", function(assert) {
  });

  QUnit.skip("Edit and Mark EDMK", function(assert) {
  });

  QUnit.skip("Move with Offset MVO", function(assert) {
  });

  QUnit.skip("Pack PACK", function(assert) {
  });

  QUnit.skip("Unpack UNPK", function(assert) {
  });

  QUnit.skip( "Zero and Add ZAP", function(assert) {
    state['MS'][0x100] = 0x2a000000; // 2+
    state['MS'][0x200] = 0x3a000000; // 3+
    execute([0xf8110100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x100],  0x3a000000); // 3+
  });

  QUnit.skip( "Zero and Add ZAP offset", function(assert) {
    state['MS'][0x100] = 0x02a00000; // 2+
    state['MS'][0x200] = 0x0003a000; // 3+
    execute([0xf8110100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x101],  0x3a000000); // 3+
  });

  QUnit.skip("Compare CP", function(assert) {
  });

  QUnit.skip("Add AP", function(assert) {
  });

  QUnit.skip("Subtract SP", function(assert) {
  });

  QUnit.skip("Multiply MP", function(assert) {
  });

  QUnit.skip("Divide DP", function(assert) {
  });

  QUnit.test( "Load Multiple LM", function(assert) {
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x11223344;
    state['MS'][0x118] = 0x55667788;
    state['MS'][0x11c] = 0x99aabbcc;
    execute([0x98253100], assert, 'LM 2,5,100(3)');
    // Load registers 2 through 5 starting at 0x110
    assert.equal(reg(2), 0x12345678);
    assert.equal(reg(3), 0x11223344);
    assert.equal(reg(4), 0x55667788);
    assert.equal(reg(5), 0x99aabbcc);
  });

  QUnit.test( "Move MVI", function(assert) {
    state['MS'][0x100] = 0x11223344;
    reg(1, 1);
    execute([0x92551100], assert, 'MVI 100(1),55'); // Move byte 55 to location 101
    assert.equal(state['MS'][0x100], 0x11553344);
  });

  QUnit.test( "Compare Logical CLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 0); // equal

    reg(1, 0x12345678);
    reg(2, 0x12345679);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 1); // first operand is low

    reg(1, 0x12345679);
    reg(2, 0x12345678);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 2); // first operand is high

    reg(1, 0x7fffffff);
    reg(2, 0x8fffffff);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 1); // first operand is low
  });

  QUnit.test( "Compare Logical CL", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x100);
    reg(3, 0x100);
    state['MS'][0x300] = 0x12345678;
    execute([0x55123100], assert, 'CL 1,100(2,3)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test( "Compare Logical CLC - equal", function(assert) {
    reg(1, 0x100);
    reg(2, 0x100);
    state['MS'][0x200] = 0x12345633;
    state['MS'][0x300] = 0x12345644;
    execute([0xd5021100, 0x22000000], assert, 'CLC 100(2,1),200(2)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test( "Compare Logical CLC", function(assert) {
    reg(1, 0x100);
    reg(2, 0x100);
    state['MS'][0x200] = 0x12345678;
    state['MS'][0x300] = 0x12345678;
    // 123456 vs 345678 because of offset
    execute([0xd5021100, 0x22010000], assert, 'CLC 100(2,1),201(2)');
    assert.equal(state['CR'], 1); // first operand is low
  });

  QUnit.test( "And NR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0x12005600);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "And NR 0", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0xedcba987);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Or OR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x16120000], assert, 'OR 1,2');
    assert.equal(reg(1), 0xff34ff78);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive or XR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x17120000], assert, 'XR 1,2');
    assert.equal(reg(1), 0xed34a978);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Shift Left Single SLL various", function(assert) {
    for (var i = 0; i < 40; i++) {
      reg(1, 1);
      reg(2, 0x12340000 + i); // Shift i bits
      execute([0x891f2100], assert, 'SLL 1,100(2)');
      if (i < 32) {
        assert.equal(reg(1), (1 << i) >>> 0, 'Shift by ' + i);
      } else {
        assert.equal(reg(1), 0, 'Shift by ' + i);
      }
    }
  });

  QUnit.test( "Branch on condition BCR", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on condition BCR, always taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07f10000], assert, 'BCR 15,1'); // always
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on condition BCR, not taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 1;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch and link BALR", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    reg(2, 0x12345678); // Branch destination
    execute([0x05120000], assert, 'BALR 1,2');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch and link BALR -not taken", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x05100000], assert, 'BALR 1,0');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch on Count BCTR - taken", function(assert) {
    reg(1, 3); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 2);
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on Count BCTR - taken, negative", function(assert) {
    reg(1, 0); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0xffffffff);
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on Count BCTR - not taken", function(assert) {
    reg(1, 1); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Set Program Mask SPM", function(assert) {
    reg(1, 0x12345678); // Mask 2
    execute([0x041f0000], assert, 'SPM 1');
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0x2);
  });

  QUnit.test( "Supervisor Call SVC", function(assert) {
    // Need more testing here
    assert.throws(function() {
      execute([0x0a120000], assert, 'SVC 12');
    });
  });

  QUnit.test( "Set Storage Key SSK - no priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    assert.throws(function() {
      execute([0x08120000], assert, 'SSK 1,2');
    });
  });

  QUnit.test( "Set Storage Key SSK - priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(1, 0x11223344); // Key
    reg(2, 0x12345670); // Address: last 4 bits must be 0
    execute([0x08120000], assert, 'SSK 1,2');
    assert.equal(state['KEYS'][0x12345678 & 0x00fff100], 4);
  });

  QUnit.test( "Set Storage Key SSK - unaligned", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(1, 0x11223344); // Key
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x08120000], assert, 'SSK 1,2');
    });
  });

  // ISK reads the storage key
  QUnit.test( "Insert Storage Key ISK -priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0x89abcdef);
    reg(2, 0x12345670); // Aligned: last 4 bits 0
    execute([0x09120000], assert, 'ISK 1,2');
    assert.equal(reg(1), 0x89abcd20);
  });

  QUnit.test( "Insert Storage Key ISK -no priv", function(assert) {
    state['AMWP'] = 1; // Unprivileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0xaabbccdd);
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x09120000], assert, 'ISK 1,2');
    });
  });

  QUnit.test( "Insert Storage Key ISK -unaligned", function(assert) {
    state['AMWP'] = 0; // Privileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0xaabbccdd);
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x09120000], assert, 'ISK 1,2');
    });
  });

  QUnit.test( "Test and Set - not set TS", function(assert) {
    reg(2, 2); // Index
    state['MS'][0x100] = 0x83857789; // 102 top bit not set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 0); // Not set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });

  QUnit.test( "Test and Set - set TS", function(assert) {
    reg(2, 2); // Index
    state['MS'][0x100] = 0x8385c789; // 102 top bit set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 1); // Set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });
});
</script>
</body>
</html>
