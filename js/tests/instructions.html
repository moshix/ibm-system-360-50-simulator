<!DOCTYPE html>
<html>
<!--
Test instructions on the 360 simulator.
-->
<head>
  <meta charset="utf-8">
  <title>Instruction unittests</title>
  <link rel="stylesheet" href="qunit-2.9.2.css" >
  <script src="data.js"></script>
  <script src="../out/utils.js"></script>
  <script src="../out/disasm.js"></script>
  <script src="../out/decode.js"></script>
  <script src="../out/engine.js"></script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>

  <script src="qunit-2.9.2.js"></script>
  <script>

QUnit.config.collapse = false; // Expand all failures

// Log test name to console
QUnit.testStart(function(test) {
  var module = test.module ? test.module : '';
  console.log('-----' + module + " " + test.name + "-----");
});

// Override alert so simulator will stop if an error is hit.
// https://stackoverflow.com/questions/1729501/javascript-overriding-alert
(function(proxied) {
window.alert = function() {
  running = 0; // Stop the simulator
  throw(arguments[0]);
  console.log('stopping ' + arguments[0]);
  return proxied.apply(this, arguments);
};
})(window.alert);

var state;

// *** Number of cycles for randomized tests
testcycles = 1;

// Read or write register
function reg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][0x30 + num];
  } else {
    state['LS'][0x30 + num] = data;
  }
}

// Read or write half FP register
function fpreg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][0x20 + num];
  } else {
    state['LS'][0x20 + num] = data;
  }
}

// Convert a floating point value to a 64-bit FP register.
function floatToFpreg(num, val) {
  if (val == 0) {
    fpreg(num, 0);
    fpreg(num + 1, 0);
    return;
  }
  var s = 0;
  if (val < 0) {
    s = 0x80000000;
    val = -val;
  }
  var charac = 64;
  while (val >= 1 && charac < 128) {
    charac += 1;
    val /= 16;
  }
  while (val < 1/16. && charac >= 0) {
    charac -= 1;
    val *= 16;
  }
  if (charac < 0 || charac >= 128) {
    alert('Float over/underflow');
  }
  val *= 2**24;
  var f0 = Math.trunc(val);
  var w0 = (s | (charac << 24) | f0) >>> 0;
  var w1 = Math.trunc((val - f0) * 2**32);
  fpreg(num, w0);
  fpreg(num + 1, w1);
}

// Convert a float from a 32-bit FP register
function fpreg32ToFloat(num) {
  var w0 = fpreg(num);
  if ((w0 & 0x00ffffff) == 0) {
    return 0;
  }
  var charac = (((w0 & 0x7f000000) >>> 24) - 64) * 4; // power of 2
  var frac = w0 & 0x00ffffff;
  var val = frac * 2 ** (charac - 24);
  if (w0 & 0x80000000) {
    val = -val;
  }
  return val;
}

// Convert a float from a 64-bit FP register
function fpreg64ToFloat(num) {
  var w0 = fpreg(num);
  var w1 = fpreg(num + 1);
  if ((w0 & 0x00ffffff) == 0 && w1 == 0) {
    return 0;
  }
  var charac = (((w0 & 0x7f000000) >>> 24) - 64) * 4; // power of 2
  var frac = (w0 & 0x00ffffff) + (w1 / 2**32);
  var val = frac * 2 ** (charac - 24);
  if (w0 & 0x80000000) {
    val = -val;
  }
  return val;
}

// Returns 32-bit as a signed value
function signed32(n) {
  if (n & 0x80000000) {
    return -(0x100000000 - n);
  } else {
    return n;
  }
}

// Convert words to halfwords
function hw(words) {
  var result = [];
  for (var i = 0; i < words.length; i++) {
    result.push(words[i] >>> 16);
    result.push(words[i] & 0xffff);
  }
  return result;
}

// Pseudo-random number generator from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
// Call this with a seed to get a random number generator.
// Generates number between 0 and 1.

function mulberry32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}

// Return random 32-bit number generator function
function rand32(a) {
  return function() {
    var t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return (t ^ t >>> 14) >>> 0;
  }
}

// Return a random floating point number scaled roughly to 2**-powRange to 2**powRange
function randfloat(rand, powRange) {
  if (powRange == undefined) {
    powRange = 200;
  }
  var f = rand() + rand() / 2**32;
  var pow = Math.floor((rand() * powRange * 2) - powRange);
  var f = f * 2**pow * 4;
  if (rand() < .5) {
    f = -f;
  }
  return f;
}

var running;
// Load instruction(s) into memory at 0x400 and execute.
function execute(instr, assert, desired) {
  command = disasm(hw(instr));
  console.log(command);
  assert.equal(command.replace(/ /g, ''), desired.replace(/ /g, '', desired), desired);
  // Load instruction into memory
  for (var i = 0; i < instr.length; i++) {
    state['MS'][0x400 + i * 4] = instr[i];
  }
  state['IAR'] = 0x400;
  state['ROAR'] = 0x0197;
  running = 1;
  executeInstr();
}

maxcount = 100;

// Execute one instruction
function executeInstr(instr) {
  for (var count = 0; count < maxcount; count++) {
    // Log micro-instruction
    var saddr = fmtAddress(state['ROAR']);
    console.log(decode(saddr, testdata[saddr]).join('\n'));
    // Execute micro-instruction
    cycle(state, testdata[saddr]);
    if (!running) { // emulator problem bailout
      alert('Bailing out');
      return;
    }

    // Check validity
    var keys = Object.keys(state);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (typeof state[key] == 'number' && state[key] < 0) {
        alert('Negative value for state ' + key + ' ' + state[key]);
      }
    }

    console.log('L: ' + state['L'].toString(16) +
      ', R: ' + state['R'].toString(16) +
      ', M: ' + state['M'].toString(16) +
      ', T: ' + state['T'].toString(16) +
      ', F: ' + state['F'].toString(16) +
      ', H: ' + state['H'].toString(16) +
      ', J: ' + state['J'].toString(16) +
      ', U: ' + state['U'].toString(16) +
      ', V: ' + state['V'].toString(16) +
      ', W: ' + state['W'].toString(16) +
      ', LB: ' + state['LB'].toString(16) +
      ', MB: ' + state['MB'].toString(16) +
      ', MD: ' + state['MD'].toString(16) +
      ', G1: ' + state['G1'].toString(16) +
      ', G2: ' + state['G2'].toString(16) +
      ', IAR: ' + state['IAR'].toString(16) +
      ', LSAR: ' + state['LSAR'].toString(16) +
      ', SGNS: ' + state['LSGNS'] + ' ' + state['RSGNS'] +
      ', S: ' + state['S'] +
      ', BS: ' + state['BS'] +
      ', CR: ' + state['CR'] +
      ', CSTAT: ' + state['CSTAT'] +
      ', CAR: ' + state['CAR']);
    // Check if done
    if (count > 5 && [0x149, 0x14a, 0x14c, 0x14e, 0x184, 0x185, 0x187, 0x188, 0x189, 0x19b].includes(state['ROAR'])) {
      return;
    }
    if (count > 8 && [0x148].includes(state['ROAR'])) {
      return;
    }
    if (state['TRAP']) {
      console.log("********** TRAP **********");
      throw('TRAP');
      return;
    }
    if ([0x218, 0x195, 0x19c, 0x1b0, 0x1b4, 0x1b8, 0x1b1, 0x1b3, 0x1b5, 0x1b7, 0x10e, 0x10f].includes(state['ROAR'])) {
      console.log('********** Exception ' + state['ROAR'].toString(16) + ' **********');
      console.log('IAR: ' + state['IAR']);
      throw('Exception');
      return;
    }
  }
  throw('Count exceeded');
}

QUnit.module("Utilities", function(hooks) {
  hooks.beforeEach(function(assert) {
    state = createState();
  });

  QUnit.test( "fp conversion", function(assert) {
    floatToFpreg(0, 0.0);
    assert.equal(fpreg(0), 0);
    assert.equal(fpreg(1), 0);

    // From Princ Ops page 157
    floatToFpreg(0, 1.0);
    assert.equal(fpreg(0), 0x41100000);
    assert.equal(fpreg(1), 0);

    floatToFpreg(0, 0.5);
    assert.equal(fpreg(0), 0x40800000);
    assert.equal(fpreg(1), 0);

    floatToFpreg(0, 1/64);
    assert.equal(fpreg(0), 0x3f400000);
    assert.equal(fpreg(1), 0);

    floatToFpreg(0, -15);
    assert.equal(fpreg(0), 0xc1f00000);
    assert.equal(fpreg(1), 0);
  });

  QUnit.test( "fp 32 conversion", function(assert) {
    fpreg(0, 0);
    assert.equal(fpreg32ToFloat(0), 0);

    fpreg(0, 0xff000000);
    assert.equal(fpreg32ToFloat(0), 0);

    fpreg(0, 0x41100000);
    assert.equal(fpreg32ToFloat(0), 1.0);

    fpreg(0, 0x40800000);
    assert.equal(fpreg32ToFloat(0), .5);

    fpreg(0, 0x3f400000);
    assert.equal(fpreg32ToFloat(0), 1/64);

    fpreg(0, 0xc1f00000);
    assert.equal(fpreg32ToFloat(0), -15);

    var rand = mulberry32(1);
    for (var i = 0; i < 20; i++) {
      var f = rand();
      var pow = Math.floor((rand() * 400) - 200);
      var f = f * 2**pow;
      if (rand() > .5) {
        f = -f;
      }
      floatToFpreg(0, f);
      console.log(f);
      var fp = fpreg32ToFloat(0);
      // Compare within tolerance
      var ratio = Math.abs((fp - f) / f);
      assert.ok(ratio < .000001, fp + ' ' + f);
    }
  });

  QUnit.test( "fp 64 conversion", function(assert) {
    fpreg(0, 0);
    fpreg(1, 0);
    assert.equal(fpreg64ToFloat(0), 0);

    fpreg(0, 0xff000000);
    fpreg(1, 0);
    assert.equal(fpreg64ToFloat(0), 0);

    fpreg(0, 0x41100000);
    fpreg(1, 0);
    assert.equal(fpreg64ToFloat(0), 1.0);

    fpreg(0, 0x40800000);
    fpreg(1, 0);
    assert.equal(fpreg64ToFloat(0), .5);

    fpreg(0, 0x3f400000);
    fpreg(1, 0);
    assert.equal(fpreg64ToFloat(0), 1/64);

    fpreg(0, 0xc1f00000);
    fpreg(1, 0);
    assert.equal(fpreg64ToFloat(0), -15);

    floatToFpreg(0, Math.PI);
    assert.equal(fpreg64ToFloat(0), Math.PI);

    var rand = mulberry32(1);
    for (var i = 0; i < 20; i++) {
      var f = rand();
      var pow = Math.floor((rand() * 400) - 200);
      var f = f * 2**pow;
      if (rand() > .5) {
        f = -f;
      }
      floatToFpreg(0, f);
      console.log(f);
      assert.equal(fpreg64ToFloat(0), f, f);
    }
  });

  // Roughly test characteristics of random number generator
  QUnit.test( "randfloat", function(assert) {
    var rand = mulberry32(5);
    var pos = 0, neg = 0;
    var big = 0, small = 0;
    for (var i = 0; i < 100; i++) {
      var f = randfloat(rand);
      if (f < 0) {
        neg ++;
      } else {
        pos ++;
      }
      if (Math.abs(f) > 2**100) {
        big++;
      } else if (Math.abs(f) < 2**-100) {
        small++;
      } 
    }
    assert.ok(pos > 30, pos + " > 30");
    assert.ok(neg > 30, neg + " > 30");
    assert.ok(big > 15, big + " > 15");
    assert.ok(small > 15, small + " > 15");

    // Test scaling
    big = 0;
    small = 0;
    for (var i = 0; i < 100; i++) {
      var f = randfloat(rand, 10);
      if (f < 0) {
        neg ++;
      } else {
        pos ++;
      }
      if (Math.abs(f) > 2**10) {
        big++;
      } else if (Math.abs(f) < 2**-10) {
        small++;
      } 
    }
    assert.ok(big < 8, big + " < 8");
    assert.ok(small < 8, small + " < 8");
  });

  QUnit.test( "signed32", function(assert) {
    assert.equal(signed32(0x12345678), 0x12345678);
    assert.equal(signed32(0xffffffff), -1);
    assert.equal(signed32(0xfffffff0), -16);
  });

});

// Called from CHCTL
function chctl(state, entry) {
  chctl_w = state['W'];
}

QUnit.module("Instructions", function(hooks) {
  hooks.beforeEach(function(assert) {
    state = createState();
  });

  QUnit.test( "Load LR", function(assert) {
    reg(1, 0x12345678);
    execute([0x18310000], assert, 'LR 3,1');
    assert.equal(reg(3), 0x12345678);
  });

  QUnit.test( "Load and Test LTR", function(assert) {
    reg(4, 0xcdef1234);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0xcdef1234);
    assert.equal(state['CR'], 1); // Negative

    reg(4, 0);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero

    reg(4, 0x12345678);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR negative", function(assert) {
    reg(4, 0x1000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0xfffff000);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Complement LCR positive", function(assert) {
    reg(4, 0xffffffff);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR zero", function(assert) {
    reg(4, 0);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement LCR overflow", function(assert) {
    state['PROGMASK'] = 0; // Disable overflow interrupt
    reg(4, 0x80000000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Load Positive LPR", function(assert) {
    reg(4, 0xffffffff);
    execute([0x10340000], assert, 'LPR 3,4');
    // LPR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Negative LNR positive", function(assert) {
    reg(4, 0x12345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xedcba988);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR negative", function(assert) {
    reg(4, 0xc2345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xc2345678);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR 0", function(assert) {
    reg(4, 0);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "AR add", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000005);
    execute([0x1a120000], assert, 'AR 1,2');
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x1234567d);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "AR two adds", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    reg(3, 0x00000010);
    execute([0x1a121a31], assert, 'AR 1,2');
    executeInstr(); // Run the second instruction
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x12345679);
    assert.equal(reg(3), 0x12345689);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "AR add-negative", function(assert) {
    reg(1, 0x81234567);
    reg(2, 0x00000001);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x81234568);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "AR add-zero", function(assert) {
    reg(1, 0x00000002);
    reg(2, 0xfffffffe);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "AR add-overflow-trap-disabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 0; // Disable overflow interrupt
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "AR add-overflow-trap-enabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 8; // Enable overflow interrupt
    assert.throws(function() {
      execute([0x1a120000], assert, 'AR 1,2');
      console.log('no throw');
    });
  });

  QUnit.test( "add A", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5a156200], assert, 'A 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x34567890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000202);
    state['MS'][0x500] = 0x34567890; // Only 7890 used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x7890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH sign extend", function(assert) {
    reg(1, 1);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xfffe1234; // only fffe (-2) used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0xffffffff); // -1
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Add Logical ALR (i.e. unsigned) - zero no carry ", function(assert) {
    reg(1, 0);
    reg(2, 0);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero, no carry
  });

  QUnit.test( "Add Logical ALR - non-zero no carry ", function(assert) {
    reg(1, 0xffff0000);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0xffff0002);
    assert.equal(state['CR'], 1); // Nonzero, no carry
  });

  QUnit.test( "Add Logical ALR - zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Zero and carry
  });


  QUnit.test( "Add Logical ALR - not zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000003);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 1);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "Add Logical AL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xf0000000;
    execute([0x5e156200], assert, 'AL 1,200(5,6)');
    assert.equal(reg(1), 0x02345678);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "SR subtract", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x1b120000], assert, 'SR 1,2');
    assert.equal(reg(1), 0x12345677);
  });

  QUnit.test( "Subtract S", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x5b156200], assert, 'S 1,200(5,6)');
    assert.equal(reg(1), 0x00045678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Halfword SH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x4b156200], assert, 'SH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 - 0x1230);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Logical SLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x1f120000], assert, 'SLR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Difference is zero (carry)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0xffffffff);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x11111111;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), 0xeeeeeeee);
    assert.equal(state['CR'], 3); // Non-zero, carry (no borrow)
  });

  QUnit.test( "Subtract Logical SL b", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x23456789;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), (0x12345678 - 0x23456789) >>> 0);
    assert.equal(state['CR'], 1); // Non-zero, no carry (borrow)
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0x12345678); // Unchanged
    assert.equal(state['CR'], 0); // Operands are equal
  });

  QUnit.test( "Compare CR b", function(assert) {
    reg(1, 0xfffffffe); // -2
    reg(2, 0xfffffffd); // -3
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0xfffffffe); // Unchanged
    assert.equal(state['CR'], 2); // First operand is high
  });

  QUnit.test( "Compare CR c", function(assert) {
    reg(1, 2);
    reg(2, 3);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 2); // Unchanged
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "Compare C", function(assert) {
    reg(1, 0xf0000000);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12345678;
    execute([0x59156200], assert, 'C 1,200(5,6)');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "multiply MR: 28×19", function(assert) {
    reg(3, 28);
    reg(4, 19);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 28 * 19);
  });

  QUnit.test( "multiply MR: random", function(assert) {
    var rand = mulberry32(1);
    for (var i = 0; i < testcycles; i++) {
      var n1 = Math.trunc(rand() * 1000);
      var n2 = Math.trunc(rand() * 1000);
      if (n1 * n2 >= 0x10000) continue;
      if (n1 == 6) continue
      reg(3, n1);
      reg(4, n2);
      execute([0x1c240000], assert, 'MR 2,4');
      assert.equal(reg(2), 0, n1 + '×' + n2);
      assert.equal(reg(3), n1 * n2, n1 + '×' + n2);
    }
  });

  QUnit.test( "multiply MR: large", function(assert) {
    reg(3, 0x12345678);
    reg(4, 0x34567890);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3b8c7b8);
    assert.equal(reg(3), 0x3248e380);
  });

  QUnit.test( "multiply MR: larger", function(assert) {
    reg(3, 0x7fffffff);
    reg(4, 0x7fffffff);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3fffffff);
    assert.equal(reg(3), 0x00000001);
  });

  QUnit.test( "multiply MR: negative", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0xfffffffb); // -5
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 20);
  });

  QUnit.test( "multiply MR: negative, positive", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0x0000000a); // 10
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0xffffffff);
    assert.equal(reg(3), (-40) >>> 0);
  });

  QUnit.test( "Multiply M", function(assert) {
    reg(3, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5c256200], assert, 'M 2,200(5,6)');
    assert.equal(reg(2), 0x03b8c7b8); // High 32-bits
    assert.equal(reg(3), 0x3248e380); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH - small", function(assert) {
    reg(3, 4);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x00000003; // 3
    execute([0x4c356202], assert, 'MH 3,202(5,6)');
    assert.equal(reg(3), 12); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH", function(assert) {
    reg(3, 0x00000015); // 21
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xffd91111; // -39
    execute([0x4c356200], assert, 'MH 3,200(5,6)');
    assert.equal(reg(3), 0xfffffccd); // Low 32-bits
  });

  QUnit.test( "Divide DR big", function(assert) {
    reg(2, 0x00112233);
    reg(3, 0x44556677);
    reg(4, 0x12345678); // 0x1122334455667788 / 0x12345678
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    console.log('Quotient' + reg(3).toString(16));
    console.log('Remainder' + reg(2).toString(16));
    assert.equal(reg(2), 0x11b3d5f7); // Remainder
    assert.equal(reg(3), 0x00f0f0f0); // Quotient
  });

  QUnit.test( "Divide DR", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, 0x00000234);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), Math.floor(0x112345678 / 0x234)); // Quotient
  });

  QUnit.test( "Divide DR negative", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, (-0x00000234) >>> 0);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), (-Math.floor(0x112345678 / 0x234)) >>> 0); // Quotient
  });

  QUnit.test( "Divide D - overflow", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x23456789;
    assert.throws(function() {
      execute([0x5d256200], assert, 'D 2,200(5,6)');
    });
  });

  QUnit.test( "Divide D", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x73456789;
    execute([0x5d256200], assert, 'D 2,200(5,6)');
    assert.equal(reg(2), 0x50c0186a); // Remainder
    assert.equal(reg(3), 0x286dead6); // Quotient
  });

  QUnit.test( "Shift Left Single SLA", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2, i.e. 2.
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA extrabits", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2fc1], assert, 'SLA 1,fc1(2)'); // shift value is 6 bits, fc ignored
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0", function(assert) {
    reg(1, 0x12345678);
    execute([0x8b100000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0 negative", function(assert) {
    reg(1, 0x92345678);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x92345678); // Should be unchanged
    assert.equal(state['CR'], 1); // Negative
  });


  QUnit.test( "Shift Left Single SLA 0 zero", function(assert) {
    reg(1, 0);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Shift Left Single SLA: positive overflow", function(assert) {
    reg(1, 0x10000000);
    reg(2, 2); // Shift by 2 still fits
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x40000000);
    assert.equal(state['CR'], 2); // Positive

    reg(1, 0x10000000);
    reg(2, 3); // Shift by 3 overflows
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x00000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out by 32", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000020); // Shift by 32 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out negative", function(assert) {
    reg(1, 0x80000000);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: negative overflow", function(assert) {
    reg(1, 0x80000000);
    reg(2, 21); // Shift by 2 should overflow
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative-overflow", function(assert) {
    reg(1, 0x80000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0x80000004); // Keep the sign
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative", function(assert) {
    reg(1, 0xf0000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0xc0000004); // Keep the sign
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Add Decimal AP - small", function(assert) {
    state['MS'][0x100] = 0x0000002c; // 2+
    state['MS'][0x200] = 0x00003c00; // 3+
    execute([0xfa000103, 0x02020000], assert, 'AP 103(1,0),202(1,0)');
    assert.equal(state['MS'][0x100],  0x0000005c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - 1 byte", function(assert) {
    state['MS'][0x100] = 0x2888011c; // 2888011+
    state['MS'][0x200] = 0x1112292c; // 1112292+
    execute([0xfa330100, 0x02000000], assert, 'AP 100(4,0),200(4,0)');
    assert.equal(state['MS'][0x100],  0x4000303c); // 4000303+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - 1 byte - small", function(assert) {
    state['MS'][0x100] = 0x0000002c; // 2+
    state['MS'][0x200] = 0x0000003c; // 3+
    execute([0xfa330100, 0x02000000], assert, 'AP 100(4,0),200(4,0)');
    assert.equal(state['MS'][0x100],  0x0000005c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - offset", function(assert) {
    state['MS'][0x100] = 0x0043212c; // 2+
    state['MS'][0x200] = 0x0023413c; // 3+
    execute([0xfa220101, 0x02010000], assert, 'AP 101(3,0),201(3,0)');
    assert.equal(state['MS'][0x100],  0x0066625c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - no offset", function(assert) {
    state['MS'][0x100] = 0x0043212c; // 2+
    state['MS'][0x200] = 0x0023413c; // 3+
    execute([0xfa330100, 0x02000000], assert, 'AP 100(4,0),200(4,0)');
    assert.equal(state['MS'][0x100],  0x0066625c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP", function(assert) {
    // Example from Princ Ops p136.2
    reg(12, 0x00002000);
    reg(13, 0x000004fd);
    state['MS'][0x2000] = 0x38460d00; // 38460-
    state['MS'][0x500] = 0x0112345c; // 112345+
    execute([0xfa23c000, 0xd0030000], assert, 'AP 0(3,12),3(4,13)');
    assert.equal(state['MS'][0x2000],  0x73885c00); // 73885+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Positive (FP long) LPDR", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x9abcdef0);
    execute([0x20400000], assert, 'LPDR 4,0');
    assert.equal(fpreg(4), 0x02345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Load Negative (FP long) LNDR", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x21400000], assert, 'LNDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Load and Test (FP) LTDR - positive", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x12345678);
    assert.equal(fpreg(5), 0x9abcdef0);
    assert.equal(state['CR'], 2); // Greater than zero
  });

  QUnit.test( "Load and Test (FP) LTDR - negative", function(assert) {
    fpreg(0, 0x92345678);
    fpreg(1, 0x9abcdef0);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
    assert.equal(state['CR'], 1); // Less than zero
  });

  QUnit.test( "Load and Test (FP) LTDR - zero negative", function(assert) {
    fpreg(0, 0xff000000);
    fpreg(1, 0x00000000);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0xff000000);
    assert.equal(fpreg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load and Test (FP) LTDR - zero positive", function(assert) {
    fpreg(0, 0x1f000000);
    fpreg(1, 0x00000000);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x1f000000);
    assert.equal(fpreg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement (FP long) LCDR", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x23400000], assert, 'LCDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Halve (FP) HDR", function(assert) {
    fpreg(2, 0x12123456);
    fpreg(3, 0xabcdef00);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x1191a2b5, fpreg64ToFloat(0) + ' ' + fpreg64ToFloat(2));
    assert.equal(fpreg(1), 0x5e6f7800);
  });

  QUnit.test( "Halve (FP) HDR - guard bit used after normalizing", function(assert) {
    fpreg(2, 0x12123456);
    fpreg(3, 0xabcdef01);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x1191a2b5);
    assert.equal(fpreg(1), 0x5e6f7808);
  });

  QUnit.test( "Halve (FP) HDR - simple", function(assert) {
    fpreg(2, 0x12aa8844);
    fpreg(3, 0x22884422);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x12554422);
    assert.equal(fpreg(1), 0x11442211);
  });

  QUnit.test( "Halve (FP) HDR - shift across word", function(assert) {
    fpreg(2, 0x12aa8845);
    fpreg(3, 0x22884422);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x12554422);
    assert.equal(fpreg(1), 0x91442211);
  });

  QUnit.test( "Halve (FP) HDR underflow", function(assert) {
    fpreg(2, 0x00000000);
    fpreg(3, 0x00000001);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x00000000);
    assert.equal(fpreg(1), 0x00000000);
  });

  QUnit.test( "Halve (FP) HDR zero", function(assert) {
    fpreg(2, 0x12000000);
    fpreg(3, 0x00000000);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x00000000);
    assert.equal(fpreg(1), 0x00000000);
  });

  QUnit.test( "Halve (FP) HDR random", function(assert) {
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f = randfloat(rand);
      floatToFpreg(2, f);
      execute([0x24020000], assert, 'HDR 0,2');
      var f1 = fpreg64ToFloat(0);
      assert.equal(f / 2, f1);
    }
  });

  QUnit.test( "Load (FP long) LDR - bad register", function(assert) {
    assert.throws(function() {
      execute([0x28410000], assert, 'LDR 4,1');
    });
  });

  QUnit.test( "Load (FP long) LDR - bad register b", function(assert) {
    assert.throws(function() {
      execute([0x28140000], assert, 'LDR 1,4');
    });
  });

  QUnit.test( "Compare (FP) CDR", function(assert) {
    fpreg(4, 0x43000000);
    fpreg(5, 0x00000000);
    fpreg(6, 0x34123456);
    fpreg(7, 0x789abcde);
    execute([0x2946ffff], assert, 'CDR 4,6');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test( "Add N (FP) ADR", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x2a020000], assert, 'ADR 0,2');
      var fres = fpreg64ToFloat(0);
      assert.equal(fres, f1 - f2);
    }
  });

  QUnit.test( "Subtract N (FP) SDR", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x2b020000], assert, 'SDR 0,2');
      var fres = fpreg64ToFloat(0);
      assert.equal(fres, f1 - f2);
    }
  });

  QUnit.test( "Multiply (FP) MDR", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand);
      var f2 = randfloat(rand);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x2c020000], assert, 'MDR 0,2');
      var fres = fpreg64ToFloat(0);
      assert.equal(fres, f1 * f2);
    }
  });

  QUnit.test( "Divide (FP) DDR", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x2d020000], assert, 'DDR 0,2');
      var fres = fpreg64ToFloat(0);
      assert.equal(fres, f1 / f2);
    }
  });

  QUnit.test( "Add U (FP) AWR", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x2e020000], assert, 'AWR 0,2');
      var fres = fpreg64ToFloat(0);
      assert.equal(fres, f1 + f2);
    }
  });

  QUnit.test( "Subtract U (FP) SWR", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x2f020000], assert, 'SWR 0,2');
      var fres = fpreg64ToFloat(0);
      assert.equal(fres, f1 - f2);
    }
  });

  QUnit.test( "Load Positive (FP short) LPER", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x30400000], assert, 'LPER 4,0');
    assert.equal(fpreg(0), 0x82345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x02345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load Negative (FP short) LNER -neg", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x31400000], assert, 'LNER 4,0');
    assert.equal(fpreg(0), 0x82345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x82345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load Negative (FP short) LNER -pos", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x31400000], assert, 'LNER 4,0');
    assert.equal(fpreg(0), 0x12345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load and Test (FP short) LTER - zero", function(assert) {
    fpreg(0, 0x12000000);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0x12000000);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x12000000);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load and Test (FP short) LTER - negative", function(assert) {
    fpreg(0, 0xc2345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0xc2345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0xc2345678);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load and Test (FP short) LTER - positive", function(assert) {
    fpreg(0, 0x00000001);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0x00000001);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x00000001);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement (FP short) LCER", function(assert) {
    fpreg(2, 0x12345678);
    fpreg(3, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x33420000], assert, 'LCER 4,2');
    assert.equal(fpreg(2), 0x12345678);
    assert.equal(fpreg(3), 0x33333333);
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Halve (FP short) HER", function(assert) {
    fpreg(2, 0x12345678); // Source
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x121a2b3c);
  });

  QUnit.test( "Halve (FP short) HER - unnormalized", function(assert) {
    fpreg(2, 0x18000008); // Source: 8 is unnormalized
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x13400000);
  });

  QUnit.test( "Halve (FP short) HER - result needs normalizing", function(assert) {
    fpreg(2, 0x18100000); // Result will be 18080000, normalized to 17800000
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x17800000);
  });

  QUnit.test( "Halve (FP short) HER - zero", function(assert) {
    fpreg(2, 0x00000000); // standard zero
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x00000000);
  });

  QUnit.test( "Halve (FP short) HER - nonstandard zero", function(assert) {
    fpreg(2, 0x95000000); // nonstandard zero
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x00000000);
  });

  QUnit.test( "Halve (FP short) HER - underflow", function(assert) {
    fpreg(2, 0x00000001);
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x00000000);
  });

  QUnit.test( "Load (FP short) LER", function(assert) {
    fpreg(2, 0x12345678); // Source
    fpreg(3, 0x9abcdef0);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0xaabbccdd);
    execute([0x38420000], assert, 'LER 4,2');
    assert.equal(fpreg(2), 0x12345678);
    assert.equal(fpreg(3), 0x9abcdef0);
    assert.equal(fpreg(4), 0x12345678);
    assert.equal(fpreg(5), 0xaabbccdd);
  });

  QUnit.test( "Load (FP short) LER - bad register", function(assert) {
    assert.throws(function() {
      execute([0x38120000], assert, 'LER 1,2');
    });
  });

  QUnit.test( "Load (FP short) LER - bad register b", function(assert) {
    assert.throws(function() {
      execute([0x38410000], assert, 'LER 4,1');
    });
  });

  QUnit.test("Compare (FP short) CER equal ", function(assert) { // F
    fpreg(4, 0x12345678);
    fpreg(2, 0x12345678);
    execute([0x39420000], assert, 'CER 4,2');
    assert.equal(state['CR'], 0);
  });

  QUnit.test("Compare (FP short) CER greater ", function(assert) {
    fpreg(4, 0x12345679);
    fpreg(2, 0x12345678);
    execute([0x39420000], assert, 'CER 4,2');
    assert.equal(state['CR'], 2);
  });

  QUnit.test("Compare (FP short) CER less ", function(assert) { // F
    fpreg(4, 0x92345678);
    fpreg(2, 0x12345678);
    execute([0x39420000], assert, 'CER 4,2');
    assert.equal(state['CR'], 1);
  });

  QUnit.test("Add N (FP short) AER ", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < 1; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      f1 = 1;
      f2 = 2;
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x3a020000], assert, 'AER 0,2');
      var fres = fpreg32ToFloat(0);
      var wanted = f1 + f2;
      var ratio = Math.abs((fres - wanted) / wanted);
      assert.ok(ratio < .000001, fres + ' ' + wanted);
      if (wanted == 0) {
        assert.equal(state['CR'], 1);
      } else if (wanted > 0) {
        assert.equal(state['CR'], 2);
      } else {
        assert.equal(state['CR'], 1);
      }
    }
  });

  QUnit.test("Subtract N (FP short) SER ", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x3b020000], assert, 'SER 0,2');
      var fres = fpreg32ToFloat(0);
      var wanted = f1 - f2;
      var ratio = Math.abs((fres - wanted) / wanted);
      assert.ok(ratio < .000001, fres + ' ' + wanted);
    }
  });

  QUnit.test("Multiply N (FP short) MER ", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x3c020000], assert, 'MER 0,2');
      var fres = fpreg64ToFloat(0);
      var wanted = f1 * f2;
      var ratio = Math.abs((fres - wanted) / wanted);
      assert.ok(ratio < .000001, fres + ' ' + wanted);
    }
  });

  QUnit.test("Divide N (FP short) DER ", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x3d020000], assert, 'DER 0,2');
      var fres = fpreg64ToFloat(0);
      var wanted = f1 / f2;
      var ratio = Math.abs((fres - wanted) / wanted);
      assert.ok(ratio < .000001, fres + ' ' + wanted);
    }
  });

  QUnit.test("Add U (FP short) AUR ", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x3e020000], assert, 'AUR 0,2');
      var fres = fpreg64ToFloat(0);
      var wanted = f1 + f2;
      var ratio = Math.abs((fres - wanted) / wanted);
      assert.ok(ratio < .000001, fres + ' ' + wanted);
    }
  });

  QUnit.test("Subtract U (FP short) SUR ", function(assert) { // F
    var rand = mulberry32(100);
    for (var i = 0; i < testcycles; i++) {
      var f1 = randfloat(rand, 64);
      var f2 = randfloat(rand, 64);
      floatToFpreg(0, f1);
      floatToFpreg(2, f2);
      execute([0x3f020000], assert, 'SUR 0,2');
      var fres = fpreg64ToFloat(0);
      var wanted = f1 - f2;
      var ratio = Math.abs((fres - wanted) / wanted);
      assert.ok(ratio < .000001, fres + ' ' + wanted);
    }
  });

  QUnit.test("Store halfword STH ", function(assert) {
    reg(3, 0xaabbccdd);
    reg(4, 1);
    reg(5, 1);
    state['MS'][0x1000] = 0x12345678;
    execute([0x40345ffe], assert, 'STH 3,ffe(4,5)');
    assert.equal(state['MS'][0x1000], 0xccdd5678);
  });

  QUnit.test("Store halfword STH +2", function(assert) {
    reg(3, 0xaabbccdd);
    reg(4, 1);
    reg(5, 3);
    state['MS'][0x1000] = 0x12345678;
    execute([0x40345ffe], assert, 'STH 3,ffe(4,5)');
    assert.equal(state['MS'][0x1000], 0x1234ccdd);
  });

  QUnit.test("Store halfword STH odd", function(assert) {
    reg(3, 0xaabbccdd);
    reg(4, 1);
    reg(5, 2);
    state['MS'][0x1000] = 0x12345678;
    assert.throws(function() {
      execute([0x40345ffe], assert, 'STH 3,ffe(4,5)');
    });
  });

  QUnit.test("Load Address LA", function(assert) {
    // From Princ Ops p147
    execute([0x41100800], assert, 'LA 1,800(0,0)');
    assert.equal(reg(1), 2048);
  });

  QUnit.test("Load Address LA b", function(assert) {
    // From Princ Ops p147
    reg(5, 0x00123456);
    execute([0x4150500a], assert, 'LA 5,a(0,5)');
    assert.equal(reg(5), 0x00123460);
  });

  QUnit.test("Store Character STC", function(assert) {
    for (var i = 0; i < 4; i++) { // Test all 4 offsets
      reg(5, 0xffffff12); // Only 12 used
      reg(1, i);
      state['MS'][0x100] = 0xaabbccdd;
      execute([0x42501100], assert, 'STC 5,100(0,1)');
      var shift = (3 - i) * 8;
      var desired = ((0xaabbccdd & ~(0xff << shift)) | (0x12 << shift)) >>> 0;
      assert.equal(state['MS'][0x100], desired);
    }
  });

  QUnit.test("Insert Character IC", function(assert) {
    for (var i = 0; i < 4; i++) { // Test all 4 offsets
      reg(5, 0xaabbccdd);
      reg(1, i);
      state['MS'][0x100] = 0x00112233;
      execute([0x43501100], assert, 'IC 5,100(0,1)');
      var desired = (0xaabbcc00 | (i * 17)) >>> 0;
      assert.equal(reg(5), desired);
    }
  });

  QUnit.test("Execute EX", function(assert) {
    state['MS'][0x100] = 0x1a000000; // Target instruction AR 0,0
    reg(1, 0x00000045); // Modification: AR 4,5
    reg(4, 0x100);
    reg(5, 0x200);
    execute([0x44100100], assert, 'EX 1,100(0,0)');
    assert.equal(reg(4), 0x300);
  });

  QUnit.test("Execute EX double execute", function(assert) {
    state['MS'][0x100] = 0x44100100; // Target instruction EX 1,100(0,0)
    reg(1, 0x00000045); // Modification: EX 4,100(5,0)
    assert.throws(function() {
      execute([0x44100100], assert, 'EX 1,100(0,0)');
    });
  });

  QUnit.test( "Branch and link BAL", function(assert) {
    reg(3, 0x12300000);
    reg(4, 0x00045600);
    state['ILC'] = 0; // overwritten with 2
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x45134078], assert, 'BAL 1,78(3,4)');
    assert.equal(reg(1), 0xba000404); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test("Branch on Count BCT taken", function(assert) {
    reg(1, 3); // Counter
    reg(2, 0x00345678); // Branch destination
    reg(3, 0x00000010);
    execute([0x46123100], assert, 'BCT 1,100(2,3)');
    assert.equal(reg(1), 2);
    assert.equal(state['IAR'], 0x00345788);
  });

  QUnit.test("Branch/Condition BC", function(assert) {
    var rand = rand32();
    for (var i = 0; i < 16; i++) {
      state['CR'] = rand() & 3;
      execute([0x47000100 | (i << 20)], assert, 'BC ' + i + ',100(0,0)');
      if (((i & 8) && (state['CR'] == 0)) ||
          ((i & 4) && (state['CR'] == 1)) ||
          ((i & 2) && (state['CR'] == 2)) ||
          ((i & 1) && (state['CR'] == 3))) {
        // Taken
        assert.equal(state['IAR'], 0x100);
      } else {
        assert.equal(state['IAR'], 0x404);
      }
    }
  });

  QUnit.test( "Load Halfword LH sign-extend", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8765, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH sign-extend unaligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x202);
    state['MS'][0x1b84] = 0x07658321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8321, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH halfword aligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345986], assert, 'LH 3,986(4,5)');
    // LH 3, 986(4, 5): load R3 with mem[986+R4+R45)
    assert.equal(reg(3), 0x00004321, reg(3).toString(16));
  });

  QUnit.test("Compare Halfword CH equal", function(assert) {
    reg(3, 0x00005678);
    state['MS'][0x100] = 0x5678abcd;
    execute([0x49300100], assert, 'CH 3,100(0,0)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test("Compare Halfword CH equal extend", function(assert) {
    reg(3, 0xffff9678);
    state['MS'][0x100] = 0x9678abcd;
    execute([0x49300100], assert, 'CH 3,100(0,0)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test("Compare Halfword CH high", function(assert) {
    reg(3, 0x00001235);
    state['MS'][0x100] = 0x1234abcd;
    execute([0x49300100], assert, 'CH 3,100(0,0)');
    assert.equal(state['CR'], 2); // First operand high
  });

  QUnit.test("Compare Halfword CH high extend", function(assert) {
    reg(3, 0x00001235);
    state['MS'][0x100] = 0x8234abcd;
    execute([0x49300100], assert, 'CH 3,100(0,0)');
    assert.equal(state['CR'], 2); // First operand high
  });

  QUnit.test("Compare Halfword CH low neg", function(assert) {
    reg(3, 0x80001235);
    state['MS'][0x100] = 0x1234abcd;
    execute([0x49300100], assert, 'CH 3,100(0,0)');
    assert.equal(state['CR'], 1); // First operand low
  });

  QUnit.test("Compare Halfword CH low neg extend", function(assert) {
    reg(3, 0xfffffffc);
    state['MS'][0x100] = 0xfffd0000;
    execute([0x49300100], assert, 'CH 3,100(0,0)');
    assert.equal(state['CR'], 1); // First operand low
  });

  // Halfword second operand is sign-extended and added to first register.
  QUnit.test("Add halfword AH", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0x1234eeee;
    execute([0x4a300200], assert, 'AH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 + 0x1234);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Add halfword AH negative", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0xfffe9999; // -2
    execute([0x4a300200], assert, 'AH 3,200(0,0)');
    assert.equal(reg(3), 0x12345676);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Add halfword AH +2", function(assert) {
    reg(3, 0x12345678);
    reg(1, 2);
    state['MS'][0x200] = 0x99991234;
    execute([0x4a310200], assert, 'AH 3,200(1,0)');
    assert.equal(reg(3), 0x12345678 + 0x1234);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Subtract halfword AH", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0x1234eeee;
    execute([0x4b300200], assert, 'SH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 - 0x1234);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Multiply halfword MH", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0x00059999; // 5
    execute([0x4c300200], assert, 'MH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 * 5);
  });

  QUnit.test("Multiply halfword MH negatives ", function(assert) {
    reg(3, (-0x12345678) >>> 0);
    state['MS'][0x200] = 0xfffb9999; // -5
    execute([0x4c300200], assert, 'MH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 * 5);
  });

  QUnit.test( "Convert to Binary CVB: princ op", function(assert) {
    // Example from Principles of Operation p122
    reg(5, 50); // Example seems to have addresses in decimal?
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 25594); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: bad sign", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x00255941; // 1 is not a valid sign
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  // Needs DC0 to support correction properly
  QUnit.test( "Convert to Binary CVB: bad digit", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: doubleword unaligned", function(assert) {
    reg(5, 0);
    reg(6, 0);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756034], assert, 'CVB 7,34(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756031], assert, 'CVB 7,31(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000214;
    state['MS'][1004] = 0x8000000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.equal(reg(7), 2148000000); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: big overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x12345678;
    state['MS'][1004] = 0x4800000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: large", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000021;
    state['MS'][1004] = 0x2345678f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 212345678); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: negative", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594d; // d is negative
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), (-25594) >>> 0); // Note: decimal, not hex
  });

  // QE900/073C, CLF 112
  QUnit.test( "Convert to Binary CVB", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567f; // Decimal 1234567+
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), 1234567); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB neg", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567b; // Decimal 1234567-
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), (-1234567) >>> 0); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Decimal CVD", function(assert) { // F
    // Princ Ops p142
    reg(1, 0x00000f0f); // 3855 dec
    reg(13, 0x00007600);
    state['AMWP'] = 0; // EBCDIC
    execute([0x4e10d008], assert, 'CVD 1,8(0,13)');
    assert.equal(state['MS'][0x7608], 0x00000000);
    assert.equal(state['MS'][0x760c], 0x0003855c);
  });

  QUnit.test( "Convert to Decimal CVD ASCII", function(assert) { // F
    reg(1, 0x00000f0f); // 3855 dec
    reg(13, 0x00007600);
    state['AMWP'] = 8; // ASCII
    execute([0x4e10d008], assert, 'CVD 1,8(0,13)');
    assert.equal(state['MS'][0x7608], 0x00000000);
    assert.equal(state['MS'][0x760c], 0x0003855d);
  });

  QUnit.test( "Store ST", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x100);
    reg(3, 0x100);
    execute([0x50123400], assert, 'ST 1,400(2,3)');
    assert.equal(state['MS'][0x600], 0x12345678);
  });

  QUnit.test( "AND N", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x12345678;
    execute([0x54123454], assert, 'N 1,454(2,3)');
    assert.equal(reg(1), (0x11223344 & 0x12345678) >>> 0);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Compare Logical CL", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x900] = 0x12345678;
    execute([0x55123400], assert, 'CL 1,400(2,3)');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test( "OR O", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x12345678;
    execute([0x56123454], assert, 'O 1,454(2,3)');
    assert.equal(reg(1), (0x11223344 | 0x12345678) >>> 0);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive OR X", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x12345678;
    execute([0x57123454], assert, 'X 1,454(2,3)');
    assert.equal(reg(1), (0x11223344 ^ 0x12345678) >>> 0);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive OR X - zero", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x11223344;
    execute([0x57123454], assert, 'X 1,454(2,3)');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load L", function(assert) {
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x12345678;
    execute([0x58345984], assert, 'L 3,984(4,5)');
    // L 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0x12345678);
  });

  QUnit.test( "Compare C b", function(assert) {
    reg(3, 0x12345678);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x12345678;
    execute([0x59345984], assert, 'C 3,984(4,5)');
    assert.equal(state['CR'], 0); // Operands are equal
  });

  QUnit.test("Add A random", function(assert) {
    var rand = rand32(42);
    for (var i = 0; i < testcycles; i++) {
      var n1 = rand();
      var n2 = rand();
      reg(1, n1);
      state['MS'][0x100] = n2;
      execute([0x5a100100], assert, 'A 1,100(0,0)');
      var sum = signed32(n1) + signed32(n2);
      if (sum >= 0x80000000 || sum < -0x80000000) {
        assert.equal(state['CR'], 3); // Overflow
        continue;
      } else if (sum == 0) {
        assert.equal(state['CR'], 0); // Zero
      } else if (sum > 0) {
        assert.equal(state['CR'], 2); // Positive
      } else {
        assert.equal(state['CR'], 1); // Negative
      }
      assert.equal(signed32(reg(1)), sum);
    }
  });

  QUnit.test("Subtract C random", function(assert) {
    var rand = rand32(43);
    for (var i = 0; i < testcycles; i++) {
      var n1 = rand();
      var n2 = rand();
      reg(1, n1);
      state['MS'][0x100] = n2;
      execute([0x5b100100], assert, 'S 1,100(0,0)');
      var result = signed32(n1) - signed32(n2);
      if (result >= 0x80000000 || result < -0x80000000) {
        assert.equal(state['CR'], 3); // Overflow
        continue;
      } else if (result == 0) {
        assert.equal(state['CR'], 0); // Zero
      } else if (result > 0) {
        assert.equal(state['CR'], 2); // Positive
      } else {
        assert.equal(state['CR'], 1); // Negative
      }
      assert.equal(signed32(reg(1)), result);
    }
  });

  QUnit.test("Multiply M random", function(assert) {
    var rand = rand32(43);
    for (var i = 0; i < testcycles; i++) {
      var n1 = rand();
      var n2 = rand();
      reg(3, n1); // Note: multiplicand in reg 3 but reg 2 specified.
      state['MS'][0x100] = n2;
      execute([0x5c200100], assert, 'M 2,100(0,0)');
      var desired = signed32(n1) * signed32(n2);
      var result = reg(2) * 2**32 + reg(3);
      if (reg(2) & 0x80000000) {
        // Convert 64-bit 2's complement
        result = -((~reg(2)) * 2**32 + ((~reg(3)) >>> 0) + 1);
      }
      var info = signed32(n1) + '*' + signed32(n2) + '=' + desired + ' vs ' + result;
      info += '  ' + reg(2).toString(16) + ' ' + reg(3).toString(16);
      assert.equal(result, desired, info);
      if (result != desired) break;
      // No condition code
    }
  });

  QUnit.test("Divide D random", function(assert) { // F
    var rand = rand32(43);
    for (var i = 0; i < testcycles; i++) {
      var quotient = rand();
      var remainder = rand();
      var divisor = rand();
      if (quotient * divisor * remainder < 0) {
        remainder = -remainder;
      }
      var dividend = quotient * divisor + remainder;
      // XXX Need to implement this
      reg(2, n1);
      state['MS'][0x100] = n2;
      execute([0x5d200100], assert, 'D 2,100(0,0)');
      var result = signed32(n1) * signed32(n2);
      if (result == 0) {
        assert.equal(state['CR'], 0); // Zero
      } else if (result > 0) {
        assert.equal(state['CR'], 2); // Positive
      } else {
        assert.equal(state['CR'], 1); // Negative
      }
      var result0 = Math.trunc(result / 2**32);
      assert.equal(reg(2), result0);
      var result1 = result - result0 * 2**32;
      assert.equal(reg(3), result1);
    }
  });

  QUnit.test("Add Logical AL random", function(assert) {
    var rand = rand32(44);
    for (var i = 0; i < testcycles; i++) {
      var n1 = rand();
      var n2 = rand();
      reg(2, n1);
      state['MS'][0x100] = n2;
      execute([0x5e200100], assert, 'AL 2,100(0,0)');
      var result = n1 + n2;
      var carry = 0;
      if (result >= 0x100000000) {
        carry = 1;
        result -= 0x100000000;
      }
      if (carry == 0) {
        if (result == 0) {
          assert.equal(state['CR'], 0); // Zero, no carry
        } else {
          assert.equal(state['CR'], 1); // Nonzero, no carry
        }
      } else {
        if (result == 0) {
          assert.equal(state['CR'], 2); // Zero, carry
        } else {
          assert.equal(state['CR'], 3); // Nonzero, carry
        }
      }
      assert.equal(reg(2), result);
    }
  });

  QUnit.test("Subtract Logical SL random", function(assert) {
    var rand = rand32(44);
    for (var i = 0; i < testcycles; i++) {
      var n1 = rand();
      var n2 = rand();
      reg(2, n1);
      state['MS'][0x100] = n2;
      execute([0x5f200100], assert, 'SL 2,100(0,0)');
      var result = n1 + ((n2 ^ 0xffffffff) >>> 0) + 1;
      var carry = 0;
      if (result >= 0x100000000) {
        carry = 1;
        result -= 0x100000000;
      }
      if (carry == 0) {
        if (result == 0) {
          assert.equal(state['CR'], 0); // Zero, no carry
        } else {
          assert.equal(state['CR'], 1); // Nonzero, no carry
        }
      } else {
        if (result == 0) {
          assert.equal(state['CR'], 2); // Zero, carry
        } else {
          assert.equal(state['CR'], 3); // Nonzero, carry
        }
      }
      assert.equal(reg(2), result);
    }
  });

  QUnit.test("Store (FP long) STD", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    execute([0x60012100], assert, 'STD 0,100(1,2)');
    assert.equal(state['MS'][0x500], 0x12345678);
    assert.equal(state['MS'][0x504], 0xaabbccdd);
  });

  QUnit.test("Load (FP long) LD", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x104] = 0xaabbccdd;
    execute([0x68000100], assert, 'LD 0,100(0,0)');
    assert.equal(fpreg(0), 0x12345678);
    assert.equal(fpreg(1), 0xaabbccdd);
  });

  QUnit.test("Load (FP long) LD unnormalized", function(assert) {
    state['MS'][0x100] = 0x44000000;
    state['MS'][0x104] = 0xaabbccdd;
    execute([0x68000100], assert, 'LD 0,100(0,0)');
    assert.equal(fpreg(0), 0x44000000); // Stays unnormalized
    assert.equal(fpreg(1), 0xaabbccdd);
  });

  QUnit.test("Compare (FP long) CD", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    state['MS'][0x100] = 0x44000000;
    state['MS'][0x104] = 0xaabbccdd;
    execute([0x69000100], assert, 'CD 0,100(0,0)');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test("Add N (FP long) AD", function(assert) { // F
    // Princ Ops 153
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x6a60d000], assert, 'AD 6,0(0, 13)');
    assert.equal(fpreg(6), 0x42833345);
    assert.equal(fpreg(7), 0x60000000);
  });

  QUnit.test("Subtract N (FP long) SD", function(assert) { // F
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x6b60d000], assert, 'SD 6,0(0, 13)');
    assert.equal(fpreg(6), 0x42833345);
    assert.equal(fpreg(7), 0x60000000);
  });

  QUnit.test("Multiply (FP long) MD", function(assert) { // F
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x6c60d000], assert, 'MD 6,0(0, 13)');
    assert.equal(fpreg(6), 0x42833345);
  });

  QUnit.test("Divide (FP long) DD", function(assert) { // F
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x6d60d000], assert, 'DD 6,0(0, 13)');
    assert.equal(fpreg(6), 0x42833345);
  });

  QUnit.test("Add U (FP long) AW", function(assert) { // F
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x7e60d000], assert, 'AU 6,0(0, 13)');
    assert.equal(fpreg(6), 0x42833345);
  });

  QUnit.test("Subtract U (FP long) SW", function(assert) { // F
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x7f60d000], assert, 'SU 6,0(0, 13)');
    assert.equal(fpreg(6), 0x42833345);
  });

  QUnit.test("Store (FP short) STE", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x404] = 0x11223344;
    execute([0x70012100], assert, 'STE 0,100(1,2)');
    assert.equal(state['MS'][0x500], 0x12345678);
    assert.equal(state['MS'][0x504], 0x11223344);
  });

  QUnit.test("Load (FP short) LE", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x500] = 0x11223344;
    execute([0x78012100], assert, 'LE 0,100(1,2)');
    assert.equal(fpreg(0), 0x11223344);
    assert.equal(fpreg(1), 0xaabbccdd);
  });

  QUnit.test("Compare (FP short) CE", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x500] = 0x11223344;
    execute([0x79012100], assert, 'CE 0,100(1,2)');
    assert.equal(fpreg(0), 0x11223344);
  });

  QUnit.test("Add N (FP short) AE", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x500] = 0x11223344;
    execute([0x7a012100], assert, 'AE 0,100(1,2)');
    assert.equal(fpreg(0), 0x11223344);
  });

  QUnit.test("Subtract N (FP short) SE", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x500] = 0x11223344;
    execute([0x7b012100], assert, 'SE 0,100(1,2)');
    assert.equal(fpreg(0), 0x11223344);
  });

  QUnit.test("Multiply (FP short) ME", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x500] = 0x11223344;
    execute([0x7c012100], assert, 'ME 0,100(1,2)');
    assert.equal(fpreg(0), 0x11223344);
  });

  QUnit.test("Divide (FP short) DE", function(assert) { // F
    fpreg(0, 0x12345678);
    fpreg(1, 0xaabbccdd);
    reg(1, 0x100);
    reg(2, 0x300);
    state['MS'][0x500] = 0x11223344;
    execute([0x7d012100], assert, 'DE 0,100(1,2)');
    assert.equal(fpreg(0), 0x11223344);
  });

  QUnit.test("Add U (FP short) AU", function(assert) { // F
    // Princ Ops 153
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x7e60d000], assert, 'AU 6,0(0, 13)');
    assert.equal(fpreg(6), 0x43083334);
  });

  QUnit.test("Subtract U (FP short) SU", function(assert) { // F
    fpreg(6, 0x43082100);
    fpreg(7, 0x00000000);
    state['MS'][0x2000] = 0x41123456;
    state['MS'][0x2004] = 0x00000000;
    reg(13, 0x00002000);
    execute([0x7f60d000], assert, 'SU 6,0(0, 13)');
    assert.equal(fpreg(6), 0x43083334);
  });

  QUnit.test("Set System Mask SSM", function(assert) {
    state['SYSMASK'] = 0xff;
    state['KEY'] = 3;
    state['AMWP'] = 0xe; // Privileged
    state['CR'] = 1;
    state['PROGMASK'] = 0xa;
    reg(3, 0x11);
    state['MS'][0x110] = 0xaabbccdd; // Access byte 1
    execute([0x80ee3100], assert, 'SSM 100(3)');
    assert.equal(state['SYSMASK'], 0xbb);
    assert.equal(state['KEY'], 0x3);
    assert.equal(state['AMWP'], 0xe);
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0xa);
    assert.equal(state['IAR'], 0x404);
  });

  QUnit.test("Set System Mask SSM unprivileged", function(assert) {
    state['SYSMASK'] = 0xff;
    state['KEY'] = 3;
    state['AMWP'] = 0xf; // Unrivileged
    state['CR'] = 1;
    state['PROGMASK'] = 0xa;
    assert.throws(function() {
      execute([0x80ee3100], assert, 'SSM 100(3)');
    });
  });

  QUnit.test("Load PSW LPSW", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x9a123450; // Branch to 123450
    execute([0x82003100], assert, 'LPSW 100(3)');
    assert.equal(state['SYSMASK'], 0x12);
    assert.equal(state['KEY'], 0x3);
    assert.equal(state['AMWP'], 0x4);
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0xa);
    assert.equal(state['IAR'], 0x123450);
  });

  QUnit.test( "Diagnose", function(assert) { // F
    reg(2, 3); // Counter
    execute([0x83123456], assert, 'diagnose');
  });

  QUnit.test("Write Direct WRD", function(assert) {
    state['AMWP'] = 1; // Privileged
    // Direct control not supported in this microcode
    assert.throws(function() {
      execute([0x84123456], assert, 'WRD 456(3), 12');
    });
  });

  QUnit.test("Read Direct RDD", function(assert) {
    state['AMWP'] = 1; // Privileged
    // Direct control not supported in this microcode
    assert.throws(function() {
      execute([0x85123456], assert, 'RDD 456(3), 12');
    });
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 1); // Increment
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x86142200], assert, 'BXH 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH decrement", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 0xffffffff); // Increment -1
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x86142200], assert, 'BXH 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH shared reg", function(assert) {
    reg(1, 1); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x86132200], assert, 'BXH 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH shared reg not taken", function(assert) {
    reg(1, 0xffffffff); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x86132200], assert, 'BXH 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 1); // Increment
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x87142200], assert, 'BXLE 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE decrement", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 0xffffffff); // Increment -1
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x87142200], assert, 'BXLE 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE shared reg", function(assert) {
    reg(1, 1); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x87132200], assert, 'BXLE 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE shared reg taken", function(assert) {
    reg(1, 0xffffffff); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x87132200], assert, 'BXLE 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  QUnit.test( "Shift Left Single SLL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x891f2100], assert, 'SLL 1,100(2)');
    assert.equal(reg(1), 0x11a2b3c0);
  });

  QUnit.test( "Shift Right Single SRL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x881f2100], assert, 'SRL 1,100(2)');
    assert.equal(reg(1), 0x82345678 >>> 3);
  });

  QUnit.test("Shift Right Single SRA", function(assert) {
    reg(2, 0x11223344);
    execute([0x8a2f0105], assert, 'SRA 2,105(0)'); // Shift right 5
    assert.equal(reg(2), 0x0089119a);
  });

  QUnit.test("Shift Left S SLA", function(assert) {
    // From Princ Ops p143
    reg(2, 0x007f0a72);
    execute([0x8b2f0008], assert, 'SLA 2,8(0)'); // Shift left 8
    assert.equal(reg(2), 0x7f0a7200);
  });

  QUnit.test("Shift Right Double SRDL", function(assert) {
    reg(4, 0x12345678);
    reg(5, 0xaabbccdd);
    execute([0x8c4f0118], assert, 'SRDL 4,118(0)'); // Shift right 24 (x18)
    assert.equal(reg(4), 0x00000012);
    assert.equal(reg(5), 0x345678aa);
  });

  QUnit.test("Shift Left Double SLDL", function(assert) {
    reg(4, 0x12345678);
    reg(5, 0xaabbccdd);
    reg(6, 8);
    execute([0x8d4f6100], assert, 'SLDL 4,100(6)'); // Shift left 8
    assert.equal(reg(4), 0x345678aa);
    assert.equal(reg(5), 0xbbccdd00);
  });

  QUnit.test("Shift Left Double SLDL large", function(assert) {
    reg(4, 0x12345678);
    reg(5, 0x00010001);
    execute([0x8d4f051b], assert, 'SLDL 4,51b(0)'); // Shift left 27
    assert.equal(reg(4), 0xc0000800);
    assert.equal(reg(5), 0x08000000);
  });

  QUnit.test("Shift Left Double SLDL odd", function(assert) {
    assert.throws(function() {
      execute([0x8d1f2100], assert, 'SLDL 1,100(2)');
    });
  });

  QUnit.test("Shift Right D SRDA positive", function(assert) {
    reg(4, 0x12345678);
    reg(5, 0xaabbccdd);
    execute([0x8e4f0118], assert, 'SRDA 4,118(0)'); // Shift right 24 (x18)
    assert.equal(reg(4), 0x00000012);
    assert.equal(reg(5), 0x345678aa);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Shift Right D SRDA zero", function(assert) {
    reg(4, 0x02345678);
    reg(5, 0xaabbccdd);
    execute([0x8e4f013c], assert, 'SRDA 4,13c(0)'); // Shift right 60 (x3c)
    assert.equal(reg(4), 0x00000000);
    assert.equal(reg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test("Shift Right D SRDA negative", function(assert) {
    reg(4, 0x92345678);
    reg(5, 0xaabbccdd);
    execute([0x8e4f0118], assert, 'SRDA 4,118(0)'); // Shift right 24 (x18)
    assert.equal(reg(4), 0xffffff92);
    assert.equal(reg(5), 0x345678aa);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test("Shift Left D SLDA", function(assert) {
    // From Princ Ops p143
    reg(2, 0x007f0a72);
    reg(3, 0xfedcba98);
    execute([0x8f2f001f], assert, 'SLDA 2,1f(0)');
    assert.equal(reg(2), 0x7f6e5d4c);
    assert.equal(reg(3), 0x00000000);
  });

  QUnit.test("Store Multiple STM", function(assert) {
    // From Princ Ops p143
    reg(14, 0x00002563);
    reg(15, 0x00012736);
    reg(0, 0x12430062);
    reg(1, 0x73261257);
    reg(6, 0x00004000);
    execute([0x90e16050], assert, 'STM 14,1,50(6)');
    assert.equal(state['MS'][0x4050], 0x00002563);
    assert.equal(state['MS'][0x4054], 0x00012736);
    assert.equal(state['MS'][0x4058], 0x12430062);
    assert.equal(state['MS'][0x405c], 0x73261257);
  });

  QUnit.test("Test Under Mask TM", function(assert) {
    // From Princ Ops p147
    state['MS'][0x9998] = 0xaafbaaaa;
    reg(9, 0x00009990);
    execute([0x91c39009], assert, 'TM 9(9),c3');
    assert.equal(state['CR'], 3);
  });

  QUnit.test("Test Under Mask TM b", function(assert) {
    // From Princ Ops p147
    state['MS'][0x9998] = 0xaa3caaaa;
    reg(9, 0x00009990);
    execute([0x91c39009], assert, 'TM 9(9),c3');
    assert.equal(state['CR'], 0);
  });

  QUnit.test("Move immediate MVI", function(assert) {
    reg(1, 0x123456);
    state['CR'] = 2;
    state['MS'][0x123464] = 0x12345678;
    execute([0x92421010], assert, 'MVI 10(1),42');
    assert.equal(state['MS'][0x123464], 0x12344278);
    assert.equal(state['CR'], 2); // Unchanged
  });

  QUnit.test("AND immediate NI", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x94f01010], assert, 'NI 10(1),f0');
    assert.equal(state['MS'][0x123464], 0x12345078);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("AND immediate NI - zero", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x94001010], assert, 'NI 10(1),0');
    assert.equal(state['MS'][0x123464], 0x12340078);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test("Compare Logical immediate CLI - equal", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x95561010], assert, 'CLI 10(1),56');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test("Compare Logical immediate CLI - low", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x95ff1010], assert, 'CLI 10(1),ff');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test("Compare Logical immediate CLI - all", function(assert) {
    for (var i = 0; i < 256 && i < testcycles * 3; i++) {
      reg(1, 0x123456);
      state['MS'][0x123464] = 0x12345678;
      execute([0x95001010 | (i << 16)], assert, 'CLI 10(1),' + i.toString(16));
      if (i == 0x56) {
        assert.equal(state['CR'], 0); // Equal
      } else if (i < 0x56) {
        assert.equal(state['CR'], 2); // First operand is high
      } else {
        assert.equal(state['CR'], 1); // First operand is low
      }
    }
  });

  QUnit.test("OR immediate OI", function(assert) {
    reg(1, 2);
    state['MS'][0x1000] = 0x12345678;
    execute([0x96421fff], assert, 'OI fff(1),42');
    assert.equal(state['MS'][0x1000], 0x12765678);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("Exclusive OR immediate XI", function(assert) {
    reg(0, 0x100); // Not used
    state['MS'][0x120] = 0x12345678;
    execute([0x970f0123], assert, 'XI 123(0),f');
    assert.equal(state['MS'][0x120], 0x12345677);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("Start I/O SIO", function(assert) { // F
    execute([0x9cff0234], assert, 'SIO 234(0)');
  });

  QUnit.test("Test I/O TIO", function(assert) { // F
    execute([0x9dff0234], assert, 'TIO 234(0)');
    assert.equal(chctl_w, 42);
  });

  QUnit.test("Halt I/O HIO", function(assert) { // F
    execute([0x9eff0234], assert, 'HIO 234(0)');
    assert.equal(chctl_w, 42);
  });

  QUnit.test("Test Channel TCH", function(assert) { // F
    execute([0x9fff0234], assert, 'TCH 234(0)');
    assert.equal(chctl_w, 42);
  });

  QUnit.test("Move Numeric MVN", function(assert) {
    // From Princ Ops p144
    state['MS'][0x7090] = 0xc1c2c3c4;
    state['MS'][0x7094] = 0xc5c6c7c8;
    state['MS'][0x7040] = 0xaaf0f1f2;
    state['MS'][0x7044] = 0xf3f4f5f6;
    state['MS'][0x7048] = 0xf7f8aaaa;
    reg(14, 0x00007090);
    reg(15, 0x00007040);
    execute([0xd103f001, 0xe000aaaa], assert, 'MVN 1(4,15),0(14)');
    assert.equal(state['MS'][0x7090], 0xc1c2c3c4);
    assert.equal(state['MS'][0x7040], 0xaaf1f2f3);
    assert.equal(state['MS'][0x7044], 0xf4f4f5f6);
    assert.equal(state['MS'][0x7048], 0xf7f8aaaa);
  });

  QUnit.test( "Move MVC", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x200] = 0x11223344;
    execute([0xd2030100, 0x02000000], assert, 'MVC 100(4,0),200(0)'); // Move 4 bytes from 200 to 100
    assert.equal(state['MS'][0x100], 0x11223344);
    assert.equal(state['MS'][0x200], 0x11223344); // Unchanged
  });

  QUnit.test( "Move MVC 2", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x104] = 0xabcdef01;
    reg(1, 2);
    reg(2, 0);
    execute([0xd2011100, 0x01050000], assert, 'MVC 100(2,1),105(0)'); // Move 2 bytes from 105 to 102
    assert.equal(state['MS'][0x100], 0x1234cdef);
    assert.equal(state['MS'][0x104], 0xabcdef01); // Unchanged
  });

  QUnit.test("Move Zone MVZ", function(assert) {
    // From Princ Ops page 144
    state['MS'][0x800] = 0xf1c2f3c4;
    state['MS'][0x804] = 0xf5c6aabb;
    reg(15, 0x00000800);
    execute([0xd304f001, 0xf000aabb], assert, 'MVZ 1(5,15),0(15)');
    assert.equal(state['MS'][0x800], 0xf1f2f3f4);
    assert.equal(state['MS'][0x804], 0xf5f6aabb);
  });

  QUnit.test("AND NC", function(assert) {
    state['MS'][0x358] = 0x00001790;
    state['MS'][0x360] = 0x00001401;
    reg(7, 0x00000358);
    execute([0xd4037000, 0x7008aaaa], assert, 'NC 0(4,7),8(7)');
    assert.equal(state['MS'][0x358], 0x00001400);
  });

  QUnit.test( "Compare Logical CLC - equal", function(assert) {
    reg(1, 0x100);
    reg(2, 0x100);
    state['MS'][0x200] = 0x12345633;
    state['MS'][0x300] = 0x12345644;
    execute([0xd5021100, 0x22000000], assert, 'CLC 100(3,1),200(2)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test( "Compare Logical CLC", function(assert) {
    reg(1, 0x100);
    reg(2, 0x100);
    state['MS'][0x200] = 0x12345678;
    state['MS'][0x300] = 0x12345678;
    // 123456 vs 345678 because of offset
    execute([0xd5021100, 0x22010000], assert, 'CLC 100(3,1),201(2)');
    assert.equal(state['CR'], 1); // first operand is low
  });

  QUnit.test("OR OC", function(assert) {
    state['MS'][0x358] = 0x00001790;
    state['MS'][0x360] = 0x00001401;
    reg(7, 0x00000358);
    execute([0xd6037000, 0x7008aaaa], assert, 'OC 0(4,7),8(7)');
    assert.equal(state['MS'][0x358], 0x00001791);
  });

  QUnit.test("Exclusive OR XC", function(assert) {
    // From Princ Ops p146
    state['MS'][0x358] = 0x00001790;
    state['MS'][0x360] = 0x00001401;
    reg(7, 0x00000358);
    execute([0xd7037000, 0x7008aaaa], assert, 'XC 0(4,7),8(7)');
    assert.equal(state['MS'][0x358], 0x00000391);
    execute([0xd7037008, 0x7000aaaa], assert, 'XC 8(4,7),0(7)');
    assert.equal(state['MS'][0x360], 0x00001790);
    execute([0xd7037000, 0x7008aaaa], assert, 'XC 0(4,7),8(7)');
    assert.equal(state['MS'][0x358], 0x00001401);
  });

  QUnit.test("Translate TR", function(assert) { // F
    // Based on Princ Ops p147
    for (var i = 0; i < 256; i += 4) {
      // Table increments each char by 3. Don't worry about wrapping.
      state['MS'][0x1000 + i] = (((i + 3) << 24) | ((i + 4) << 16) | ((i + 5) << 8) | (i + 6)) >>> 0;
    }
    state['MS'][0x2100] = 0x12345678;
    state['MS'][0x2104] = 0xabcdef01;
    state['MS'][0x2108] = 0x11223344;
    state['MS'][0x210c] = 0x55667788;
    state['MS'][0x2110] = 0x99aabbcc;
    reg(12, 0x00002100);
    reg(15, 0x00001000);
    execute([0xdc13c000, 0xf000aaaa], assert, 'TR 0(20,12),0(15)');
    assert,equal(state['MS'][0x2100], 0x1537597b);
    assert,equal(state['MS'][0x2104], 0xaed0f204);
    assert,equal(state['MS'][0x2108], 0x14253647);
    assert,equal(state['MS'][0x210c], 0x58697a8b);
    assert,equal(state['MS'][0x2110], 0x9cadbecf);
  });

  QUnit.test("Translate and Test TRT", function(assert) { // F
    // Based on Princ Ops p147
    for (var i = 0; i < 256; i += 4) {
      state['MS'][0x1000 + i] = 0;
    }
    state['MS'][0x2020] = 0x10203040;

    state['MS'][0x3000] = 0x12345621; // 21 will match table entry 20
    state['MS'][0x3004] = 0x11223344;
    state['MS'][0x3008] = 0x55667788;
    state['MS'][0x300c] = 0x99aabbcc;
    execute([0xdd0f1000, 0xf000aaaa], assert, 'TRT 0(16,1),0(15)');
    reg(1, 0x00003003); // Match at 3003
    reg(2, 0x00000020); // Function value from table
    assert.equal(state['CR'], 1); // not completed
  });

  QUnit.test("Edit ED", function(assert) { // F
    // Princ Ops page 149
    state['MS'][0x1200] = 0x0257426c;
    state['MS'][0x1000] = 0x4020206b;
    state['MS'][0x1004] = 0x2020214b;
    state['MS'][0x1008] = 0x202040c3;
    state['MS'][0x100c] = 0xd9ffffff;
    execute([0xde0cc000, 0xc200aaaa], assert, 'ED 0(13,12),200(12)');
    assert,equal(state['MS'][0x1000], 0x4040f26b);
    assert,equal(state['MS'][0x1004], 0xf5f7f44b);
    assert,equal(state['MS'][0x1008], 0xf2f64040);
    assert,equal(state['MS'][0x1008], 0x40ffffff);
    assert.equal(state['CR'], 2); // Result greater than zero
  });

  QUnit.test("Edit ED 2", function(assert) { // F
    // Princ Ops page 149
    state['MS'][0x1200] = 0x0000026d;
    state['MS'][0x1000] = 0x4020206b;
    state['MS'][0x1004] = 0x2020214b;
    state['MS'][0x1008] = 0x202040c3;
    state['MS'][0x100c] = 0xd9ffffff;
    execute([0xde0cc000, 0xc200aaaa], assert, 'ED 0(13,12),200(12)');
    assert,equal(state['MS'][0x1000], 0x40404040);
    assert,equal(state['MS'][0x1004], 0x4040404b);
    assert,equal(state['MS'][0x1008], 0xf2f640c3);
    assert,equal(state['MS'][0x1008], 0xd9ffffff);
    assert.equal(state['CR'], 1); // Result less than zero
  });

  QUnit.test("Edit and Mark EDMK", function(assert) { // F
    reg(1, 0xaabbccdd);
    state['MS'][0x1200] = 0x0000026d;
    state['MS'][0x1000] = 0x4020206b;
    state['MS'][0x1004] = 0x2020214b;
    state['MS'][0x1008] = 0x202040c3;
    state['MS'][0x100c] = 0xd9ffffff;
    execute([0xde0cc000, 0xc200aaaa], assert, 'ED 0(13,12),200(12)');
    assert,equal(state['MS'][0x1000], 0x40404040);
    assert,equal(state['MS'][0x1004], 0x4040404b);
    assert,equal(state['MS'][0x1008], 0xf2f640c3);
    assert,equal(state['MS'][0x1008], 0xd9ffffff);
    assert.equal(state['CR'], 1); // Result less than zero
    assert.equal(reg(1), 0xaa001000); // Need to adjust this address
  });

  QUnit.test("Move with Offset MVO", function(assert) {
    // Princ Ops 152
    reg(12, 0x00005600);
    reg(15, 0x00004500);
    state['MS'][0x5600] = 0x7788990c;
    state['MS'][0x4500] = 0x123456ff;
    execute([0xf132c000, 0xf0000000], assert, 'MVO 0(4, 12), 0(3, 15)');
    assert.equal(state['MS'][0x5600],  0x0123456c);
  });

  QUnit.test("Pack PACK", function(assert) {
    // Princ Ops p151
    reg(12, 0x00001000);
    state['MS'][0x1000] = 0xf1f2f3f4;
    state['MS'][0x1004] = 0xc5000000;
    execute([0xf244c000, 0xc0000000], assert, 'PACK 0(5, 12), 0(5, 12)');
    assert.equal(state['MS'][0x1000],  0x00001234);
    assert.equal(state['MS'][0x1004],  0x5c000000);
  });

  QUnit.test("Unpack UNPK", function(assert) {
    // Princ Ops p151
    reg(12, 0x00001000);
    reg(13, 0x00002500);
    state['MS'][0x2500] = 0xaa12345d;
    execute([0xf342c000, 0xd0010000], assert, 'UNPK 0(5, 12), 1(3, 13)');
    assert.equal(state['MS'][0x1000],  0xf1f2f3f4);
    assert.equal(state['MS'][0x1004],  0xd5000000);
  });

  QUnit.test( "Zero and Add ZAP", function(assert) {
    // Princ Ops p150
    reg(9, 0x00004000);
    state['MS'][0x4000] = 0x12345678;
    state['MS'][0x4004] = 0x90aaaaaa;
    state['MS'][0x4500] = 0x38460dff;
    execute([0xf8429000, 0x95000000], assert, 'ZAP 0(5, 9), 500(3, 9)');
    assert.equal(state['MS'][0x4000],  0x00003846);
    assert.equal(state['MS'][0x4004],  0x0daaaaaa);
    assert.equal(state['CR'], 1); // Result less than zero
  });

  QUnit.test( "Zero and Add ZAP -short ", function(assert) {
    state['AMWP'] = 8; // ASCII
    state['MS'][0x100] = 0x2a000000; // 2+
    state['MS'][0x200] = 0x3a000000; // 3+
    execute([0xf8000100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x100],  0x3a000000); // 3+
  });

  QUnit.test( "Zero and Add ZAP offset", function(assert) {
    state['AMWP'] = 8; // ASCII
    state['MS'][0x100] = 0x002a0000; // 2+
    state['MS'][0x200] = 0x00003a00; // 3+
    execute([0xf8000101, 0x02020000], assert, 'ZAP 101(1, 0), 202(1, 0)');
    assert.equal(state['MS'][0x100],  0x003a0000); // 3+
  });

  QUnit.test("Compare decimal CP", function(assert) {
    // Princ Op page 150
    reg(12, 0x00000600);
    reg(13, 0x00000400);
    state['MS'][0x700] = 0x1725356d;
    state['MS'][0x500] = 0x0672142d;;
    execute([0xf933c100, 0xd1000000], assert, 'CP 100(4, 12), 100(4, 13)');
    assert.equal(state['CR'], 1); // First lower
  });

  QUnit.test("Compare decimal CP 0", function(assert) {
    reg(12, 0x00000600);
    reg(13, 0x00000400);
    state['MS'][0x700] = 0x1725356d;
    state['MS'][0x500] = 0x00172535;
    state['MS'][0x504] = 0x6d000000;
    execute([0xf933c100, 0xd1010000], assert, 'CP 100(4, 12), 101(4, 13)');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test("Compare decimal CP 3", function(assert) {
    reg(12, 0x00000600);
    reg(13, 0x00000400);
    state['MS'][0x700] = 0x1725346d;
    state['MS'][0x500] = 0x00172535;
    state['MS'][0x504] = 0x6d000000;
    execute([0xf933c100, 0xd1010000], assert, 'CP 100(4, 12), 101(4, 13)');
    assert.equal(state['CR'], 2); // First higher
  });

  QUnit.test("Add AP", function(assert) {
    // PrincOps p 150
    reg(12, 0x00002000);
    reg(13, 0x000004fd);
    state['MS'][0x2000] = 0x38460d00;
    state['MS'][0x500] = 0x0112345c;
    execute([0xfa23c000, 0xd0030000], assert, 'AP 0(3, 12), 3(4, 13)');
    assert.equal(state['MS'][0x2000],  0x73885c00);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Subtract decimal SP", function(assert) { // F
    reg(12, 0x00002000);
    reg(13, 0x000004fd);
    state['MS'][0x2000] = 0x38460c00; // arg1
    state['MS'][0x500] = 0x0112345c; // arg2
    execute([0xfb23c000, 0xd0030000], assert, 'SP 0(3, 12), 3(4, 13)');
    assert.equal(state['MS'][0x2000],  0x73885d00);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test("Multiply MP", function(assert) { // F
    // PrincOps p 151
    reg(4, 0x00001200);
    reg(6, 0x00000500);
    state['MS'][0x1200] = 0xffff3846;
    state['MS'][0x1204] = 0x0dffffff;
    state['MS'][0x500] = 0x321dffff;
    execute([0xfc414100, 0x60000000], assert, 'MP 100(5, 4), 0(2, 6)');
    assert.equal(state['MS'][0x1300],  0x01234566);
    assert.equal(state['MS'][0x1304],  0x0c000000);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Divide DP", function(assert) { // F
    // PrincOps p 151
    reg(12, 0x00002000);
    reg(13, 0x00003000);
    state['MS'][0x2000] = 0x01234567;
    state['MS'][0x2004] = 0x8cffffff;
    state['MS'][0x3000] = 0x321dffff;
    execute([0xfd41c000, 0xd0000000], assert, 'DP 0(5, 12), 0(2, 13)');
    assert.equal(state['MS'][0x2000],  0x38460d01);
    assert.equal(state['MS'][0x2004],  0x8cffffff);
  });

  QUnit.test( "Load Multiple LM", function(assert) {
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x11223344;
    state['MS'][0x118] = 0x55667788;
    state['MS'][0x11c] = 0x99aabbcc;
    execute([0x98253100], assert, 'LM 2,5,100(3)');
    // Load registers 2 through 5 starting at 0x110
    assert.equal(reg(2), 0x12345678);
    assert.equal(reg(3), 0x11223344);
    assert.equal(reg(4), 0x55667788);
    assert.equal(reg(5), 0x99aabbcc);
  });

  QUnit.test( "Move MVI", function(assert) {
    state['MS'][0x100] = 0x11223344;
    reg(1, 1);
    execute([0x92551100], assert, 'MVI 100(1),55'); // Move byte 55 to location 101
    assert.equal(state['MS'][0x100], 0x11553344);
  });

  QUnit.test( "Compare Logical CLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 0); // equal

    reg(1, 0x12345678);
    reg(2, 0x12345679);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 1); // first operand is low

    reg(1, 0x12345679);
    reg(2, 0x12345678);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 2); // first operand is high

    reg(1, 0x7fffffff);
    reg(2, 0x8fffffff);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 1); // first operand is low
  });

  QUnit.test( "Compare Logical CL b", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x100);
    reg(3, 0x100);
    state['MS'][0x300] = 0x12345678;
    execute([0x55123100], assert, 'CL 1,100(2,3)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test( "And NR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0x12005600);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "And NR 0", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0xedcba987);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Or OR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x16120000], assert, 'OR 1,2');
    assert.equal(reg(1), 0xff34ff78);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive or XR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x17120000], assert, 'XR 1,2');
    assert.equal(reg(1), 0xed34a978);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Shift Left Single SLL various", function(assert) {
    for (var i = 0; i < testcycles; i++) {
      reg(1, 1);
      reg(2, 0x12340000 + i); // Shift i bits
      execute([0x891f2100], assert, 'SLL 1,100(2)');
      if (i < 32) {
        assert.equal(reg(1), (1 << i) >>> 0, 'Shift by ' + i);
      } else {
        assert.equal(reg(1), 0, 'Shift by ' + i);
      }
    }
  });

  QUnit.test( "Branch on condition BCR", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on condition BCR, always taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07f10000], assert, 'BCR 15,1'); // always
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on condition BCR, not taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 1;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch and link BALR", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    reg(2, 0x12345678); // Branch destination
    execute([0x05120000], assert, 'BALR 1,2');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch and link BALR -not taken", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x05100000], assert, 'BALR 1,0');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch on Count BCTR - taken", function(assert) {
    reg(1, 3); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 2);
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on Count BCTR - taken, negative", function(assert) {
    reg(1, 0); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0xffffffff);
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on Count BCTR - not taken", function(assert) {
    reg(1, 1); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Set Program Mask SPM", function(assert) {
    reg(1, 0x12345678); // Mask 2
    execute([0x041f0000], assert, 'SPM 1');
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0x2);
  });

  QUnit.test( "Supervisor Call SVC", function(assert) {
    // Need more testing here
    assert.throws(function() {
      execute([0x0a120000], assert, 'SVC 12');
    });
  });

  QUnit.test( "Set Storage Key SSK - no priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    assert.throws(function() {
      execute([0x08120000], assert, 'SSK 1,2');
    });
  });

  QUnit.test( "Set Storage Key SSK - priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(1, 0x11223344); // Key
    reg(2, 0x00005670); // Address: last 4 bits must be 0
    execute([0x08120000], assert, 'SSK 1,2');
    assert.equal(state['KEYS'][0x12345678 & 0x00fff100], 4);
  });

  QUnit.test( "Set Storage Key SSK - unaligned", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(1, 0x11223344); // Key
    reg(2, 0x00005674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x08120000], assert, 'SSK 1,2');
    });
  });

  // ISK reads the storage key
  QUnit.test( "Insert Storage Key ISK -priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0x89abcdef);
    reg(2, 0x12345670); // Aligned: last 4 bits 0
    execute([0x09120000], assert, 'ISK 1,2');
    assert.equal(reg(1), 0x89abcd20);
  });

  QUnit.test( "Insert Storage Key ISK -no priv", function(assert) {
    state['AMWP'] = 1; // Unprivileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0xaabbccdd);
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x09120000], assert, 'ISK 1,2');
    });
  });

  QUnit.test( "Insert Storage Key ISK -unaligned", function(assert) {
    state['AMWP'] = 0; // Privileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0xaabbccdd);
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x09120000], assert, 'ISK 1,2');
    });
  });

  QUnit.test( "Test and Set - not set TS", function(assert) {
    reg(2, 2); // Index
    state['MS'][0x100] = 0x83857789; // 102 top bit not set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 0); // Not set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });

  QUnit.test( "Test and Set - set TS", function(assert) {
    reg(2, 2); // Index
    state['MS'][0x100] = 0x8385c789; // 102 top bit set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 1); // Set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });
});
</script>
</body>
</html>
