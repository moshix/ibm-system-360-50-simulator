<!DOCTYPE html>
<html>
<!--
Test instructions on the 360 simulator.
-->
<head>
  <meta charset="utf-8">
  <title>Instruction unittests</title>
  <link rel="stylesheet" href="qunit-2.9.2.css" >
  <script src="data.js"></script>
  <script src="../utils.js"></script>
  <script src="../disasm.js"></script>
  <script src="../decode.js"></script>
  <script src="../engine.js"></script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>

  <script src="qunit-2.9.2.js"></script>
  <script>

QUnit.config.collapse = false; // Expand all failures

// Log test name to console
QUnit.testStart(function(test) {
  var module = test.module ? test.module : '';
  console.log('-----' + module + " " + test.name + "-----");
});

// Override alert so simulator will stop if an error is hit.
// https://stackoverflow.com/questions/1729501/javascript-overriding-alert
(function(proxied) {
window.alert = function() {
  running = 0; // Stop the simulator
  throw(arguments[0]);
  console.log('stopping ' + arguments[0]);
  return proxied.apply(this, arguments);
};
})(window.alert);

var state;

// Read or write register
function reg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][0x30 + num];
  } else {
    state['LS'][0x30 + num] = data;
  }
}

// Read or write half FP register
function fpreg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][0x20 + num];
  } else {
    state['LS'][0x20 + num] = data;
  }
}

// Convert words to halfwords
function hw(words) {
  var result = [];
  for (var i = 0; i < words.length; i++) {
    result.push(words[i] >>> 16);
    result.push(words[i] & 0xffff);
  }
  return result;
}

var running;
// Load instruction(s) into memory at 0x400 and execute.
function execute(instr, assert, desired) {
  command = disasm(hw(instr));
  console.log(command);
  assert.equal(command.replace(/ /g, ''), desired.replace(/ /g, '', desired));
  // Load instruction into memory
  for (var i = 0; i < instr.length; i++) {
    state['MS'][0x400 + i * 4] = instr[i];
  }
  state['IAR'] = 0x400;
  state['ROAR'] = 0x0197;
  running = 1;
  executeInstr();
}

// Execute one instruction
function executeInstr(instr) {
  for (var count = 0; count < 100; count++) {
    // Log micro-instruction
    var saddr = fmtAddress(state['ROAR']);
    console.log(decode(saddr, testdata[saddr]).join('\n'));
    // Execute micro-instruction
    cycle(state, testdata[saddr]);
    if (!running) { // emulator problem bailout
      alert('Bailing out');
      return;
    }

    // Check validity
    var keys = Object.keys(state);
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (typeof state[key] == 'number' && state[key] < 0) {
        alert('Negative value for state ' + key + ' ' + state[key]);
      }
    }

    console.log('L: ' + state['L'].toString(16) +
      ', R: ' + state['R'].toString(16) +
      ', M: ' + state['M'].toString(16) +
      ', T: ' + state['T'].toString(16) +
      ', F: ' + state['F'].toString(16) +
      ', H: ' + state['H'].toString(16) +
      ', J: ' + state['J'].toString(16) +
      ', U: ' + state['U'].toString(16) +
      ', V: ' + state['V'].toString(16) +
      ', W: ' + state['W'].toString(16) +
      ', LB: ' + state['LB'].toString(16) +
      ', MB: ' + state['MB'].toString(16) +
      ', MD: ' + state['MD'].toString(16) +
      ', G1: ' + state['G1'].toString(16) +
      ', G2: ' + state['G2'].toString(16) +
      ', IAR: ' + state['IAR'].toString(16) +
      ', LSAR: ' + state['LSAR'].toString(16) +
      ', SGNS: ' + state['LSGNS'] + ' ' + state['RSGNS'] +
      ', S: ' + state['S'] +
      ', BS: ' + state['BS'] +
      ', CR: ' + state['CR']);
    // Check if done
    if (count > 5 && [0x149, 0x14a, 0x14c, 0x14e, 0x184, 0x185, 0x187, 0x188, 0x189, 0x19b].includes(state['ROAR'])) {
      return;
    }
    if (count > 8 && [0x148].includes(state['ROAR'])) {
      return;
    }
    if (state['TRAP']) {
      console.log("********** TRAP **********");
      throw('TRAP');
      return;
    }
    if ([0x218, 0x195, 0x19c, 0x1b0, 0x1b4, 0x1b8, 0x1b1, 0x1b3, 0x1b5, 0x1b7, 0x10e, 0x10f].includes(state['ROAR'])) {
      console.log('********** Exception ' + state['ROAR'].toString(16) + ' **********');
      console.log('IAR: ' + state['IAR']);
      throw('Exception');
      return;
    }
  }
  throw('Count exceeded');
}

QUnit.module("Instructions", function(hooks) {
  hooks.beforeEach(function(assert) {
    state = createState();
  });

  QUnit.test( "Load LR", function(assert) {
    reg(1, 0x12345678);
    execute([0x18310000], assert, 'LR 3,1');
    assert.equal(reg(3), 0x12345678);
  });

  QUnit.test( "Load L", function(assert) {
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x12345678;
    execute([0x58345984], assert, 'L 3,984(4,5)');
    // L 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0x12345678);
  });
  QUnit.test( "Load and Test LTR", function(assert) {
    reg(4, 0xcdef1234);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0xcdef1234);
    assert.equal(state['CR'], 1); // Negative

    reg(4, 0);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero

    reg(4, 0x12345678);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR negative", function(assert) {
    reg(4, 0x1000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0xfffff000);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Complement LCR positive", function(assert) {
    reg(4, 0xffffffff);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR zero", function(assert) {
    reg(4, 0);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement LCR overflow", function(assert) {
    state['PROGMASK'] = 0; // Disable overflow interrupt
    reg(4, 0x80000000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Load Positive LPR", function(assert) {
    reg(4, 0xffffffff);
    execute([0x10340000], assert, 'LPR 3,4');
    // LPR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Negative LNR positive", function(assert) {
    reg(4, 0x12345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xedcba988);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR negative", function(assert) {
    reg(4, 0xc2345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xc2345678);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR 0", function(assert) {
    reg(4, 0);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "AR add", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000005);
    execute([0x1a120000], assert, 'AR 1,2');
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x1234567d);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "AR two adds", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    reg(3, 0x00000010);
    execute([0x1a121a31], assert, 'AR 1,2');
    executeInstr(); // Run the second instruction
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x12345679);
    assert.equal(reg(3), 0x12345689);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "AR add-negative", function(assert) {
    reg(1, 0x81234567);
    reg(2, 0x00000001);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x81234568);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "AR add-zero", function(assert) {
    reg(1, 0x00000002);
    reg(2, 0xfffffffe);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "AR add-overflow-trap-disabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 0; // Disable overflow interrupt
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "AR add-overflow-trap-enabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 8; // Enable overflow interrupt
    assert.throws(function() {
      execute([0x1a120000], assert, 'AR 1,2');
      console.log('no throw');
    });
  });

  QUnit.test( "add A", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5a156200], assert, 'A 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x34567890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000202);
    state['MS'][0x500] = 0x34567890; // Only 7890 used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x7890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH sign extend", function(assert) {
    reg(1, 1);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xfffe1234; // only fffe (-2) used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0xffffffff); // -1
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Add Logical ALR (i.e. unsigned) - zero no carry ", function(assert) {
    reg(1, 0);
    reg(2, 0);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero, no carry
  });

  QUnit.test( "Add Logical ALR - non-zero no carry ", function(assert) {
    reg(1, 0xffff0000);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0xffff0002);
    assert.equal(state['CR'], 1); // Nonzero, no carry
  });

  QUnit.test( "Add Logical ALR - zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Zero and carry
  });


  QUnit.test( "Add Logical ALR - not zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000003);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 1);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "Add Logical AL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xf0000000;
    execute([0x5e156200], assert, 'AL 1,200(5,6)');
    assert.equal(reg(1), 0x02345678);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "SR subtract", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x1b120000], assert, 'SR 1,2');
    assert.equal(reg(1), 0x12345677);
  });

  QUnit.test( "Subtract S", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x5b156200], assert, 'S 1,200(5,6)');
    assert.equal(reg(1), 0x00045678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Halfword SH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x4b156200], assert, 'SH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 - 0x1230);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Logical SLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x1f120000], assert, 'SLR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Difference is zero (carry)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0xffffffff);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x111111111;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), 0xeeeeeeee);
    assert.equal(state['CR'], 3); // Non-zero, carry (no borrow)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x23456789;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), (0x12345678 - 0x23456789) >>> 0);
    assert.equal(state['CR'], 1); // Non-zero, no carry (borrow)
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0x12345678); // Unchanged
    assert.equal(state['CR'], 0); // Operands are equal
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0xfffffffe); // -2
    reg(2, 0xfffffffd); // -3
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0xfffffffe); // Unchanged
    assert.equal(state['CR'], 2); // First operand is high
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 2);
    reg(2, 3);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 2); // Unchanged
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "Compare C", function(assert) {
    reg(1, 0xf0000000);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12345678;
    execute([0x59156200], assert, 'C 1,200(5,6)');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "multiply MR: 28×19", function(assert) {
    reg(3, 28);
    reg(4, 19);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 28 * 19);
  });

  // Pseudo-random number generator from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript

  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  var rand = mulberry32(1);

  QUnit.test( "multiply MR: random", function(assert) {
    for (var i = 0; i < 100; i++) {
      var n1 = Math.trunc(rand() * 1000);
      var n2 = Math.trunc(rand() * 1000);
      if (n1 * n2 >= 0x10000) continue;
      if (n1 == 6) continue
      reg(3, n1);
      reg(4, n2);
      execute([0x1c240000], assert, 'MR 2,4');
      assert.equal(reg(2), 0, n1 + '×' + n2);
      assert.equal(reg(3), n1 * n2, n1 + '×' + n2);
    }
  });

  QUnit.test( "multiply MR: large", function(assert) {
    reg(3, 0x12345678);
    reg(4, 0x34567890);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3b8c7b8);
    assert.equal(reg(3), 0x3248e380);
  });

  QUnit.test( "multiply MR: larger", function(assert) {
    reg(3, 0x7fffffff);
    reg(4, 0x7fffffff);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3fffffff);
    assert.equal(reg(3), 0x00000001);
  });

  QUnit.test( "multiply MR: negative", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0xfffffffb); // -5
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 20);
  });

  QUnit.test( "multiply MR: negative, positive", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0x0000000a); // 10
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0xffffffff);
    assert.equal(reg(3), (-40) >>> 0);
  });

  QUnit.test( "Multiply M", function(assert) {
    reg(3, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5c256200], assert, 'M 2,200(5,6)');
    assert.equal(reg(2), 0x03b8c7b8); // High 32-bits
    assert.equal(reg(3), 0x3248e380); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH - small", function(assert) {
    reg(3, 4);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x00000003; // 3
    execute([0x4c356202], assert, 'MH 3,202(5,6)');
    assert.equal(reg(3), 12); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH", function(assert) {
    reg(3, 0x00000015); // 21
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xffd91111; // -39
    execute([0x4c356200], assert, 'MH 3,200(5,6)');
    assert.equal(reg(3), 0xfffffccd); // Low 32-bits
  });

  QUnit.test( "Divide DR big", function(assert) {
    reg(2, 0x00112233);
    reg(3, 0x44556677);
    reg(4, 0x12345678); // 0x1122334455667788 / 0x12345678
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    console.log('Quotient' + reg(3).toString(16));
    console.log('Remainder' + reg(2).toString(16));
    assert.equal(reg(2), 0x11b3d5f7); // Remainder
    assert.equal(reg(3), 0x00f0f0f0); // Quotient
  });

  QUnit.test( "Divide DR", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, 0x00000234);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), Math.floor(0x112345678 / 0x234)); // Quotient
  });

  QUnit.test( "Divide DR negative", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, (-0x00000234) >>> 0);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), (-Math.floor(0x112345678 / 0x234)) >>> 0); // Quotient
  });

  QUnit.test( "Divide D - overflow", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x23456789;
    assert.throws(function() {
      execute([0x5d256200], assert, 'D 2,200(5,6)');
    });
  });

  QUnit.test( "Divide D", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x73456789;
    execute([0x5d256200], assert, 'D 2,200(5,6)');
    assert.equal(reg(2), 0x50c0186a); // Remainder
    assert.equal(reg(3), 0x286dead6); // Quotient
  });

  QUnit.test( "Shift Left Single SLA", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2, i.e. 2.
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA extrabits", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2fc1], assert, 'SLA 1,fc1(2)'); // shift value is 6 bits, fc ignored
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0", function(assert) {
    reg(1, 0x12345678);
    execute([0x8b100000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0 negative", function(assert) {
    reg(1, 0x92345678);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x92345678); // Should be unchanged
    assert.equal(state['CR'], 1); // Negative
  });


  QUnit.test( "Shift Left Single SLA 0 zero", function(assert) {
    reg(1, 0);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Shift Left Single SLA: positive overflow", function(assert) {
    reg(1, 0x10000000);
    reg(2, 2); // Shift by 2 still fits
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x40000000);
    assert.equal(state['CR'], 2); // Positive

    reg(1, 0x10000000);
    reg(2, 3); // Shift by 3 overflows
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x00000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out by 32", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000020); // Shift by 32 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out negative", function(assert) {
    reg(1, 0x80000000);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: negative overflow", function(assert) {
    reg(1, 0x80000000);
    reg(2, 21); // Shift by 2 should overflow
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative-overflow", function(assert) {
    reg(1, 0x80000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0x80000004); // Keep the sign
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative", function(assert) {
    reg(1, 0xf0000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0xc0000004); // Keep the sign
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Add Decimal AP - small", function(assert) {
    state['MS'][0x100] = 0x0000002c; // 2+
    state['MS'][0x200] = 0x00003c00; // 3+
    execute([0xfa000103, 0x02020000], assert, 'AP 103(1,0),202(1,0)');
    assert.equal(state['MS'][0x100],  0x0000005c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - 1 byte", function(assert) {
    state['MS'][0x100] = 0x2888011c; // 2888011+
    state['MS'][0x200] = 0x1112292c; // 1112292+
    execute([0xfa330100, 0x02000000], assert, 'AP 100(4,0),200(4,0)');
    assert.equal(state['MS'][0x100],  0x4000303c); // 4000303+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - 1 byte - small", function(assert) {
    state['MS'][0x100] = 0x0000002c; // 2+
    state['MS'][0x200] = 0x0000003c; // 3+
    execute([0xfa330100, 0x02000000], assert, 'AP 100(4,0),200(4,0)');
    assert.equal(state['MS'][0x100],  0x0000005c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - offset", function(assert) {
    state['MS'][0x100] = 0x0043212c; // 2+
    state['MS'][0x200] = 0x0023413c; // 3+
    execute([0xfa220101, 0x02010000], assert, 'AP 101(3,0),201(3,0)');
    assert.equal(state['MS'][0x100],  0x0066625c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP - no offset", function(assert) {
    state['MS'][0x100] = 0x0043212c; // 2+
    state['MS'][0x200] = 0x0023413c; // 3+
    execute([0xfa330100, 0x02000000], assert, 'AP 100(4,0),200(4,0)');
    assert.equal(state['MS'][0x100],  0x0066625c); // 5+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Decimal AP", function(assert) {
    // Example from Princ Ops p136.2
    reg(12, 0x00002000);
    reg(13, 0x000004fd);
    state['MS'][0x2000] = 0x38460d00; // 38460-
    state['MS'][0x500] = 0x0112345c; // 112345+
    execute([0xfa23c000, 0xd0030000], assert, 'AP 0(3,12),3(4,13)');
    assert.equal(state['MS'][0x2000],  0x73885c00); // 73885+
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Positive (FP long) LPDR", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x9abcdef0);
    execute([0x20400000], assert, 'LPDR 4,0');
    assert.equal(fpreg(4), 0x02345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Load Negative (FP long) LNDR", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x21400000], assert, 'LNDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Load and Test (FP) LTDR - positive", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x12345678);
    assert.equal(fpreg(5), 0x9abcdef0);
    assert.equal(state['CR'], 2); // Greater than zero
  });

  QUnit.test( "Load and Test (FP) LTDR - negative", function(assert) {
    fpreg(0, 0x92345678);
    fpreg(1, 0x9abcdef0);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
    assert.equal(state['CR'], 1); // Less than zero
  });

  QUnit.test( "Load and Test (FP) LTDR - zero negative", function(assert) {
    fpreg(0, 0xff000000);
    fpreg(1, 0x00000000);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0xff000000);
    assert.equal(fpreg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load and Test (FP) LTDR - zero positive", function(assert) {
    fpreg(0, 0x1f000000);
    fpreg(1, 0x00000000);
    execute([0x22400000], assert, 'LTDR 4,0');
    assert.equal(fpreg(4), 0x1f000000);
    assert.equal(fpreg(5), 0x00000000);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement (FP long) LCDR", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x9abcdef0);
    execute([0x23400000], assert, 'LCDR 4,0');
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x9abcdef0);
  });

  QUnit.test( "Halve (FP) HDR", function(assert) {
    fpreg(2, 0x12123456);
    fpreg(3, 0xabcdef00);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x1191a2b5);
    assert.equal(fpreg(1), 0x5e6f7800);
  });

  QUnit.test( "Halve (FP) HDR - guard bit used after normalizing", function(assert) {
    fpreg(2, 0x12123456);
    fpreg(3, 0xabcdef01);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x1191a2b5);
    assert.equal(fpreg(1), 0x5e6f7808);
  });

  QUnit.test( "Halve (FP) HDR - simple", function(assert) {
    fpreg(2, 0x12aa8844);
    fpreg(3, 0x22884422);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x12554422);
    assert.equal(fpreg(1), 0x11442211);
  });

  QUnit.test( "Halve (FP) HDR - shift across word", function(assert) {
    fpreg(2, 0x12aa8845);
    fpreg(3, 0x22884422);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x12554422);
    assert.equal(fpreg(1), 0x91442211);
  });

  QUnit.skip( "Halve (FP) HDR underflow", function(assert) {
    fpreg(2, 0x00000000);
    fpreg(3, 0x00000001);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x1191a2b5);
    assert.equal(fpreg(1), 0x5e6f7800);
  });

  QUnit.test( "Halve (FP) HDR zero", function(assert) {
    fpreg(2, 0x12000000);
    fpreg(3, 0x00000000);
    execute([0x24020000], assert, 'HDR 0,2');
    assert.equal(fpreg(0), 0x00000000);
    assert.equal(fpreg(1), 0x00000000);
  });

  QUnit.test( "Load (FP long) LDR - bad register", function(assert) {
    assert.throws(function() {
      execute([0x28410000], assert, 'LDR 4,1');
    });
  });

  QUnit.test( "Load (FP long) LDR - bad register", function(assert) {
    assert.throws(function() {
      execute([0x28140000], assert, 'LDR 1,4');
    });
  });

  QUnit.skip( "Compare (FP) CDR", function(assert) {
  });

  QUnit.skip( "Add N (FP) ADR", function(assert) {
  });

  QUnit.skip( "Subtract N (FP) SDR", function(assert) {
  });

  QUnit.skip( "Multiply (FP) MDR", function(assert) {
  });

  QUnit.skip( "Divide (FP) DDR", function(assert) {
  });

  QUnit.skip( "Add U (FP) AWR", function(assert) {
  });

  QUnit.skip( "Subtract U (FP) SWR", function(assert) {
  });

  QUnit.skip( "Subtract U (FP) SWR", function(assert) {
  });

  QUnit.test( "Load Positive (FP short) LPER", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x30400000], assert, 'LPER 4,0');
    assert.equal(fpreg(0), 0x82345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x02345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load Negative (FP short) LNER -neg", function(assert) {
    fpreg(0, 0x82345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x31400000], assert, 'LNER 4,0');
    assert.equal(fpreg(0), 0x82345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x82345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load Negative (FP short) LNER -pos", function(assert) {
    fpreg(0, 0x12345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x31400000], assert, 'LNER 4,0');
    assert.equal(fpreg(0), 0x12345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Load and Test (FP short) LTER - zero", function(assert) {
    fpreg(0, 0x12000000);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0x12000000);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x12000000);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load and Test (FP short) LTER - negative", function(assert) {
    fpreg(0, 0xc2345678);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0xc2345678);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0xc2345678);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load and Test (FP short) LTER - positive", function(assert) {
    fpreg(0, 0x00000001);
    fpreg(1, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x32400000], assert, 'LTER 4,0');
    assert.equal(fpreg(0), 0x00000001);
    assert.equal(fpreg(1), 0x33333333);
    assert.equal(fpreg(4), 0x00000001);
    assert.equal(fpreg(5), 0x55555555);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement (FP short) LCER", function(assert) {
    fpreg(2, 0x12345678);
    fpreg(3, 0x33333333);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0x55555555);
    execute([0x33420000], assert, 'LCER 4,2');
    assert.equal(fpreg(2), 0x12345678);
    assert.equal(fpreg(3), 0x33333333);
    assert.equal(fpreg(4), 0x92345678);
    assert.equal(fpreg(5), 0x55555555);
  });

  QUnit.test( "Halve (FP short) HER", function(assert) {
    fpreg(2, 0x12345678); // Source
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x121a2b3c);
  });

  QUnit.test( "Halve (FP short) HER - unnormalized", function(assert) {
    fpreg(2, 0x18000008); // Source: 8 is unnormalized
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x13400000);
  });

  QUnit.test( "Halve (FP short) HER - result needs normalizing", function(assert) {
    fpreg(2, 0x18100000); // Result will be 18080000, normalized to 17800000
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x17800000);
  });

  QUnit.test( "Halve (FP short) HER - zero", function(assert) {
    fpreg(2, 0x00000000); // standard zero
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x00000000);
  });

  QUnit.test( "Halve (FP short) HER - nonstandard zero", function(assert) {
    fpreg(2, 0x95000000); // nonstandard zero
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x00000000);
  });

  QUnit.skip( "Halve (FP short) HER - underflow", function(assert) {
    fpreg(2, 0x00000001);
    execute([0x34420000], assert, 'HER 4,2');
    assert.equal(fpreg(4), 0x00000000);
  });

  QUnit.test( "Load (FP short) LER", function(assert) {
    fpreg(2, 0x12345678); // Source
    fpreg(3, 0x9abcdef0);
    fpreg(4, 0x22334455); // Destination
    fpreg(5, 0xaabbccdd);
    execute([0x38420000], assert, 'LER 4,2');
    assert.equal(fpreg(2), 0x12345678);
    assert.equal(fpreg(3), 0x9abcdef0);
    assert.equal(fpreg(4), 0x12345678);
    assert.equal(fpreg(5), 0xaabbccdd);
  });

  QUnit.test( "Load (FP short) LER - bad register", function(assert) {
    assert.throws(function() {
      execute([0x38120000], assert, 'LER 1,2');
    });
  });

  QUnit.test( "Load (FP short) LER - bad register", function(assert) {
    assert.throws(function() {
      execute([0x38410000], assert, 'LER 4,1');
    });
  });

  QUnit.skip("Compare (FP short) CER ", function(assert) {
  });

  QUnit.skip("Add N (FP short) ALR ", function(assert) {
  });

  QUnit.skip("Subtract N (FP short) SER ", function(assert) {
  });

  QUnit.skip("Multiply N (FP short) MER ", function(assert) {
  });

  QUnit.skip("Divide N (FP short) DER ", function(assert) {
  });

  QUnit.skip("Add U (FP short) AUR ", function(assert) {
  });

  QUnit.skip("Subtract U (FP short) SUR ", function(assert) {
  });

  QUnit.test("Store halfword STH ", function(assert) {
    reg(3, 0xaabbccdd);
    reg(4, 1);
    reg(5, 1);
    state['MS'][0x1000] = 0x12345678;
    execute([0x40345ffe], assert, 'STH 3,ffe(4,5)');
    assert.equal(state['MS'][0x1000], 0xccdd5678);
  });

  QUnit.test("Store halfword STH +2", function(assert) {
    reg(3, 0xaabbccdd);
    reg(4, 1);
    reg(5, 3);
    state['MS'][0x1000] = 0x12345678;
    execute([0x40345ffe], assert, 'STH 3,ffe(4,5)');
    assert.equal(state['MS'][0x1000], 0x1234ccdd);
  });

  QUnit.test("Store halfword STH odd", function(assert) {
    reg(3, 0xaabbccdd);
    reg(4, 1);
    reg(5, 2);
    state['MS'][0x1000] = 0x12345678;
    assert.throws(function() {
      execute([0x40345ffe], assert, 'STH 3,ffe(4,5)');
    });
  });

  QUnit.test("Load Address LA", function(assert) {
    // From Princ Ops p147
    execute([0x41100800], assert, 'LA 1,800(0,0)');
    assert.equal(reg(1), 2048);
  });

  QUnit.test("Load Address LA b", function(assert) {
    // From Princ Ops p147
    reg(5, 0x00123456);
    execute([0x4150500a], assert, 'LA 5,a(0,5)');
    assert.equal(reg(5), 0x00123460);
  });

  QUnit.skip("Store Character STC", function(assert) {
  });

  QUnit.skip("Insert Character IC", function(assert) {
  });

  QUnit.skip("Execute EX", function(assert) {
  });

  QUnit.test( "Branch and link BAL", function(assert) {
    reg(3, 0x12300000);
    reg(4, 0x00045600);
    state['ILC'] = 0; // overwritten with 2
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x45134078], assert, 'BAL 1,78(3,4)');
    assert.equal(reg(1), 0xba000404); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.skip("Branch on Count BCT", function(assert) {
  });

  QUnit.skip("Branch/Condition BC", function(assert) {
  });

  QUnit.test( "Load Halfword LH sign-extend", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8765, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH sign-extend unaligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x202);
    state['MS'][0x1b84] = 0x07658321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8321, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH halfword aligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345986], assert, 'LH 3,986(4,5)');
    // LH 3, 986(4, 5): load R3 with mem[986+R4+R45)
    assert.equal(reg(3), 0x00004321, reg(3).toString(16));
  });

  QUnit.skip("Compare CH", function(assert) {
  });

  // Halfword second operand is sign-extended and added to first register.
  QUnit.test("Add halfword AH", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0x1234eeee;
    execute([0x4a300200], assert, 'AH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 + 0x1234);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Add halfword AH negative", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0xfffe9999; // -2
    execute([0x4a300200], assert, 'AH 3,200(0,0)');
    assert.equal(reg(3), 0x12345676);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Add halfword AH +2", function(assert) {
    reg(3, 0x12345678);
    reg(1, 2);
    state['MS'][0x200] = 0x99991234;
    execute([0x4a310200], assert, 'AH 3,200(1,0)');
    assert.equal(reg(3), 0x12345678 + 0x1234);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Subtract halfword AH", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0x1234eeee;
    execute([0x4b300200], assert, 'SH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 - 0x1234);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test("Multiply halfword MH", function(assert) {
    reg(3, 0x12345678);
    state['MS'][0x200] = 0x00059999; // 5
    execute([0x4c300200], assert, 'MH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 * 5);
  });

  QUnit.test("Multiply halfword MH negatives ", function(assert) {
    reg(3, (-0x12345678) >>> 0);
    state['MS'][0x200] = 0xfffb9999; // -5
    execute([0x4c300200], assert, 'MH 3,200(0,0)');
    assert.equal(reg(3), 0x12345678 * 5);
  });

  QUnit.test( "Convert to Binary CVB: princ op", function(assert) {
    // Example from Principles of Operation p122
    reg(5, 50); // Example seems to have addresses in decimal?
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 25594); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: bad sign", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x00255941; // 1 is not a valid sign
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  // Needs DC0 to support correction properly
  QUnit.skip( "Convert to Binary CVB: bad digit", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: doubleword unaligned", function(assert) {
    reg(5, 0);
    reg(6, 0);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756034], assert, 'CVB 7,34(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756031], assert, 'CVB 7,31(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000214;
    state['MS'][1004] = 0x8000000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.equal(reg(7), 2148000000); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: big overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x12345678;
    state['MS'][1004] = 0x4800000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: large", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000021;
    state['MS'][1004] = 0x2345678f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 212345678); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: negative", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594d; // d is negative
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), (-25594) >>> 0); // Note: decimal, not hex
  });

  // QE900/073C, CLF 112
  QUnit.test( "Convert to Binary CVB", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567f; // Decimal 1234567+
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), 1234567); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB neg", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567b; // Decimal 1234567-
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), (-1234567) >>> 0); // Note: decimal, not hex
  });

  QUnit.skip( "Convert to Decimal CVD", function(assert) {
    // Princ Ops p142
    reg(1, 0x00000f0f); // 3855 dec
    reg(13, 0x00007600);
    state['AMWP'] = 0; // EBCDIC
    execute([0x4e10d008], assert, 'CVD 1,8(0,13)');
    assert.equal(state['MS'][0x7608], 0x00000000);
    assert.equal(state['MS'][0x760c], 0x0003855c);
  });

  QUnit.skip( "Convert to Decimal CVD ASCII", function(assert) {
    reg(1, 0x00000f0f); // 3855 dec
    reg(13, 0x00007600);
    state['AMWP'] = 8; // ASCII
    execute([0x4e10d008], assert, 'CVD 1,8(0,13)');
    assert.equal(state['MS'][0x7608], 0x00000000);
    assert.equal(state['MS'][0x760c], 0x0003855d);
  });

  QUnit.skip( "Store ST", function(assert) {
  });

  QUnit.test( "AND N", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x12345678;
    execute([0x54123454], assert, 'N 1,454(2,3)');
    assert.equal(reg(1), (0x11223344 & 0x12345678) >>> 0);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.skip( "Compare Logical CL", function(assert) {
  });

  QUnit.test( "OR O", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x12345678;
    execute([0x56123454], assert, 'O 1,454(2,3)');
    assert.equal(reg(1), (0x11223344 | 0x12345678) >>> 0);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive OR X", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x12345678;
    execute([0x57123454], assert, 'X 1,454(2,3)');
    assert.equal(reg(1), (0x11223344 ^ 0x12345678) >>> 0);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive OR X - zero", function(assert) {
    reg(1, 0x11223344);
    reg(2, 0x200);
    reg(3, 0x300);
    state['MS'][0x954] = 0x11223344;
    execute([0x57123454], assert, 'X 1,454(2,3)');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.skip( "Load L", function(assert) {
  });

  QUnit.skip( "Compare C", function(assert) {
  });

  QUnit.skip("Add A", function(assert) {
  });

  QUnit.skip("Subtract C", function(assert) {
  });

  QUnit.skip("Multiply M", function(assert) {
  });

  QUnit.skip("Divide D", function(assert) {
  });

  QUnit.skip("Add Logical AL", function(assert) {
  });

  QUnit.skip("Subtracdt Logical SL", function(assert) {
  });

  QUnit.skip("Store (FP long) STD", function(assert) {
  });

  QUnit.skip("Load (FP long) LD", function(assert) {
  });

  QUnit.skip("Compare (FP long) CD", function(assert) {
  });

  QUnit.skip("Add N (FP long )AD", function(assert) {
  });

  QUnit.skip("Subtract N (FP long) SD", function(assert) {
  });

  QUnit.skip("Multiply (FP long) MD", function(assert) {
  });

  QUnit.skip("Divide (FP long) DD", function(assert) {
  });

  QUnit.skip("Add U (FP long) AW", function(assert) {
  });

  QUnit.skip("Subtract U (FP long) SW", function(assert) {
  });

  QUnit.skip("Store (FP short) STE", function(assert) {
  });

  QUnit.skip("Load (FP short) LE", function(assert) {
  });

  QUnit.skip("Compare (FP short) CE", function(assert) {
  });

  QUnit.skip("Add N (FP short )AE", function(assert) {
  });

  QUnit.skip("Subtract N (FP short) SE", function(assert) {
  });

  QUnit.skip("Multiply (FP short) ME", function(assert) {
  });

  QUnit.skip("Divide (FP short) DE", function(assert) {
  });

  QUnit.skip("Add U (FP short) AU", function(assert) {
  });

  QUnit.skip("Subtract U (FP short) SU", function(assert) {
  });

  QUnit.test("Set System Mask SSM", function(assert) {
    state['SYSMASK'] = 0xff;
    state['KEY'] = 3;
    state['AMWP'] = 0xe; // Privileged
    state['CR'] = 1;
    state['PROGMASK'] = 0xa;
    reg(3, 0x11);
    state['MS'][0x110] = 0xaabbccdd; // Access byte 1
    execute([0x80ee3100], assert, 'SSM 100(3)');
    assert.equal(state['SYSMASK'], 0xbb);
    assert.equal(state['KEY'], 0x3);
    assert.equal(state['AMWP'], 0xe);
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0xa);
    assert.equal(state['IAR'], 0x404);
  });

  QUnit.test("Set System Mask SSM unprivileged", function(assert) {
    state['SYSMASK'] = 0xff;
    state['KEY'] = 3;
    state['AMWP'] = 0xf; // Unrivileged
    state['CR'] = 1;
    state['PROGMASK'] = 0xa;
    assert.throws(function() {
      execute([0x80ee3100], assert, 'SSM 100(3)');
    });
  });

  QUnit.test("Load PSW LPSW", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x9a123450; // Branch to 123450
    execute([0x82003100], assert, 'LPSW 100(3)');
    assert.equal(state['SYSMASK'], 0x12);
    assert.equal(state['KEY'], 0x3);
    assert.equal(state['AMWP'], 0x4);
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0xa);
    assert.equal(state['IAR'], 0x123450);
  });

  QUnit.skip( "Diagnose", function(assert) {
    reg(2, 3); // Counter
    execute([0x83123456], assert, 'diagnose');
  });

  QUnit.skip("Write Direct WRD", function(assert) {
  });

  QUnit.skip("Read Direct RDD", function(assert) {
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 1); // Increment
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x86142200], assert, 'BXH 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH decrement", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 0xffffffff); // Increment -1
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x86142200], assert, 'BXH 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH shared reg", function(assert) {
    reg(1, 1); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x86132200], assert, 'BXH 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index High BXH shared reg", function(assert) {
    reg(1, 0xffffffff); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x86132200], assert, 'BXH 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 1); // Increment
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x87142200], assert, 'BXLE 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE decrement", function(assert) {
    reg(1, 0x12345678); // Value
    reg(4, 0xffffffff); // Increment -1
    reg(5, 0x12345678); // Comparand
    reg(2, 0x1000); // Branch target
    execute([0x87142200], assert, 'BXLE 1, 4, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE shared reg", function(assert) {
    reg(1, 1); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x87132200], assert, 'BXLE 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345679);
    assert.equal(state['IAR'], 0x404); // Branch not taken
  });

  // Add increment to first operand, compare with odd register after R3
  QUnit.test("Branch on index Low or Equal BXLE shared reg", function(assert) {
    reg(1, 0xffffffff); // Value
    reg(3, 0x12345678); // Increment and comparand
    reg(2, 0x1000); // Branch target
    execute([0x87132200], assert, 'BXLE 1, 3, 200(2)');
    assert.equal(reg(1), 0x12345677);
    assert.equal(state['IAR'], 0x1200); // Branch taken
  });

  QUnit.test( "Shift Left Single SLL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x891f2100], assert, 'SLL 1,100(2)');
    assert.equal(reg(1), 0x11a2b3c0);
  });

  QUnit.test( "Shift Right Single SRL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x881f2100], assert, 'SRL 1,100(2)');
    assert.equal(reg(1), 0x82345678 >>> 3);
  });

  QUnit.skip("Shift Right S SRA", function(assert) {
  });

  QUnit.skip("Shift Left S SLA", function(assert) {
    // From Princ Ops p143
    reg(2, 0x007f0a72);
    execute([0x8b2f0008], assert, 'SLA 2,8(0)'); // Shift left 8
    assert.equal(reg(2), 0x7f0a7200);
  });

  QUnit.skip("Shift Right Double SRDL", function(assert) {
  });

  QUnit.test("Shift Left Double SLDL", function(assert) {
    reg(4, 0x12345678);
    reg(5, 0xaabbccdd);
    reg(6, 8);
    execute([0x8d4f6100], assert, 'SLDL 4,100(6)'); // Shift left 8
    assert.equal(reg(4), 0x345678aa);
    assert.equal(reg(5), 0xbbccdd00);
  });

  QUnit.test("Shift Left Double SLDL large", function(assert) {
    reg(4, 0x12345678);
    reg(5, 0x00010001);
    execute([0x8d4f051b], assert, 'SLDL 4,51b(0)'); // Shift left 27
    assert.equal(reg(4), 0xc0000800);
    assert.equal(reg(5), 0x08000000);
  });

  QUnit.test("Shift Left Double SLDL odd", function(assert) {
    assert.throws(function() {
      execute([0x8d1f2100], assert, 'SLDL 1,100(2)');
    });
  });

  QUnit.skip("Shift Right D SRDA", function(assert) {
  });

  QUnit.skip("Shift Left D SLDA", function(assert) {
    // From Princ Ops p143
    reg(2, 0x007f0a72);
    reg(3, 0xfedcba98);
    execute([0x8f2f001f], assert, 'SLDA 2,1f(0)');
    assert.equal(reg(2), 0x7f6e5d4c);
    assert.equal(reg(3), 0x00000000);
  });

  QUnit.test("Store Multiple STM", function(assert) {
    // From Princ Ops p143
    reg(14, 0x00002563);
    reg(15, 0x00012736);
    reg(0, 0x12430062);
    reg(1, 0x73261257);
    reg(6, 0x00004000);
    execute([0x90e16050], assert, 'STM 14,1,50(6)');
    assert.equal(state['MS'][0x4050], 0x00002563);
    assert.equal(state['MS'][0x4054], 0x00012736);
    assert.equal(state['MS'][0x4058], 0x12430062);
    assert.equal(state['MS'][0x405c], 0x73261257);
  });

  QUnit.test("Test Under Mask TM", function(assert) {
    // From Princ Ops p147
    state['MS'][0x9998] = 0xaafbaaaa;
    reg(9, 0x00009990);
    execute([0x91c39009], assert, 'TM 9(9),c3');
    assert.equal(state['CR'], 3);
  });

  QUnit.test("Test Under Mask TM b", function(assert) {
    // From Princ Ops p147
    state['MS'][0x9998] = 0xaa3caaaa;
    reg(9, 0x00009990);
    execute([0x91c39009], assert, 'TM 9(9),c3');
    assert.equal(state['CR'], 0);
  });

  QUnit.test("Move immediate MVI", function(assert) {
    reg(1, 0x123456);
    state['CR'] = 2;
    state['MS'][0x123464] = 0x12345678;
    execute([0x92421010], assert, 'MVI 10(1),42');
    assert.equal(state['MS'][0x123464], 0x12344278);
    assert.equal(state['CR'], 2); // Unchanged
  });

  QUnit.test("AND immediate NI", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x94f01010], assert, 'NI 10(1),f0');
    assert.equal(state['MS'][0x123464], 0x12345078);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("AND immediate NI - zero", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x94001010], assert, 'NI 10(1),0');
    assert.equal(state['MS'][0x123464], 0x12340078);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test("Compare Logical immediate CLI - equal", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x95561010], assert, 'CLI 10(1),56');
    assert.equal(state['CR'], 0); // Equal
  });

  QUnit.test("Compare Logical immediate CLI - low", function(assert) {
    reg(1, 0x123456);
    state['MS'][0x123464] = 0x12345678;
    execute([0x95ff1010], assert, 'CLI 10(1),ff');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test("Compare Logical immediate CLI - all", function(assert) {
    for (var i = 0; i < 256; i++) {
      reg(1, 0x123456);
      state['MS'][0x123464] = 0x12345678;
      execute([0x95001010 | (i << 16)], assert, 'CLI 10(1),' + i.toString(16));
      if (i == 0x56) {
        assert.equal(state['CR'], 0); // Equal
      } else if (i < 0x56) {
        assert.equal(state['CR'], 2); // First operand is high
      } else {
        assert.equal(state['CR'], 1); // First operand is low
      }
    }
  });

  QUnit.test("OR immediate OI", function(assert) {
    reg(1, 2);
    state['MS'][0x1000] = 0x12345678;
    execute([0x96421fff], assert, 'OI fff(1),42');
    assert.equal(state['MS'][0x1000], 0x12765678);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test("Exclusive OR immediate XI", function(assert) {
    reg(0, 0x100); // Not used
    state['MS'][0x120] = 0x12345678;
    execute([0x970f0123], assert, 'XI 123(0),f');
    assert.equal(state['MS'][0x120], 0x12345677);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.skip("Start I/O SIO", function(assert) {
  });

  QUnit.skip("Test I/O TIO", function(assert) {
  });

  QUnit.skip("Halt I/O HIO", function(assert) {
  });

  QUnit.skip("Test Channel TCH", function(assert) {
  });

  QUnit.test("Move Numeric MVN", function(assert) {
    // From Princ Ops p144
    state['MS'][0x7090] = 0xc1c2c3c4;
    state['MS'][0x7094] = 0xc5c6c7c8;
    state['MS'][0x7040] = 0xaaf0f1f2;
    state['MS'][0x7044] = 0xf3f4f5f6;
    state['MS'][0x7048] = 0xf7f8aaaa;
    reg(14, 0x00007090);
    reg(15, 0x00007040);
    execute([0xd103f001, 0xe000aaaa], assert, 'MVN 1(4,15),0(14)');
    assert.equal(state['MS'][0x7090], 0xc1c2c3c4);
    assert.equal(state['MS'][0x7040], 0xaaf1f2f3);
    assert.equal(state['MS'][0x7044], 0xf4f4f5f6);
    assert.equal(state['MS'][0x7048], 0xf7f8aaaa);
  });

  QUnit.test( "Move MVC", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x200] = 0x11223344;
    execute([0xd2030100, 0x02000000], assert, 'MVC 100(4,0),200(0)'); // Move 4 bytes from 200 to 100
    assert.equal(state['MS'][0x100], 0x11223344);
    assert.equal(state['MS'][0x200], 0x11223344); // Unchanged
  });

  QUnit.test( "Move MVC 2", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x104] = 0xabcdef01;
    reg(1, 2);
    reg(2, 0);
    execute([0xd2011100, 0x01050000], assert, 'MVC 100(2,1),105(0)'); // Move 2 bytes from 105 to 102
    assert.equal(state['MS'][0x100], 0x1234cdef);
    assert.equal(state['MS'][0x104], 0xabcdef01); // Unchanged
  });

  QUnit.test("Move Zone MVZ", function(assert) {
    // From Princ Ops page 144
    state['MS'][0x800] = 0xf1c2f3c4;
    state['MS'][0x804] = 0xf5c6aabb;
    reg(15, 0x00000800);
    execute([0xd304f001, 0xf000aabb], assert, 'MVZ 1(5,15),0(15)');
    assert.equal(state['MS'][0x800], 0xf1f2f3f4);
    assert.equal(state['MS'][0x804], 0xf5f6aabb);
  });

  QUnit.skip("AND NC", function(assert) {
  });

  QUnit.test( "Compare Logical CLC - equal", function(assert) {
    reg(1, 0x100);
    reg(2, 0x100);
    state['MS'][0x200] = 0x12345633;
    state['MS'][0x300] = 0x12345644;
    execute([0xd5021100, 0x22000000], assert, 'CLC 100(3,1),200(2)');
    assert.equal(state['CR'], 0); // equal
  });

  QUnit.test( "Compare Logical CLC", function(assert) {
    reg(1, 0x100);
    reg(2, 0x100);
    state['MS'][0x200] = 0x12345678;
    state['MS'][0x300] = 0x12345678;
    // 123456 vs 345678 because of offset
    execute([0xd5021100, 0x22010000], assert, 'CLC 100(3,1),201(2)');
    assert.equal(state['CR'], 1); // first operand is low
  });

  QUnit.skip("OR OC", function(assert) {
  });

  QUnit.test("Exclusive OR XC", function(assert) {
    // From Princ Ops p146
    state['MS'][0x358] = 0x00001790;
    state['MS'][0x360] = 0x00001401;
    reg(7, 0x00000358);
    execute([0xd7037000, 0x7008aaaa], assert, 'XC 0(4,7),8(7)');
    assert.equal(state['MS'][0x358], 0x00000391);
    execute([0xd7037008, 0x7000aaaa], assert, 'XC 8(4,7),0(7)');
    assert.equal(state['MS'][0x360], 0x00001790);
    execute([0xd7037000, 0x7008aaaa], assert, 'XC 0(4,7),8(7)');
    assert.equal(state['MS'][0x358], 0x00001401);
  });

  QUnit.skip("Translate TR", function(assert) {
    // Based on Princ Ops p147
    for (var i = 0; i < 256; i += 4) {
      // Table increments each char by 3. Don't worry about wrapping.
      state['MS'][0x1000 + i] = (((i + 3) << 24) | ((i + 4) << 16) | ((i + 5) << 8) | (i + 6)) >>> 0;
    }
    state['MS'][0x2100] = 0x12345678;
    state['MS'][0x2104] = 0xabcdef01;
    state['MS'][0x2108] = 0x11223344;
    state['MS'][0x210c] = 0x55667788;
    state['MS'][0x2110] = 0x99aabbcc;
    reg(12, 0x00002100);
    reg(15, 0x00001000);
    execute([0xdc13c000, 0xf000aaaa], assert, 'TR 0(14,12),0(15)');
    assert,equal(state['MS'][0x2100], 0x1537597b);
    assert,equal(state['MS'][0x2104], 0xaed0f204);
    assert,equal(state['MS'][0x2108], 0x14253647);
    assert,equal(state['MS'][0x210c], 0x58697a8b);
    assert,equal(state['MS'][0x2110], 0x9cadbecf);
  });

  QUnit.skip("Translate and Test TRT", function(assert) {
    // Based on Princ Ops p147
    for (var i = 0; i < 256; i += 4) {
      state['MS'][0x1000 + i] = 0;
    }
    state['MS'][0x2020] = 0x10203040;

    state['MS'][0x3000] = 0x12345621; // 21 will match table entry 20
    state['MS'][0x3004] = 0x11223344;
    state['MS'][0x3008] = 0x55667788;
    state['MS'][0x300c] = 0x99aabbcc;
    execute([0xdd0f1000, 0xf000aaaa], assert, 'TRT 0(16,1),0(15)');
    reg(1, 0x00003003); // Match at 3003
    reg(2, 0x00000020); // Function value from table
    assert.equal(state['CR'], 1); // not completed
  });

  QUnit.skip("Edit ED", function(assert) {
  });

  QUnit.skip("Edit and Mark EDMK", function(assert) {
  });

  QUnit.skip("Move with Offset MVO", function(assert) {
  });

  QUnit.skip("Pack PACK", function(assert) {
  });

  QUnit.skip("Unpack UNPK", function(assert) {
  });

  QUnit.skip( "Zero and Add ZAP", function(assert) {
    state['MS'][0x100] = 0x2a000000; // 2+
    state['MS'][0x200] = 0x3a000000; // 3+
    execute([0xf8110100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x100],  0x3a000000); // 3+
  });

  QUnit.skip( "Zero and Add ZAP offset", function(assert) {
    state['MS'][0x100] = 0x02a00000; // 2+
    state['MS'][0x200] = 0x0003a000; // 3+
    execute([0xf8110100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x101],  0x3a000000); // 3+
  });

  QUnit.skip("Compare CP", function(assert) {
  });

  QUnit.skip("Add AP", function(assert) {
  });

  QUnit.skip("Subtract SP", function(assert) {
  });

  QUnit.skip("Multiply MP", function(assert) {
  });

  QUnit.skip("Divide DP", function(assert) {
  });

  QUnit.test( "Load Multiple LM", function(assert) {
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x11223344;
    state['MS'][0x118] = 0x55667788;
    state['MS'][0x11c] = 0x99aabbcc;
    execute([0x98253100], assert, 'LM 2,5,100(3)');
    // Load registers 2 through 5 starting at 0x110
    assert.equal(reg(2), 0x12345678);
    assert.equal(reg(3), 0x11223344);
    assert.equal(reg(4), 0x55667788);
    assert.equal(reg(5), 0x99aabbcc);
  });

  QUnit.test( "Move MVI", function(assert) {
    state['MS'][0x100] = 0x11223344;
    reg(1, 1);
    execute([0x92551100], assert, 'MVI 100(1),55'); // Move byte 55 to location 101
    assert.equal(state['MS'][0x100], 0x11553344);
  });

  QUnit.test( "Compare Logical CLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 0); // equal

    reg(1, 0x12345678);
    reg(2, 0x12345679);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 1); // first operand is low

    reg(1, 0x12345679);
    reg(2, 0x12345678);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 2); // first operand is high

    reg(1, 0x7fffffff);
    reg(2, 0x8fffffff);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['CR'], 1); // first operand is low
  });

  QUnit.test( "Compare Logical CL", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x100);
    reg(3, 0x100);
    state['MS'][0x300] = 0x12345678;
    execute([0x55123100], assert, 'CL 1,100(2,3)');
    assert.equal(state['CR'], 0); // equal
  });


  QUnit.test( "And NR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0x12005600);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "And NR 0", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0xedcba987);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Or OR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x16120000], assert, 'OR 1,2');
    assert.equal(reg(1), 0xff34ff78);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive or XR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x17120000], assert, 'XR 1,2');
    assert.equal(reg(1), 0xed34a978);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Shift Left Single SLL various", function(assert) {
    for (var i = 0; i < 40; i++) {
      reg(1, 1);
      reg(2, 0x12340000 + i); // Shift i bits
      execute([0x891f2100], assert, 'SLL 1,100(2)');
      if (i < 32) {
        assert.equal(reg(1), (1 << i) >>> 0, 'Shift by ' + i);
      } else {
        assert.equal(reg(1), 0, 'Shift by ' + i);
      }
    }
  });

  QUnit.test( "Branch on condition BCR", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on condition BCR, always taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07f10000], assert, 'BCR 15,1'); // always
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on condition BCR, not taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 1;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch and link BALR", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    reg(2, 0x12345678); // Branch destination
    execute([0x05120000], assert, 'BALR 1,2');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch and link BALR -not taken", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x05100000], assert, 'BALR 1,0');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch on Count BCTR - taken", function(assert) {
    reg(1, 3); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 2);
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on Count BCTR - taken, negative", function(assert) {
    reg(1, 0); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0xffffffff);
    assert.equal(state['IAR'], 0x00345678);
  });

  QUnit.test( "Branch on Count BCTR - not taken", function(assert) {
    reg(1, 1); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Set Program Mask SPM", function(assert) {
    reg(1, 0x12345678); // Mask 2
    execute([0x041f0000], assert, 'SPM 1');
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0x2);
  });

  QUnit.test( "Supervisor Call SVC", function(assert) {
    // Need more testing here
    assert.throws(function() {
      execute([0x0a120000], assert, 'SVC 12');
    });
  });

  QUnit.test( "Set Storage Key SSK - no priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    assert.throws(function() {
      execute([0x08120000], assert, 'SSK 1,2');
    });
  });

  QUnit.test( "Set Storage Key SSK - priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(1, 0x11223344); // Key
    reg(2, 0x12345670); // Address: last 4 bits must be 0
    execute([0x08120000], assert, 'SSK 1,2');
    assert.equal(state['KEYS'][0x12345678 & 0x00fff100], 4);
  });

  QUnit.test( "Set Storage Key SSK - unaligned", function(assert) {
    state['AMWP'] = 0; // Privileged
    reg(1, 0x11223344); // Key
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x08120000], assert, 'SSK 1,2');
    });
  });

  // ISK reads the storage key
  QUnit.test( "Insert Storage Key ISK -priv", function(assert) {
    state['AMWP'] = 0; // Privileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0x89abcdef);
    reg(2, 0x12345670); // Aligned: last 4 bits 0
    execute([0x09120000], assert, 'ISK 1,2');
    assert.equal(reg(1), 0x89abcd20);
  });

  QUnit.test( "Insert Storage Key ISK -no priv", function(assert) {
    state['AMWP'] = 1; // Unprivileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0xaabbccdd);
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x09120000], assert, 'ISK 1,2');
    });
  });

  QUnit.test( "Insert Storage Key ISK -unaligned", function(assert) {
    state['AMWP'] = 0; // Privileged
    state['KEYS'][0x12345670 & 0x00fff100] = 2;
    reg(1, 0xaabbccdd);
    reg(2, 0x12345674); // Unaligned: last 4 bits not 0
    assert.throws(function() {
      execute([0x09120000], assert, 'ISK 1,2');
    });
  });

  QUnit.test( "Test and Set - not set TS", function(assert) {
    reg(2, 2); // Index
    state['MS'][0x100] = 0x83857789; // 102 top bit not set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 0); // Not set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });

  QUnit.test( "Test and Set - set TS", function(assert) {
    reg(2, 2); // Index
    state['MS'][0x100] = 0x8385c789; // 102 top bit set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 1); // Set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });
});
</script>
</body>
</html>
