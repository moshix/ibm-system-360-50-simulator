<!DOCTYPE html>
<html>
<!--
Test instructions on the 360 simulator.
-->
<head>
  <meta charset="utf-8">
  <title>Instruction unittests</title>
  <link rel="stylesheet" href="qunit-2.9.2.css" >
  <script src="data.js"></script>
  <script src="../utils.js"></script>
  <script src="../disasm.js"></script>
  <script src="../decode.js"></script>
  <script src="../engine.js"></script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>

  <script src="qunit-2.9.2.js"></script>
  <script>

QUnit.config.collapse = false; // Expand all failures

// Log test name to console
QUnit.testStart(function(test) {
  var module = test.module ? test.module : '';
  console.log('-----' + module + " " + test.name + "-----");
});

// Override alert so simulator will stop if an error is hit.
// https://stackoverflow.com/questions/1729501/javascript-overriding-alert
(function(proxied) {
window.alert = function() {
  running = 0; // Stop the simulator
  throw(arguments[0]);
  console.log('stopping ' + arguments[0]);
  return proxied.apply(this, arguments);
};
})(window.alert);

var state;

function reg(num, data) {
  if (data == undefined) {
    // read
    return state['LS'][48 + num];
  } else {
    state['LS'][48 + num] = data;
  }
}

// Convert words to halfwords
function hw(words) {
  var result = [];
  for (var i = 0; i < words.length; i++) {
    result.push(words[i] >>> 16);
    result.push(words[i] & 0xffff);
  }
  return result;
}

var running;
// Load instruction(s) into memory at 0x400 and execute.
function execute(instr, assert, desired) {
  command = disasm(hw(instr));
  console.log(command);
  assert.equal(command.replace(/ /g, ''), desired.replace(/ /g, '', desired));
  // Load instruction into memory
  for (var i = 0; i < instr.length; i++) {
    state['MS'][0x400 + i] = instr[i];
  }
  state['IAR'] = 0x400;
  state['ROAR'] = 0x0197;
  running = 1;
  executeInstr();
}

// Execute one instruction
function executeInstr(instr) {
  for (var count = 0; count < 100; count++) {
    // Log micro-instruction
    var saddr = fmtAddress(state['ROAR']);
    console.log(decode(saddr, testdata[saddr]).join('\n'));
    // Execute micro-instruction
    cycle(state, testdata[saddr]);
    if (!running) { // emulator problem bailout
      alert('Bailing out');
      return;
    }
    console.log('L: ' + state['L'].toString(16) +
      ', R: ' + state['R'].toString(16) +
      ', M: ' + state['M'].toString(16) +
      ', T: ' + state['T'].toString(16) +
      ', F: ' + state['F'].toString(16) +
      ', H: ' + state['H'].toString(16) +
      ', U: ' + state['U'].toString(16) +
      ', V: ' + state['V'].toString(16) +
      ', W: ' + state['W'].toString(16) +
      ', LB: ' + state['LB'].toString(16) +
      ', MB: ' + state['MB'].toString(16) +
      ', MD: ' + state['MD'].toString(16) +
      ', G1: ' + state['G1'].toString(16) +
      ', G2: ' + state['G2'].toString(16) +
      ', SGNS: ' + state['LSGNS'] + ' ' + state['RSGNS'] +
      ', S: ' + state['S'] +
      ', CR: ' + state['CR']);
    // Check if done
    if (count > 5 && [0x148, 0x149, 0x14a, 0x14c, 0x14e, 0x184, 0x185, 0x187, 0x188, 0x189, 0x19b].includes(state['ROAR'])) {
      return;
    }
    if (state['TRAP']) {
      console.log("********** TRAP **********");
      throw('TRAP');
      return;
    }
    if ([0x218, 0x195, 0x19c, 0x1b0, 0x1b4, 0x1b8, 0x1b1, 0x1b3, 0x1b5, 0x1b7, 0x10e, 0x10f, 
        0x751, 0x731, 0x733, 0x735].includes(state['ROAR'])) {
      console.log('********** Exception ' + state['ROAR'].toString(16) + ' **********');
      console.log('IAR: ' + state['IAR']);
      throw('Exception');
      return;
    }
  }
  throw('Count exceeded');
}

QUnit.module("Instructions", function(hooks) {
  hooks.beforeEach(function(assert) {
    state = createState();
  });

  QUnit.test( "Load LR", function(assert) {
    reg(1, 0x12345678);
    execute([0x18310000], assert, 'LR 3,1');
    assert.equal(reg(3), 0x12345678);
  });

  QUnit.test( "Load L", function(assert) {
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x12345678;
    execute([0x58345984], assert, 'L 3,984(4,5)');
    // L 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0x12345678);
  });

  QUnit.test( "Load Halfword LH sign-extend", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8765, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH sign-extend unaligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x202);
    state['MS'][0x1b84] = 0x07658321;
    execute([0x48345984], assert, 'LH 3,984(4,5)');
    // LH 3, 984(4, 5): load R3 with mem[984+R4+R45)
    assert.equal(reg(3), 0xffff8321, reg(3).toString(16)); // sign extension
  });

  QUnit.test( "Load Halfword LH halfword aligned", function(assert) {
    reg(3, 0xffffffff);
    reg(4, 0x1000);
    reg(5, 0x200);
    state['MS'][0x1b84] = 0x87654321;
    execute([0x48345986], assert, 'LH 3,986(4,5)');
    // LH 3, 986(4, 5): load R3 with mem[986+R4+R45)
    assert.equal(reg(3), 0x00004321, reg(3).toString(16));
  });

  QUnit.test( "Load and Test LTR", function(assert) {
    reg(4, 0xcdef1234);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0xcdef1234);
    assert.equal(state['CR'], 1); // Negative

    reg(4, 0);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero

    reg(4, 0x12345678);
    execute([0x12340000], assert, 'LTR 3,4');
    // LTR 3, 4
    assert.equal(reg(3), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR negative", function(assert) {
    reg(4, 0x1000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0xfffff000);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Complement LCR positive", function(assert) {
    reg(4, 0xffffffff);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Complement LCR zero", function(assert) {
    reg(4, 0);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Complement LCR overflow", function(assert) {
    state['PROGMASK'] = 0; // Disable overflow interrupt
    reg(4, 0x80000000);
    execute([0x13340000], assert, 'LCR 3,4');
    // LCR 3, 4
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Load Positive LPR", function(assert) {
    reg(4, 0xffffffff);
    execute([0x10340000], assert, 'LPR 3,4');
    // LPR 3, 4
    assert.equal(reg(3), 1);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Load Negative LNR positive", function(assert) {
    reg(4, 0x12345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xedcba988);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR negative", function(assert) {
    reg(4, 0xc2345678);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0xc2345678);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Load Negative LNR 0", function(assert) {
    reg(4, 0);
    execute([0x11340000], assert, 'LNR 3,4');
    // LNR 3, 4
    assert.equal(reg(3), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Load Multiple LM", function(assert) {
    reg(3, 0x10);
    state['MS'][0x110] = 0x12345678;
    state['MS'][0x114] = 0x11223344;
    state['MS'][0x118] = 0x55667788;
    state['MS'][0x11c] = 0x99aabbcc;
    execute([0x98253100], assert, 'LM 2,5,100(3)');
    // Load registers 2 through 5 starting at 0x110
    assert.equal(reg(2), 0x12345678);
    assert.equal(reg(3), 0x11223344);
    assert.equal(reg(4), 0x55667788);
    assert.equal(reg(5), 0x99aabbcc);
  });

  QUnit.test( "add", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000005);
    execute([0x1a120000], assert, 'AR 1,2');
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x1234567d);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "two adds", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    reg(3, 0x00000010);
    execute([0x1a121a31], assert, 'AR 1,2');
    executeInstr(); // Run the second instruction
    console.log('reg 31 has ' + state['LS'][0x31].toString(16));
    assert.equal(reg(1), 0x12345679);
    assert.equal(reg(3), 0x12345689);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "add-negative", function(assert) {
    reg(1, 0x81234567);
    reg(2, 0x00000001);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x81234568);
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "add-zero", function(assert) {
    reg(1, 0x00000002);
    reg(2, 0xfffffffe);
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "add-overflow-trap-disabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 0; // Disable overflow interrupt
    execute([0x1a120000], assert, 'AR 1,2');
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "add-overflow-trap-enabled", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000001);
    state['PROGMASK'] = 8; // Enable overflow interrupt
    assert.throws(function() {
      execute([0x1a120000], assert, 'AR 1,2');
      console.log('no throw');
    });
  });

  QUnit.test( "add A", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5a156200], assert, 'A 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x34567890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000202);
    state['MS'][0x500] = 0x34567890; // Only 7890 used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 + 0x7890);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Add Halfword AH sign extend", function(assert) {
    reg(1, 1);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xfffe1234; // only fffe (-2) used
    execute([0x4a156200], assert, 'AH 1,200(5,6)');
    assert.equal(reg(1), 0xffffffff); // -1
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.test( "Add Logical ALR (i.e. unsigned) - zero no carry ", function(assert) {
    reg(1, 0);
    reg(2, 0);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero, no carry
  });

  QUnit.test( "Add Logical ALR - non-zero no carry ", function(assert) {
    reg(1, 0xffff0000);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0xffff0002);
    assert.equal(state['CR'], 1); // Nonzero, no carry
  });

  QUnit.test( "Add Logical ALR - zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000002);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Zero and carry
  });


  QUnit.test( "Add Logical ALR - not zero, carry  ", function(assert) {
    reg(1, 0xfffffffe);
    reg(2, 0x00000003);
    execute([0x1e120000], assert, 'ALR 1,2');
    assert.equal(reg(1), 1);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "Add Logical AL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xf0000000;
    execute([0x5e156200], assert, 'AL 1,200(5,6)');
    assert.equal(reg(1), 0x02345678);
    assert.equal(state['CR'], 3); // Not zero, carry
  });

  QUnit.test( "subtract", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x1b120000], assert, 'SR 1,2');
    assert.equal(reg(1), 0x12345677);
  });

  QUnit.test( "Subtract S", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x5b156200], assert, 'S 1,200(5,6)');
    assert.equal(reg(1), 0x00045678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Halfword SH", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12300000;
    execute([0x4b156200], assert, 'SH 1,200(5,6)');
    assert.equal(reg(1), 0x12345678 - 0x1230);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Subtract Logical SLR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x1f120000], assert, 'SLR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 2); // Difference is zero (carry)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0xffffffff);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x111111111;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), 0xeeeeeeee);
    assert.equal(state['CR'], 3); // Non-zero, carry (no borrow)
  });

  QUnit.test( "Subtract Logical SL", function(assert) {
    reg(1, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x23456789;
    execute([0x5f156200], assert, 'SL 1,200(5,6)');
    assert.equal(reg(1), (0x12345678 - 0x23456789) >>> 0);
    assert.equal(state['CR'], 1); // Non-zero, no carry (borrow)
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x12345678);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0x12345678); // Unchanged
    assert.equal(state['CR'], 0); // Operands are equal
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 0xfffffffe); // -2
    reg(2, 0xfffffffd); // -3
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 0xfffffffe); // Unchanged
    assert.equal(state['CR'], 2); // First operand is high
  });

  QUnit.test( "Compare CR", function(assert) {
    reg(1, 2);
    reg(2, 3);
    execute([0x19120000], assert, 'CR 1,2');
    assert.equal(reg(1), 2); // Unchanged
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "Compare C", function(assert) {
    reg(1, 0xf0000000);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x12345678;
    execute([0x59156200], assert, 'C 1,200(5,6)');
    assert.equal(state['CR'], 1); // First operand is low
  });

  QUnit.test( "multiply MR: 28×19", function(assert) {
    reg(3, 28);
    reg(4, 19);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 28 * 19);
  });

  // Pseudo-random number generator from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript

  function mulberry32(a) {
    return function() {
      var t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }

  var rand = mulberry32(1);

  QUnit.test( "multiply MR: random", function(assert) {
    for (var i = 0; i < 100; i++) {
      var n1 = Math.trunc(rand() * 1000);
      var n2 = Math.trunc(rand() * 1000);
      if (n1 * n2 >= 0x10000) continue;
      if (n1 == 6) continue
      reg(3, n1);
      reg(4, n2);
      execute([0x1c240000], assert, 'MR 2,4');
      assert.equal(reg(2), 0, n1 + '×' + n2);
      assert.equal(reg(3), n1 * n2, n1 + '×' + n2);
    }
  });

  QUnit.test( "multiply MR: large", function(assert) {
    reg(3, 0x12345678);
    reg(4, 0x34567890);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3b8c7b8);
    assert.equal(reg(3), 0x3248e380);
  });

  QUnit.test( "multiply MR: larger", function(assert) {
    reg(3, 0x7fffffff);
    reg(4, 0x7fffffff);
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0x3fffffff);
    assert.equal(reg(3), 0x00000001);
  });

  QUnit.test( "multiply MR: negative", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0xfffffffb); // -5
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0);
    assert.equal(reg(3), 20);
  });

  QUnit.test( "multiply MR: negative, positive", function(assert) {
    reg(3, 0xfffffffc); // -4
    reg(4, 0x0000000a); // 10
    execute([0x1c240000], assert, 'MR 2,4');
    assert.equal(reg(2), 0xffffffff);
    assert.equal(reg(3), (-40) >>> 0);
  });

  QUnit.test( "Multiply M", function(assert) {
    reg(3, 0x12345678);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x34567890;
    execute([0x5c256200], assert, 'M 2,200(5,6)');
    assert.equal(reg(2), 0x03b8c7b8); // High 32-bits
    assert.equal(reg(3), 0x3248e380); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH - small", function(assert) {
    reg(3, 4);
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0x00000003; // 3
    execute([0x4c356202], assert, 'MH 3,202(5,6)');
    assert.equal(reg(3), 12); // Low 32-bits
  });

  QUnit.test( "Multiply Halfword MH", function(assert) {
    reg(3, 0x00000015); // 21
    reg(5, 0x00000100);
    reg(6, 0x00000200);
    state['MS'][0x500] = 0xffd91111; // -39
    execute([0x4c356200], assert, 'MH 3,200(5,6)');
    assert.equal(reg(3), 0xfffffccd); // Low 32-bits
  });

  QUnit.test( "Divide DR big", function(assert) {
    reg(2, 0x00112233);
    reg(3, 0x44556677);
    reg(4, 0x12345678); // 0x1122334455667788 / 0x12345678
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    console.log('Quotient' + reg(3).toString(16));
    console.log('Remainder' + reg(2).toString(16));
    assert.equal(reg(2), 0x11b3d5f7); // Remainder
    assert.equal(reg(3), 0x00f0f0f0); // Quotient
  });

  QUnit.test( "Divide DR", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, 0x00000234);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), Math.floor(0x112345678 / 0x234)); // Quotient
  });

  QUnit.test( "Divide DR negative", function(assert) {
    reg(2, 0x1);
    reg(3, 0x12345678);
    reg(4, (-0x00000234) >>> 0);
    execute([0x1d240000], assert, 'DR 2,4');
    // divide R2/R3 by R4
    assert.equal(reg(2), 0x112345678 % 0x234); // Remainder
    assert.equal(reg(3), (-Math.floor(0x112345678 / 0x234)) >>> 0); // Quotient
  });

  QUnit.test( "Divide D - overflow", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x23456789;
    assert.throws(function() {
      execute([0x5d256200], assert, 'D 2,200(5,6)');
    });
  });

  QUnit.test( "Divide D", function(assert) {
    reg(2, 0x12345678);
    reg(3, 0x9abcdef0);
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0x73456789;
    execute([0x5d256200], assert, 'D 2,200(5,6)');
    assert.equal(reg(2), 0x50c0186a); // Remainder
    assert.equal(reg(3), 0x286dead6); // Quotient
  });

  QUnit.test( "Convert to Binary CVB: princ op", function(assert) {
    // Example from Principles of Operation p122
    reg(5, 50); // Example seems to have addresses in decimal?
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 25594); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: bad sign", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x00255941; // 1 is not a valid sign
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  // Needs DC0 to support correction properly
  QUnit.skip( "Convert to Binary CVB: bad digit", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: doubleword unaligned", function(assert) {
    reg(5, 0);
    reg(6, 0);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x002a594f;
    assert.throws(function() {
      execute([0x4f756034], assert, 'CVB 7,34(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.throws(function() {
      execute([0x4f756031], assert, 'CVB 7,31(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000214;
    state['MS'][1004] = 0x8000000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
    assert.equal(reg(7), 2148000000); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB: big overflow", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x12345678;
    state['MS'][1004] = 0x4800000f;
    assert.throws(function() {
      execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    });
  });

  QUnit.test( "Convert to Binary CVB: large", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000021;
    state['MS'][1004] = 0x2345678f;
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), 212345678); // Note: decimal, not hex
  });


  QUnit.test( "Convert to Binary CVB: negative", function(assert) {
    reg(5, 50);
    reg(6, 900);
    state['MS'][1000] = 0x00000000;
    state['MS'][1004] = 0x0025594d; // d is negative
    execute([0x4f756032], assert, 'CVB 7,32(5,6)');
    assert.equal(reg(7), (-25594) >>> 0); // Note: decimal, not hex
  });

  // QE900/073C, CLF 112
  QUnit.test( "Convert to Binary CVB", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567f; // Decimal 1234567+
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), 1234567); // Note: decimal, not hex
  });

  QUnit.test( "Convert to Binary CVB neg", function(assert) {
    reg(5, 0x100);
    reg(6, 0x200);
    state['MS'][0x500] = 0;
    state['MS'][0x504] = 0x1234567b; // Decimal 1234567-
    execute([0x4f156200], assert, 'CVB 1,200(5,6)');
    assert.equal(reg(1), (-1234567) >>> 0); // Note: decimal, not hex
  });

  QUnit.test( "Shift Left Single SLA", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2, i.e. 2.
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA extrabits", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0x00000001);
    execute([0x8b1f2fc1], assert, 'SLA 1,fc1(2)'); // shift value is 6 bits, fc ignored
    assert.equal(reg(1), 0x12345678 << 2);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0", function(assert) {
    reg(1, 0x12345678);
    execute([0x8b100000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x12345678);
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.test( "Shift Left Single SLA 0 negative", function(assert) {
    reg(1, 0x92345678);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0x92345678); // Should be unchanged
    assert.equal(state['CR'], 1); // Negative
  });


  QUnit.test( "Shift Left Single SLA 0 zero", function(assert) {
    reg(1, 0);
    execute([0x8b1f0000], assert, 'SLA 1,0(0)');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Shift Left Single SLA: positive overflow", function(assert) {
    reg(1, 0x10000000);
    reg(2, 2); // Shift by 2 still fits
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x40000000);
    assert.equal(state['CR'], 2); // Positive

    reg(1, 0x10000000);
    reg(2, 3); // Shift by 3 overflows
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x00000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out by 32", function(assert) {
    reg(1, 0x7fffffff);
    reg(2, 0x00000020); // Shift by 32 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: shift out negative", function(assert) {
    reg(1, 0x80000000);
    reg(2, 0x0000001f); // Shift by 31 shifts out entire number
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA: negative overflow", function(assert) {
    reg(1, 0x80000000);
    reg(2, 21); // Shift by 2 should overflow
    execute([0x8b1f2000], assert, 'SLA 1,0(2)'); // shift left by R2
    assert.equal(reg(1), 0x80000000);
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative-overflow", function(assert) {
    reg(1, 0x80000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0x80000004); // Keep the sign
    assert.equal(state['CR'], 3); // Overflow
  });

  QUnit.test( "Shift Left Single SLA negative", function(assert) {
    reg(1, 0xf0000001);
    reg(2, 0x00000001);
    execute([0x8b1f2001], assert, 'SLA 1,1(2)'); // shift left by 1 + R2
    assert.equal(reg(1), 0xc0000004); // Keep the sign
    assert.equal(state['CR'], 1); // Negative
  });

  QUnit.skip( "Add Decimal AD", function(assert) {
    // add 12+ and 34+
    // Stored as 12a 34f (plus is a, c, e, f; minus is b, d)
    state['MS'][0x100] = 0x0012a000;
    state['MS'][0x104] = 0x034f0000;
    // 
    reg(1, 2);
    reg(2, 5);
    // First operand at 0x102, length 2. Second operand at 105, length 2.
    execute([0xfa221100, 0x21000000], assert, 'AD 100(2,1),100(2,2)');
    assert.equal(reg(4), 0x12344455);
    assert.equal(state['MS'][0x100],  0x046f0000); // result is 46
    assert.equal(state['MS'][0x104],  0x034f0000); // Unchanged
    assert.equal(state['CR'], 2); // Positive
  });

  QUnit.skip( "Zero and Add ZAP", function(assert) {
    state['MS'][0x100] = 0x2a000000; // 2+
    state['MS'][0x200] = 0x3a000000; // 3+
    execute([0xf8110100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x100],  0x3a000000); // 3+
  });

  QUnit.skip( "Zero and Add ZAP offset", function(assert) {
    state['MS'][0x100] = 0x02a00000; // 2+
    state['MS'][0x200] = 0x0003a000; // 3+
    execute([0xf8110100, 0x02000000], assert, 'ZAP 100(1, 0), 200(1, 0)');
    assert.equal(state['MS'][0x101],  0x3a000000); // 3+
  });

  QUnit.skip( "Load (FP short) LER", function(assert) {
    reg(1, 0x12345678);
    reg(4, 0x22334455);
    execute([0x38410000], assert, 'LER 4,1');
    assert.equal(reg(4), 0x12344455);
  });

  QUnit.skip( "Load (FP long) LDR", function(assert) {
    reg(1, 0x12345678);
    execute([0x28410000], assert, 'LDR 4,1');
    assert.equal(reg(4), 0x12345678);
  });

  QUnit.skip( "Load Complement (FP) LCER", function(assert) {
    reg(1, 0x12345678);
    reg(4, 0x22334455);
    execute([0x33410000], assert, 'LCER 4,1');
    assert.equal(reg(4), 0x92344455);
  });

  QUnit.skip( "Load Complement (FP long) LCDR", function(assert) {
    reg(1, 0x12345678);
    execute([0x23410000], assert, 'LCDR 4,1');
    assert.equal(reg(4), 0x92345678);
  });

  QUnit.skip( "Move MVI", function(assert) {
    state['MS'][0x100] = 0x11223344;
    reg(1, 1);
    execute([0x92551100], assert, 'MVI 100(1),55'); // Move byte 55 to location 101
    assert.equal(state['MS'][0x100], 0x11553344);
  });

  QUnit.skip( "Move MVC", function(assert) {
    state['MS'][0x100] = 0x12345678;
    state['MS'][0x104] = 0xabcdef01;
    reg(1, 1);
    reg(2, 0);
    execute([0xd2030100, 0x21040000], assert, 'MVC 100(3,1),105(0)'); // Move 3 bytes from 105 to 101
    assert.equal(state['MS'][0x100], 0x1bcd5678);
    assert.equal(state['MS'][0x104], 0xaabbccdd); // Unchanged
  });

  QUnit.skip( "Compare Logical CLR", function(assert) {
    reg(1, 1);
    reg(2, 0);
    execute([0x15120000], assert, 'CLR 1,2');
    assert.equal(state['MS'][0x100], 0x1bcd5678);
    assert.equal(state['MS'][0x104], 0xaabbccdd); // Unchanged
  });

  QUnit.test( "And NR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0x12005600);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "And NR 0", function(assert) {
    reg(1, 0x12345678);
    reg(2, 0xedcba987);
    execute([0x14120000], assert, 'NR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['CR'], 0); // Zero
  });

  QUnit.test( "Or OR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x16120000], assert, 'OR 1,2');
    assert.equal(reg(1), 0xff34ff78);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Exclusive or XR", function(assert) {
    reg(1, 0xff00ff00);
    reg(2, 0x12345678);
    execute([0x17120000], assert, 'XR 1,2');
    assert.equal(reg(1), 0xed34a978);
    assert.equal(state['CR'], 1); // Not zero
  });

  QUnit.test( "Shift Left Single SLL various", function(assert) {
    for (var i = 0; i < 40; i++) {
      reg(1, 1);
      reg(2, 0x12340000 + i); // Shift i bits
      execute([0x891f2100], assert, 'SLL 1,100(2)');
      if (i < 32) {
        assert.equal(reg(1), (1 << i) >>> 0, 'Shift by ' + i);
      } else {
        assert.equal(reg(1), 0, 'Shift by ' + i);
      }
    }
  });

  QUnit.test( "Shift Left Single SLL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x891f2100], assert, 'SLL 1,100(2)');
    assert.equal(reg(1), 0x11a2b3c0);
  });

  QUnit.test( "Shift Right Single SRL", function(assert) {
    reg(1, 0x82345678);
    reg(2, 0x12340003); // Shift 3 bits
    execute([0x881f2100], assert, 'SRL 1,100(2)');
    assert.equal(reg(1), 0x82345678 >>> 3);
  });

  QUnit.test( "Branch on condition BCR", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x12345678);
  });

  QUnit.test( "Branch on condition BCR, always taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 0;
    execute([0x07f10000], assert, 'BCR 15,1'); // always
    assert.equal(state['IAR'], 0x12345678);
  });

  QUnit.test( "Branch on condition BCR, not taken", function(assert) {
    reg(1, 0x12345678); // Branch destination
    state['CR'] = 1;
    execute([0x07810000], assert, 'BCR 8,1');
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch and link BALR", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    reg(2, 0x12345678); // Branch destination
    execute([0x05120000], assert, 'BALR 1,2');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x12345678);
  });

  QUnit.test( "Branch and link BALR -not taken", function(assert) {
    state['ILC'] = 2; // overwritten with 1
    state['CR'] = 3;
    state['PROGMASK'] = 0xa;
    execute([0x05100000], assert, 'BALR 1,0');
    assert.equal(reg(1), 0x7a000402); // low-order PSW: ILC, CR, PROGMASK, return IAR
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Branch on Count BCTR - taken", function(assert) {
    reg(1, 3); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 2);
    assert.equal(state['IAR'], 0x12345678);
  });

  QUnit.test( "Branch on Count BCTR - taken, negative", function(assert) {
    reg(1, 0); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0xffffffff);
    assert.equal(state['IAR'], 0x12345678);
  });

  QUnit.test( "Branch on Count BCTR - not taken", function(assert) {
    reg(1, 1); // Counter
    reg(2, 0x12345678); // Branch destination
    execute([0x06120000], assert, 'BCTR 1,2');
    assert.equal(reg(1), 0);
    assert.equal(state['IAR'], 0x402);
  });

  QUnit.test( "Set Program Mask SPM", function(assert) {
    reg(1, 0x12345678); // Mask 2
    execute([0x041f0000], assert, 'SPM 1');
    assert.equal(state['CR'], 0x1);
    assert.equal(state['PROGMASK'], 0x2);
  });

  QUnit.skip( "Supervisor Call SVC", function(assert) {
    execute([0x0a120000], assert, 'SVC 12');
  });

  QUnit.skip( "Set Storage Key SSK", function(assert) {
    execute([0x08120000], assert, 'SSK 1,2');
    // Need to check
  });

  QUnit.skip( "Insert Storage Key ISK", function(assert) {
    execute([0x09120000], assert, 'ISK 1,2');
    // Need to check
  });

  QUnit.skip( "Test and Set - not set TS", function(assert) {
    reg(2, 3); // Counter
    state['MS'][0x100] = 0x83857789; // 102 top bit not set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 0); // Not set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });

  QUnit.skip( "Test and Set - set TS", function(assert) {
    reg(2, 3); // Counter
    state['MS'][0x100] = 0x8385c789; // 102 top bit set
    execute([0x93002100], assert, 'TS 100(2)');
    assert.equal(state['CR'], 1); // Set
    assert.equal(state['MS'][0x100], 0x8385ff89);
  });

  QUnit.skip( "Diagnose", function(assert) {
    reg(2, 3); // Counter
    execute([0x83123456], assert, 'diagnose');
  });
});
</script>
</body>
</html>
