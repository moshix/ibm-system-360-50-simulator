<!DOCTYPE html>
<html>
<!--
This file holds unittests for engine.js, using qunit
-->
<head>
  <meta charset="utf-8">
  <title>Engine unittests</title>
  <link rel="stylesheet" href="qunit-2.9.2.css" >
  <script src="data.js"></script>
  <script src="../decode.js"></script>
  <script src="../engine.js"></script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>

  <script src="qunit-2.9.2.js"></script>
  <script>

// Format d as 4 hex bytes
function fmt4(d) {
  return d.toString(16).padStart(8, '0');
}

function alert(msg) {
  QUnit.assert.equal(0, 1, msg);
}

// Helper to call all the adder routines
function adder(state, entry) {
  adderLX(state, entry);
    adderRY(state, entry);
    adderDG(state, entry);
    adderT(state, entry);
}

// QUnit.config.collapse = false; // Expand all failures

QUnit.test( "adder", function(assert) {
  var state = {'L': 0x12345678, 'R': 0x23456789};
  var entry = {'LX': 1 /* L */, 'RY': 1 /* R */, 'TC': 1 /* add */, 'AD': 1 /* default op */, 'AL': 0 /* shift */, 'DG': 0 /* default */};
  adder(state, entry);
  assert.equal(state['T0'], 0x12345678 + 0x23456789);
});

QUnit.test( "adder2", function(assert) {
  var state = {'L': 0x1234, 'H': 0x1233};
  var entry = {'LX': 1 /* L */, 'RY': 4 /* H */, 'TC': 0 /* sub */, 'AD': 1 /* default op */, 'AL': 0 /* shift */, 'DG': 0 /* default */};
  adder(state, entry);
  assert.equal(state['T0'], 0xfffffffe); // H - L, 1's complement
});

QUnit.test( "adder3", function(assert) {
  var state = {'M': 0x12345678};
  var entry = {'CE': 0x1234, 'LX': 3 /* E */, 'RY': 3 /* M23 */, 'TC': 1 /* add */, 'AD': 1 /* default op */, 'AL': 0 /* shift */, 'DG': 0 /* default */};
  adder(state, entry);
  assert.equal(state['T0'], (0x1234 << 1) + 0x5678);
});

QUnit.test( "adder lx 0 0", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 0});
  assert.equal(state['XG'], 0);
});

QUnit.test( "adder lx 1 L", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 1});
  assert.equal(state['XG'], 0x12345678);
});

QUnit.test( "adder lx 2 SGN", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 2});
  assert.equal(state['XG'], 0x80000000);
});

QUnit.test( "adder lx 3 E", function(assert) { // E shifted left one
  var state = {};
  adderLX(state, {'LX': 3, 'CE': 0x9});
  assert.equal(state['XG'], 0x12);
});

QUnit.test( "adder lx 4 LRL", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 4 /* LRL */});
  assert.equal(state['XG'], 0x56780000);
});

QUnit.skip( "adder lx 5 LWA", function(assert) {
});

QUnit.test( "adder lx 6 4", function(assert) {
  var state = {};
  adderLX(state, {'LX': 6});
  assert.equal(state['XG'], 4);
});

QUnit.skip( "adder lx 7 64C", function(assert) {
  var state = {};
  adderLX(state, {'LX': 7});
  assert.equal(state['XG'], (~64) >>> 0); // Complement of 64
});

QUnit.test( "adder RY 0 0", function(assert) {
  var state = {};
  adderRY(state, {'RY': 0});
  assert.equal(state['Y'], 0);
});

QUnit.test( "adder RY 0 0", function(assert) {
  var state = {};
  adderRY(state, {'RY': 0});
  assert.equal(state['Y'], 0);
});

QUnit.test( "adder RY 1 R", function(assert) {
  var state = {'R': 0x12345678};
  adderRY(state, {'RY': 1});
  assert.equal(state['Y'], 0x12345678);
});

QUnit.test( "adder RY 2 M", function(assert) {
  var state = {'M': 0x12345678};
  adderRY(state, {'RY': 2});
  assert.equal(state['Y'], 0x12345678);
});

QUnit.test( "adder RY 3 M23", function(assert) {
  var state = {'M': 0x12345678};
  adderRY(state, {'RY': 3});
  assert.equal(state['Y'], 0x5678);
});

QUnit.test( "adder RY 4 H", function(assert) {
  var state = {'H': 0x12345678};
  adderRY(state, {'RY': 4});
  assert.equal(state['Y'], 0x12345678);
});

QUnit.skip( "adder RY 5 SEMT", function(assert) {
});

  // Based on 02D3
QUnit.test( "adder-dec", function(assert) {
  var state = {'R': 0};
  adder(state, {'RY': 1, 'TC': 0, 'LX': 0, 'TR': 1, 'AD': 1, 'AL': 0, 'DG': 0});
  assert.equal(state['T0'], 0xffffffff);
});

  // The default adder inputs when nothing happens
QUnit.test( "adder-default", function(assert) {
  var state = {};
  adder(state, {'RY': 0, 'TC': 1, 'LX': 0, 'TR': 7, 'AD': 1, 'AL': 0, 'DG': 0});
  assert.equal(state['T0'], 0);
});

QUnit.skip( "adder ad 2 BCF0", function(assert) {
});

QUnit.test( "adder-carry0 ad 4 BC0", function(assert) {
  var state = {'XG': 0xffffffff, 'Y': 0x00000001, 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0);

  state = {'R': 0xfffffffe, 'L': 0x00000001, 'CIN': 0};
  adder(state, {'RY': 1 /* R */, 'TC': 1, 'LX': 1 /* L */, 'TR': 7, 'AD': 4 /* BC0 */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xffffffff);

  state = {'R': 0xffffffff, 'L': 0x10000000, 'CIN': 0};
  adder(state, {'RY': 1 /* R */, 'TC': 1, 'LX': 1 /* L */, 'TR': 7, 'AD': 4 /* BC0 */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x0fffffff);
});

// 32-bit not
function not(x) {
  return (~x) >>> 0;
}

QUnit.test( "adder-carry0 sub ad 4 BC0", function(assert) {
  // Basic subtraction is 1's complement
  var state = {'Y': 0x00000000, 'XG': not(0x00000001), 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe); // R - L, subtraction is one short without carry-in

  state = {'Y': 0xffffffff, 'XG': not(0x00000000), 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xfffffffe); // subtraction is one short

  state = {'Y': 0xefffffff, 'XG': not(0x10000000), 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xdffffffe); // subtraction is one short
});

QUnit.test( "adder-carry0 sub +hot1 ad 4 BC0", function(assert) {
  // Add hot1 to get 2's complement subtraction
  var state = {'Y': 0x00000000, 'XG': not(0x00000001)};
  adderDG(state, {'DG': 2 /* HOT1 */});
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 0); // Carry = not borrow
  assert.equal(state['T0'], 0xffffffff);

  state = {'Y': 0xffffffff, 'XG': not(0x00000000)};
  adderDG(state, {'DG': 2 /* HOT1 */});
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xffffffff);

  state = {'Y': 0xefffffff, 'XG': not(0x10000000)};
  adderDG(state, {'DG': 2 /* HOT1 */});
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xdfffffff);
});

QUnit.test( "adder-overflow ad 5 BC⩝C", function(assert) {
  // Normal positive addition
  var state = {'XG': 0x12345678, 'Y': 0x12345678, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x12345678 + 0x12345678);

  // positive + positive yields negative overflow
  // Normal positive addition
  var state = {'XG': 0x12345678, 'Y': 0x12345678, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x12345678 + 0x12345678);

  // positive + positive yields negative overflow
  state = {'XG': 0x70000000, 'Y': 0x70000000, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xe0000000);

  // positive + negative okay
  state = {'XG': 0x70000000, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x6fffffff);

  // negative + negative okay
  state = {'XG': 0xffffffff, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe);


  state = {'XG': 0x80000000, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x7fffffff);

  // -1 + 0: no overflow
  state = {'XG': 0x00000000, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xffffffff);

  // -1 + 0 + carry: no overflow
  state = {'XG': 0x00000000, 'Y': 0xffffffff, 'CIN': 1};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0);

  // -1 + 0 + carry: no overflow
  state = {'Y': 0x00000000, 'XG': 0xffffffff, 'CIN': 1};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0);
});

QUnit.test( "adder-subtract-overflow ad 5 BC⩝C", function(assert) {
  // Normal positive subtraction: note that L is subtracted from R
  var state = {'R': 0x12345678, 'L': 0x12345677};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0); // 1's complement subtraction

  // positive - positive yields negative
  state = {'R': 0x70000000, 'L': 0x70000001};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe);

  // positive - negative okay
  state = {'R': 0x12345678, 'L': 0xffffffff};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x12345678);

  // positive - negative overflow
  state = {'R': 0x7fffffff, 'L': 0xfffffffe};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x80000000);

  // negative - negative okay
  state = {'R': 0xfffffffe, 'L': 0xffffffff};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe);

  // negative - positive overflow
  state = {'R': 0x80000000, 'L': 0x00000001};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x7ffffffe);
});

QUnit.skip( "adder ad 6 BC1B", function(assert) {
});

// Carry out of pos 8
QUnit.test( "adderT ad 7 BC8", function(assert) {
  var state = {'XG': 0x00000000, 'AUX': 0, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 7});
  assert.equal(state['CAR'], 0);

  state = {'XG': 0x00800000, 'AUX': 0, 'Y': 0x00800000, 'CIN': 0};
  adderT(state, {'AD': 7});
  assert.equal(state['CAR'], 1);

  state = {'XG': 0x00ffffff, 'AUX': 0, 'Y': 0x00000001, 'CIN': 0};
  adderT(state, {'AD': 7});
  assert.equal(state['CAR'], 1);
});

QUnit.test( "adderT ad 8 DHL", function(assert) {
  var state = {'XG': 0xdddddddd, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['L'], 0, 'No correction');

  state = {'XG': 0xdddddd2d, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['L'], 0x6, 'Low-order');

  state = {'XG': 0x22222222, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['L'], 0x06666666, 'All correction');

  var state = {'XG': 0xdddddddd, 'AUX': 1, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['L'], 0x60000000, 'Aux correction');
  assert.equal(state['AUX'], 0);

  state = {'XG': 0xdddddd22, 'AUX': 1, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['L'], 0x60000006, 'Low-order, aux');

  state = {'XG': 0x22222220, 'AUX': 1, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['L'], 0x66666666, 'All correction, AUX');
});

QUnit.test( "adder ad 9 DC0", function(assert) {
  var state = {'S': [0, 1, 0, 0, 0, 0, 0, 0]};
  adderDG(state, {'AD': 9, 'DG': 0}); // Note AD 9 implemented in adderDG
  assert.equal(state['CIN'], 1);
});

QUnit.skip( "adder ad 10 DDC0", function(assert) {
});

QUnit.test( "adderT ad 11 DHH", function(assert) {
  var state = {'XG': 0xdddddddd, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['L'], 0, 'No correction');
  assert.equal(state['AUX'], 0);

  state = {'XG': 0xddddddd2, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['L'], 0, 'No correction, aux');
  assert.equal(state['AUX'], 1);

  state = {'XG': 0x22222220, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['L'], 0x06666666, 'All correction');
  assert.equal(state['AUX'], 0);

  state = {'XG': 0xffffffff, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['L'], 0x06666666, 'All correction, AUX');
  assert.equal(state['AUX'], 1);

  state = {'XG': 0x22002002, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['L'], 0x06600600, 'Some correction, AUX');
  assert.equal(state['AUX'], 1);
});

QUnit.skip( "adder ad 12 DCBS", function(assert) {
});

QUnit.test( "adder dg 1 CSTAT→ADDER", function(assert) {
  var state = {'CSTAT': 0};
  adderDG(state, {'DG': 1 /* CSTAT→ADDER */});
  assert.equal(state['CIN'], 0);

  state = {'CSTAT': 1};
  adderDG(state, {'DG': 1 /* CSTAT→ADDER */});
  assert.equal(state['CIN'], 1);
});

QUnit.test( "adder dg2 HOT1→ADDER", function(assert) {
  var state = {'L': 0x12345678};
  adder(state, {'LX': 1 /* L */, 'RY': 0 /* 0 */, 'TC': 1 /* add */, 'AD': 1 /* default op */, 'DG': 2 /* HOT1→ADDER */});
  assert.equal(state['T0'], 0x12345679);
});

QUnit.test( "adder dg 3 G1-1", function(assert) {
  var state = {'G1': 1};
  adderDG(state, {'DG': 3 /* G1-1 */});
  assert.equal(state['G1NEG'], 0);
  assert.equal(state['pending']['G1'], 0);

  state = {'G1': 0};
  adderDG(state, {'DG': 3 /* G1-1 */});
  assert.equal(state['G1NEG'], 1);
  assert.equal(state['pending']['G1'], undefined); // No change
});

QUnit.test( "adder dg 4 HOT1,G-1", function(assert) {
  var state = {'G1': 2, 'G2':1};
  adderDG(state, {'DG': 4});
  assert.equal(state['pending']['G1'], undefined); // no change
  assert.equal(state['pending']['G2'], 0);
  assert.equal(state['CIN'], 1);

  state = {'G1': 2, 'G2':0};
  adderDG(state, {'DG': 4});
  assert.equal(state['pending']['G1'], 1);
  assert.equal(state['pending']['G2'], 0xf);
  assert.equal(state['CIN'], 1);
});

QUnit.test( "adder dg 5 G2-1", function(assert) {
  var state = {'G2': 1};
  adderDG(state, {'DG': 5 /* G2-1 */});
  assert.equal(state['G2NEG'], 0);
  assert.equal(state['pending']['G2'], 0);

  state = {'G2': 0};
  adderDG(state, {'DG': 5 /* G2-1 */});
  assert.equal(state['G2NEG'], 1);
  assert.equal(state['pending']['G2'], undefined); // No change below 0
});

QUnit.test( "adder dg 6 G-1", function(assert) {
  var state = {'G1': 2, 'G2':1};
  adderDG(state, {'DG': 6});
  assert.equal(state['pending']['G1'], undefined); // No change
  assert.equal(state['pending']['G2'], 0);

  state = {'G1': 2, 'G2':0};
  adderDG(state, {'DG': 6});
  assert.equal(state['pending']['G1'], 1);
  assert.equal(state['pending']['G2'], 0xf);
});

QUnit.test( "adder dg 7 G1,2-1", function(assert) {
  var state = {'G1': 0, 'G2': 1};
  adderDG(state, {'DG': 7});
  assert.equal(state['G1NEG'], 1);
  assert.equal(state['G2NEG'], 0);
  assert.equal(state['pending']['G1'], undefined); // No change
  assert.equal(state['pending']['G2'], 0);

  var state = {'G1': 0xf, 'G2': 0};
  adderDG(state, {'DG': 7});
  assert.equal(state['G1NEG'], 0);
  assert.equal(state['G2NEG'], 1);
  assert.equal(state['pending']['G1'], 0xe);
  assert.equal(state['pending']['G2'], undefined); // No change
});


QUnit.test( "iar0", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  iar(state, {'IV': 0});
  assert.expect(0);
});

QUnit.test( "iar iv 1 WL→IVD", function(assert) {
  var state = {'WL': 0x0};
  iar(state, {'IV': 1}); // Nop, implemented in iar2
  iar2(state, {'IV': 1});
  state = {'WL': 0x9};
  iar2(state, {'IV': 1});
  assert.throws(function() {
    state = {'WL': 0xa}; // Invalid digit
    iar2(state, {'IV': 1});
  });
});

QUnit.test( "iar iv 2 WR→IVD", function(assert) {
  var state = {'WR': 0x0};
  iar(state, {'IV': 2}); // Nop, implemented in iar2
  iar2(state, {'IV': 2});
  state = {'WR': 0x9};
  iar2(state, {'IV': 2});
  assert.throws(function() {
    state = {'WR': 0xa}; // Invalid digit
    iar2(state, {'IV': 2});
  });
});

QUnit.test( "iar iv 3 W→IVD", function(assert) {
  var state = {'WL': 0x0, 'WR': 0x4};
  iar(state, {'IV': 3}); // Nop, implemented in iar2
  iar2(state, {'IV': 3});
  assert.throws(function() {
    state = {'WL': 0xa}; // Invalid digit
    iar2(state, {'IV': 3});
  });
  assert.throws(function() {
    state = {'WL': 0x0, 'WR': 0xf}; // Invalid digit
    iar2(state, {'IV': 3});
  });
});

QUnit.test( "iar iv 4 IA/4→A,IA", function(assert) {
  var state = {'IAR': 0x12340000};
  iar(state, {'IV': 4});
  assert.equal(state['IAR'], 0x12340004);
  assert.equal(state['SAR'], 0x12340004);
});

QUnit.test( "iar iv 5 IA+2/4", function(assert) {
  // instruction length << 30
  var state = {'ILC': 0, 'IAR': 0x12340000};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x12340000);

  state = {'ILC': 1, 'IAR': 0x12340000};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x12340002); // +2

  state = {'ILC': 2, 'IAR': 0x12340000};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x12340004); // +4

  state = {'ILC': 3, 'IAR': 0x12340000};
  iar(state, {'IV': 5})
  assert.equal(state['IAR'], 0x12340004); // +4
});

QUnit.test( "iar iv 6 IA+2", function(assert) {
  var state = {'IAR': 0x12340000};
  iar(state, {'IV': 6});
  assert.equal(state['IAR'], 0x12340002);
});

QUnit.test( "iar iv 7 IA+0/2→A", function(assert) {
  // No refetch: should increment
  var state = {'SAR': 1, 'IAR': 0x12340002, 'REFETCH': 0};
  iar(state, {'IV': 7, 'ZN': 0});
  assert.equal(state['SAR'], 0x12340004);
  // Refetch, no increment
  state = {'SAR': 1, 'IAR': 0x12340002, 'REFETCH': 1};
  iar(state, {'IV': 7, 'ZN': 0});
  assert.equal(state['SAR'], 0x12340002);

  // Even halfword, SMIF. Should increment. But rounded down? So no change?
  // Unclear if this case should increment or not or if it matters.
  state = {'SAR': 1, 'IAR': 0x12340000, 'REFETCH': 0};
  iar(state, {'IV': 7, 'ZN': 1});
  assert.equal(state['SAR'], 0x12340000);
  // Odd halfword, no refetch, SMIF. Should skip access.
  state = {'SAR': 1, 'IAR': 0x12340002, 'REFETCH': 0};
  iar(state, {'IV': 7, 'ZN': 1});
  assert.equal(state['SAR'], 1);
  // Odd halfword, refetch, SMIF. Should not increment
  state = {'SAR': 1, 'IAR': 0x12340002, 'REFETCH': 1};
  iar(state, {'IV': 7, 'ZN': 1});
  assert.equal(state['SAR'], 0x12340002);
});

QUnit.test( "latch tr 1 R", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  var entry = {'TR': 1 /* R */};
  adderLatch(state, entry);
  assert.equal(state['R'], 0x12345678);
});

QUnit.test( "latch tr 2 R0", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  var entry = {'TR': 2 /* R0 */};
  adderLatch(state, entry);
  assert.equal(state['R'], 0x12781234);
});

QUnit.test( "latch tr 3 M", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  var entry = {'TR': 3 /* M */};
  adderLatch(state, entry);
  assert.equal(state['M'], 0x12345678);
});

QUnit.test( "latch tr 4 D", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234, 'SAR': 0x20};
  state['MS'] = [];
  adderLatch(state, {'TR': 4 /* M */});
  assert.equal(state['SDR'], 0x12345678);
  assert.equal(state['MS'][0x20], 0x12345678);
});

QUnit.test( "latch tr 5 L0", function(assert) {
  var state = {'T': 0x12345678, 'L': 0x56781234};
  adderLatch(state, {'TR': 5 /* L0 */});
  assert.equal(state['L'], 0x12781234);
});

QUnit.test( "latch tr 6 R,A", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  adderLatch(state, {'TR': 6 /* R,A */});
  assert.equal(state['R'], 0x12345678);
  assert.equal(state['SAR'], 0x12345678);
});

QUnit.test( "latch tr 7 L", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 7 /* L */});
  assert.equal(state['L'], 0x12345678);
});

QUnit.skip( "latch tr 8 HA→A", function(assert) {
});

QUnit.test( "latch tr 9 R,AN", function(assert) {
  var state = {'T': 0x12345679};
  adderLatch(state, {'TR': 9 /* R,AN */});
  assert.equal(state['R'], 0x12345679);
  assert.equal(state['SAR'], 0x12345679);
  assert.equal(state['TRAP'], undefined);
});

QUnit.test( "latch tr 10 R,AW", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 10 /* R,AW */});
  assert.equal(state['R'], 0x12345678);
  assert.equal(state['SAR'], 0x12345678);
  assert.equal(state['TRAP'], undefined);
  state = {'T': 0x12345672}; // Halfword
  });

QUnit.test( "latch tr 11 R,AD", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 11 /* R,AD */});
  assert.equal(state['R'], 0x12345678);
  assert.equal(state['SAR'], 0x12345678);
  state = {'T': 0x12345674}; // Word
});

QUnit.test( "latch tr 12 D→IAR", function(assert) {
  var state = {'T': 0x12345678, 'SAR': 0x10};
  state['MS'] = [];
  state['MS'][0x10] = 0x3456789a;
  adderLatch(state, {'TR': 12 /* IAR */});
  assert.equal(state['IAR'], 0x0006789a);
});

QUnit.skip( "latch tr 13 SCAN→D", function(assert) {
});

QUnit.skip( "latch tr 14 R13", function(assert) {
});

QUnit.test( "latch tr 15 A", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 15});
  assert.equal(state['SAR'], 0x12345678);
});

QUnit.test( "latch tr 16 L,A", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 16});
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['SAR'], 0x12345678);
});

// 17: I/O

// 18: unused

// 19: I/O

QUnit.test( "latch tr 20 H", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 20 /* H */});
  assert.equal(state['H'], 0x12345678);
});

QUnit.test( "latch tr 21 IA", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 21});
  assert.equal(state['IAR'], 0x12345678);
});

QUnit.skip( "latch tr 22 FOLD→D", function(assert) {
});

// 23: unused

QUnit.test( "latch tr 24 L,M", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 24});
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['M'], 0x12345678);
});

  // Complex instruction decoding
QUnit.test( "latch 25 MLJK", function(assert) {
  // X=0, B=0
  var state = {'T': 0x12300678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 0);
  assert.equal(state['MD'], 0);
  assert.equal(state['S'][0], 1); // X=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 1); // B=0, i.e. T(16-19), MD

  // X=4, B=0
  state = {'T': 0x12340678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 4);
  assert.equal(state['MD'], 0);
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 1); // B=0, i.e. T(16-19), MD

  // X=4, B=5
  state = {'T': 0x12345678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 4);
  assert.equal(state['MD'], 5);
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 0); // B!=0, i.e. T(16-19), MD

  // X=0, B=5
  state = {'T': 0x12305678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 0);
  assert.equal(state['MD'], 5);
  assert.equal(state['S'][0], 1); // X=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 0); // B=0, i.e. T(16-19), MD

  // Now test ILC, 1SYL
  for (var i = 0; i < 16; i++) {
    state = {'T': i << 28, 'S': []};
    adderLatch(state, {'TR': 25});
    var top2 = i >> 2;
    if (top2 == 0) {
      assert.equal(state['1SYL'], 1);
      assert.equal(state['ILC'], 1);
    } else if (top2 == 1 || top2 == 2) {
      assert.equal(state['1SYL'], 0);
      assert.equal(state['ILC'], 2);
    } else {
      assert.equal(state['1SYL'], 0);
      assert.equal(state['ILC'], 3);
    }
  }
});

QUnit.test( "latch tr 26 MHL", function(assert) {
  var state = {'T': 0x12345678, 'M': 0x11223344};
  adderLatch(state, {'TR': 26});
  assert.equal(state['MD'], 0x1);
  assert.equal(state['M'], 0x11221234);
});

QUnit.test( "latch tr 27 MD", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 27});
  assert.equal(state['MD'], 0x3);
});

QUnit.test( "latch tr 28 M,SP", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 28});
  assert.equal(state['M'], 0x12345678);
  assert.equal(state['SP'], 0x8);
});

QUnit.test( "latch29 D*BS", function(assert) {
  // BS = 0011: only modify last two memory words
  var state = {'T': 0x12345678, 'BS': [0, 0, 1, 1], 'SAR': 0x30};
  state['MS'] = [];
  state['MS'][0x30] = 0x9abcdef0;
  adderLatch(state, {'TR': 29});
  assert.equal(state['SDR'], 0x9abc5678);
  assert.equal(state['MS'][0x30], 0x9abc5678);
});

QUnit.skip( "latch tr 30 L13", function(assert) {
});

QUnit.test( "latch tr 31 J", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 31 /* J */});
  assert.equal(state['J'], 0x8);
});

QUnit.test( "mover", function(assert) {
  // Extract 5 from E, 8 from M3
  var state = {'M': 0x12345678, 'MB': 3};
  var entry = {'LU': 0, 'MV': 2 /* MMB */, 'UL': 0 /* E */, 'UR': 2 /* V */, 'WM': 6 /* WL->J */, 'CE': 0x5};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x58);
  assert.equal(state['WL'], 0x5);
  assert.equal(state['J'], 0x5);
  assert.equal(state['WR'], 0x8);
});

QUnit.test( "mover lu 4 XTR", function(assert) {
  var state = {'M': 0x12345678, 'MB': 3};
  var entry = {'LU': 4 /* XTR */, 'MV': 2 /* MMB */, 'UL': 0 /* E */, 'UR': 2 /* V */, 'WM': 6 /* WL->J */, 'CE': 0x5};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['U'], 0);
});

QUnit.test( "mover2", function(assert) {
  // E->WR, W->MMB
  var state = {'MB': 0, 'M': 0x12345678};
  var entry = {'LU': 0, 'MV': 0, 'UL': 1, 'UR': 0, 'WM': 1, 'RY': 0, 'CE': 7};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 7);
  assert.equal(state['WL'], 0);
  assert.equal(state['WR'], 7);
  assert.equal(state['M'], 0x07345678);
});

QUnit.test( "movers", function(assert) {
  // E->WR, W->MMB
  var state = { 'LB': 0, 'L': 0x34000000, 'MB': 0, 'M': 0x12000000};
  // LLB -> U, MLB -> V, ?->WL, ?->WR
  var entry = {'LU': 7, 'MV': 2, 'UL': 3, 'UR': 3, 'WM': 0};
  state['WFN'] = 1; // or
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x12 | 0x34);

  state['WFN'] = 2; // and
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x12 & 0x34);

  state['WFN'] = 3; // xor
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x12 ^ 0x34);

  state['WFN'] = 4; // char
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x34);

  state['WFN'] = 5; // zone
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x32); // Assuming w's zone is overwritten, keep numeric

  state['WFN'] = 6; // numeric
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x14);

  state['WFN'] = 0; // cross
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x43);
});

QUnit.test("moverU 0", function(assert) {
  state = {};
  moverU(state, {'LU': 0});
  assert.equal(state['U'], 0);
});

QUnit.test("moverU 1 MD,F", function(assert) {
  state = {'MD': 0x3, 'F': 0x4};
  moverU(state, {'LU': 1});
  assert.equal(state['U'], 0x34);
});

QUnit.test("moverU 2 R3", function(assert) {
  state = {'R': 0x11223344};
  moverU(state, {'LU': 2});
  assert.equal(state['U'], 0x44);
});

QUnit.test("moverU 4 XTR", function(assert) {
  state = {};
  moverU(state, {'LU': 4});
  assert.equal(state['U'], 0);
});

QUnit.test("moverU 5 PSW4", function(assert) {
  state = {'ILC': 2, 'CR': 3, 'PROGMASK': 0xa};
  moverU(state, {'LU': 5});
  assert.equal(state['U'], 0xba);
});

QUnit.test("moverU 6 LMB", function(assert) {
  state = {'L': 0x11223344, 'MB': 2};
  moverU(state, {'LU': 6});
  assert.equal(state['U'], 0x33);
});

QUnit.test("moverU 7 LLB", function(assert) {
  state = {'L': 0x11223344, 'LB': 1};
  moverU(state, {'LU': 7});
  assert.equal(state['U'], 0x22);
});

QUnit.test("moverV 0 0", function(assert) {
  state = {};
  moverV(state, {'MV': 0});
  assert.equal(state['V'], 0);
});

QUnit.test("moverV 1 MLB", function(assert) {
  state = {'M': 0x11223344, 'LB': 1};
  moverV(state, {'MV': 1});
  assert.equal(state['V'], 0x22);
});

QUnit.test("moverV 2 MMB", function(assert) {
  state = {'M': 0x11223344, 'MB': 2};
  moverV(state, {'MV': 2});
  assert.equal(state['V'], 0x33);
});

QUnit.test("storeMover WM 1 W→MMB", function(assert) {
  var state = {'W': 0x89, 'WL': 0x8, 'WR': 0x9, 'MB': 2, 'M': 0x11223344};
  storeMover(state, {'WM': 1});
  assert.equal(state['M'], 0x11228944);
});

QUnit.test("storeMover WM 2 W67→MB", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 2});
  assert.equal(state['MB'], 1);
});

QUnit.test("storeMover WM 3 W67→LB", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 3});
  assert.equal(state['LB'], 1);
});

QUnit.test("storeMover WM 4 W27→PSW4", function(assert) {
  var state = {'W': 0x98, 'WL': 9, 'WR': 8};
  storeMover(state, {'WM': 4});
  assert.equal(state['CR'], 0x1);
  assert.equal(state['PROGMASK'], 0x8);
});

QUnit.test("storeMover WM 5 W→PSW0", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 5});
  assert.equal(state['SYSMASK'], 0x89);
});

QUnit.test("storeMover WM 6 WL→J", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 6});
  assert.equal(state['J'], 8);
});

QUnit.skip("storeMover WM 7 W→CHCTL", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
});

QUnit.test("storeMover WM 8 W,E→A(BUMP)", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 8, 'CE': 7});
  assert.equal(state['SAR'], 0x100089c);
});

QUnit.test("storeMover WM 9 WL→G1", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 9});
  assert.equal(state['G1'], 8);
});

QUnit.test("storeMover WM 10 WR→G2", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 10});
  assert.equal(state['G2'], 9);
});

QUnit.test("storeMover WM 11 W→G", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 11});
  assert.equal(state['G1'], 8);
  assert.equal(state['G2'], 9);
});

QUnit.skip("storeMover WM 12 W→MMB(E?)", function(assert) {
});

QUnit.test("storeMover WM 13 WL→MD", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 13});
  assert.equal(state['MD'], 8);
});

QUnit.test("storeMover WM 14 WR→F", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 14});
  assert.equal(state['F'], 9);
});

QUnit.test("storeMover WM 15 W→MD,F", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 15});
  assert.equal(state['MD'], 8);
  assert.equal(state['F'], 9);
});

QUnit.test( "counters", function(assert) {
  var state = {'LB': 1, 'MB': 1, 'MD': 1};
  var entry = {'UP': 0 /* 0 -> */, 'LB': 1, 'MB': 0, 'MD': 0};
  counters(state, entry);
  assert.equal(state['LB'], 0);
  assert.equal(state['MB'], 1);
  assert.equal(state['MD'], 1);
  entry = {'UP': 1 /* 3 -> */, 'LB': 0, 'MB': 1, 'MD': 0};
  counters(state, entry);
  assert.equal(state['LB'], 0);
  assert.equal(state['MB'], 3);
  assert.equal(state['MD'], 1);
  entry = {'UP': 2 /* dec */, 'LB': 0, 'MB': 1, 'MD': 1};
  counters(state, entry);
  assert.equal(state['LB'], 0);
  assert.equal(state['MB'], 2);
  assert.equal(state['MD'], 0);
  entry = {'UP': 3 /* inc */, 'LB': 1, 'MB': 1, 'MD': 0};
  counters(state, entry);
  assert.equal(state['LB'], 1);
  assert.equal(state['MB'], 3);
  assert.equal(state['MD'], 0);
});

QUnit.test( "localStorage", function(assert) {
  var ls = new Array(64);
  for (var i = 0; i < 64; i++) {
    ls[i] = i;
  }
  var state = {'LS': ls};
  var entry = {'WS': 1 /* WS1 -> LSA */, 'SF': 2 /* LS->R->LS */};
  localStorageLSAR(state, {'WS': 1 /* WS1 -> LSA */});
  assert.equal(state['LSAR'], 49); // LSFN = 0b110001
  localStore(state, {'SF': 2 /* LS->R->LS */});
  assert.equal(state['R'], 49);
});

QUnit.test("localStorage LSAR 1 WS1→LSA", function(assert) {
  var state = {};
  localStorageLSAR(state, {'WS': 1});
  assert.equal(state['LSAR'], 0x31);
});

QUnit.test("localStorage LSAR 2 WS2→LSA", function(assert) {
  var state = {};
  localStorageLSAR(state, {'WS': 2});
  assert.equal(state['LSAR'], 0x32);
});

QUnit.test("localStorage LSAR 3 WS,E→LSA", function(assert) {
  var state = {};
  localStorageLSAR(state, {'WS': 3, 'CE': 5});
  assert.equal(state['LSAR'], 0x35);
});

QUnit.test("localStorage LSAR 4 FN,J→LSA", function(assert) {
  var state = {'FN': 2, 'J': 3};
  localStorageLSAR(state, {'WS': 4, 'SF': 7});
  assert.equal(state['LSAR'], undefined); // Blocked by SF=7
  var state = {'FN': 2, 'J': 3, 'WS': 0};
  localStorageLSAR(state, {'WS': 4, 'SF': 0});
  assert.equal(state['LSAR'], 0x23);
});

QUnit.test("localStorage LSAR 5 FN,JΩ1→LSA", function(assert) {
  var state = {'FN': 2, 'J': 2};
  localStorageLSAR(state, {'WS': 5});
  assert.equal(state['LSAR'], 0x23);
});

QUnit.test("localStorage LSAR 6 FN,MD→LSA", function(assert) {
  var state = {'FN': 2, 'MD': 7};
  localStorageLSAR(state, {'WS': 6});
  assert.equal(state['LSAR'], 0x27);
});

QUnit.test("localStorage LSAR 7 FN,MDΩ1→LSA", function(assert) {
  var state = {'FN': 2, 'MD': 6};
  localStorageLSAR(state, {'WS': 7});
  assert.equal(state['LSAR'], 0x27);
});

QUnit.test( "localStorage SF=0 R→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'R': 0x11223344};
  localStore(state, {'SF': 0});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['R'], 0x11223344);
});

QUnit.test( "localStorage SF=1 LS→L,R→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'R': 0x11223344};
  localStore(state, {'SF': 1});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['R'], 0x11223344);
});

QUnit.test( "localStorage WS=2 WS2→LSA, SF=2 LS→R→LS", function(assert) {
  var state = {'LS':{0x32: 0x12345678}, 'R': 0x11223344};
  localStorageLSAR(state, {'WS': 2}); // WS2→LSA
  assert.equal(state['LSAR'], 0x32);
  localStore(state, {'SF': 2});
  assert.equal(state['R'], 0x12345678);
});

QUnit.test( "localStorage SF=4 L→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'L': 0x11223344};
  localStore(state, {'SF': 4});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['L'], 0x11223344);
});

QUnit.test( "localStorage SF=5 LS→R,L→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'L': 0x11223344, 'R': 0x55667788};
  localStore(state, {'SF': 5});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['L'], 0x11223344);
  assert.equal(state['R'], 0x12345678);
});

QUnit.test( "localStorage SF=6 LS→L→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'L': 0x11223344};
  localStore(state, {'SF': 6});
  assert.equal(state['LS'][0x32], 0x12345678);
  assert.equal(state['L'], 0x12345678);
});

QUnit.test( "ls sf 0 R→LS", function(assert) {
  var state = {'LS':[], 'R': 0x12345678, 'LSAR': 0x31};
  // Update LSA
  localStorageLSAR(state, {'CE': 4, 'WS': 3 /* WS,E→LSA */});
  // Update LS
  localStore(state, {'SF': 0 /* R→LS */});
  assert.equal(state['LS'][0x34], 0x12345678);
});

QUnit.test( "ls3  WS,E→LSA", function(assert) {
  var state = {'LS': [], 'R': 0x12345678};
  localStorageLSAR(state, {'CE': 5, 'WS': 3 /* WS,E→LSA */});
  assert.equal(state['LSAR'], 0x35); // LSFN = 0b110101
  localStore(state, {'SF': 0 /* R→LS */});
  assert.equal(state['LS'][0x35], 0x12345678);
});

QUnit.test( "roar1", function(assert) {
  var state = {};
  roar(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 4});
  assert.equal(state['ROAR'], 0x49c);
  roarAB(state, {'AB': 1});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar-zn", function(assert) {
  // Test ZN functions
  var state = {'ROAR': 0x49c};
  roarZN(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 2 /* AΩ(B=0)→A */});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c};
  roarZN(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 3 /* AΩ(B=1)→A */});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c};
  roarZN(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 6 /* BΩ(A=0)→B */});
  assert.equal(state['ROAR'], 0x49c | 1);
});

  // Test ZF functions (ZN = 0)
QUnit.test( "roar-zf", function(assert) {
  var state = {'ROAR': 0x480, 'F': 3};
  roarZN(state, {'ZP': 0x12, 'ZF': 10 /* F->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], (0x12 << 6) | (0x3 << 2));

  state = {'ROAR': 0x480, 'M': 0x24ffffff};
  roarZN(state, {'ZP': 0x12, 'ZF': 6 /* M(03)->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], (0x12 << 6) | (0x2 << 2));

  state = {'ROAR': 0x480, 'M': 0x24ffffff};
  roarZN(state, {'ZP': 0x12, 'ZF': 8 /* M(47)->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], (0x12 << 6) | (0x4 << 2));
});

QUnit.test( "ab 0 (0)", function(assert) {
  var state = {'ROAR': 0x49c};
  roarAB(state, {'AB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test( "ab 1 (1)", function(assert) {
  var state = {'ROAR': 0x49c};
  roarAB(state, {'AB': 1});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 2 (S0)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 2});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 2});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 3 (S1)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 3});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 1, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 3});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 4 (S2)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 4});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 1, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 4});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 5 (S3)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 5});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 1, 0, 0, 0, 0]};
  roarAB(state, {'AB': 5});
  assert.equal(state['ROAR'], 0x49c | 2);
});


QUnit.test( "ab 6 (S4)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 6});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 1, 0, 0, 0]};
  roarAB(state, {'AB': 6});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 7 (S5)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 7});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 1, 0, 0]};
  roarAB(state, {'AB': 7});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 8 (S6)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 8});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 1, 0]};
  roarAB(state, {'AB': 8});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 9 (S7)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 9});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 1]};
  roarAB(state, {'AB': 9});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 10 (CSTAT)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 9});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 1]};
  roarAB(state, {'AB': 9});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 11 unused

QUnit.test( "ab 12 (1SYLS)", function(assert) {
  var state = {'ROAR': 0x49c, '1SYLS': 0};
  roarAB(state, {'AB': 12});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, '1SYLS': 1};
  roarAB(state, {'AB': 12});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 13 (LSGNS)", function(assert) {
  var state = {'ROAR': 0x49c, 'LSGNS': 0};
  roarAB(state, {'AB': 13});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'LSGNS': 1};
  roarAB(state, {'AB': 13});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 14 (⩝SGNS)", function(assert) {
  var state = {'ROAR': 0x49c, 'LSGNS': 0, 'RSGNS': 0};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'LSGNS': 1, 'RSGNS': 0};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 2);
  state = {'ROAR': 0x49c, 'LSGNS': 0, 'RSGNS': 1};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 2);
  state = {'ROAR': 0x49c, 'LSGNS': 1, 'RSGNS': 1};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 0);
});

// 15 unused

QUnit.test( "roar ab 16 CRMD", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'CR': 0, 'MD': 7};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'CR': 1, 'MD': 11};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'CR': 2, 'MD': 13};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'CR': 3, 'MD': 14};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  var state = {'ROAR': 0x49c, 'CR': 0, 'MD': 8};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'CR': 1, 'MD': 4};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'CR': 2, 'MD': 2};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'CR': 3, 'MD': 1};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 17 W=0", function(assert) {
  var state = {'ROAR': 0x49c, 'W': 1};
  roarAB(state, {'AB': 17});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 0};
  roarAB(state, {'AB': 17});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 18 WL=0", function(assert) {
  var state = {'ROAR': 0x49c, 'WL': 1};
  roarAB(state, {'AB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'WL': 0};
  roarAB(state, {'AB': 18});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 19 WR=0", function(assert) {
  var state = {'ROAR': 0x49c, 'WR': 1};
  roarAB(state, {'AB': 19});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'WR': 0};
  roarAB(state, {'AB': 19});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip( "roar ab 20 MD=FP", function(assert) {
});

QUnit.test( "roar ab 21 MB=3", function(assert) {
  var state = {'ROAR': 0x49c, 'MB': 2};
  roarAB(state, {'AB': 21});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'MB': 3};
  roarAB(state, {'AB': 21});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 22 G1=0", function(assert) {
  var state = {'ROAR': 0x49c, 'MD': 0xe};
  roarAB(state, {'AB': 22 /* MD3=0 */});
  assert.equal(state['ROAR'], 0x49c | 2);
  state = {'ROAR': 0x49c, 'MD': 0xf};
  roarAB(state, {'AB': 22 /* MD3=0 */});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test( "roar ab 23 G1=0", function(assert) {
  var state = {'ROAR': 0x49c, 'G1': 1};
  roarAB(state, {'AB': 23});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G1': 0};
  roarAB(state, {'AB': 23});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 24 (G1NEG)", function(assert) {
  var state = {'ROAR': 0x49c, 'G1NEG': 0};
  roarAB(state, {'AB': 24});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'G1NEG': 1};
  roarAB(state, {'AB': 24});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 25 (G<4)", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'G1': 0, 'G2': 4};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'G1': 1, 'G2': 1};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  state = {'ROAR': 0x49c, 'G1': 0, 'G2': 3};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 26 (G1MBZ)", function(assert) {
  var state = {'ROAR': 0x49c, 'G1': 1, 'MB': 1};
  roarAB(state, {'AB': 26});
  assert.equal(state['ROAR'], 0x49c | 0);
  var state = {'ROAR': 0x49c, 'G1': 0};
  roarAB(state, {'AB': 26});
  assert.equal(state['ROAR'], 0x49c | 2);
  var state = {'ROAR': 0x49c, 'G1': 1, 'MB': 0};
  roarAB(state, {'AB': 26});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 27: I/O

// 28: I/O

QUnit.test( "ab 29 R(31)", function(assert) {
  var state = {'ROAR': 0x49c, 'R': 0xfffffffe};
  roarAB(state, {'AB': 29});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'R': 1};
  roarAB(state, {'AB': 29});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 30 F(2)", function(assert) {
  var state = {'ROAR': 0x49c, 'F': 13};
  roarAB(state, {'AB': 30});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'F': 2};
  roarAB(state, {'AB': 30});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 31 L(0)", function(assert) {
  var state = {'ROAR': 0x49c, 'L': 0x7fffffff};
  roarAB(state, {'AB': 31});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'L': 0x80000000};
  roarAB(state, {'AB': 31});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 32 F=0", function(assert) {
  var state = {'ROAR': 0x49c, 'F': 1};
  roarAB(state, {'AB': 32});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'F': 0};
  roarAB(state, {'AB': 32});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 33 (UNORM)", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0xff0fffff, 'S': [0]};
  roarAB(state, {'AB': 33});
  assert.equal(state['ROAR'], 0x49c | 2); // T8-11 == 0, not stat 0
  state = {'ROAR': 0x49c, 'S': [1]};
  roarAB(state, {'AB': 33});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T': 0xff1fffff, 'S': [0]};
  roarAB(state, {'AB': 33});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test("ab 34 TZ*BS", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'T': 0x05000000, 'BS': [1, 0, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00800000, 'BS': [0, 1, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00001000, 'BS': [1, 0, 1, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00000004, 'BS': [1, 1, 1, 1]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  var state = {'ROAR': 0x49c, 'T': 0x00ffffff, 'BS': [1, 0, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xff00ffff, 'BS': [0, 1, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xffff00ff, 'BS': [0, 0, 1, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xffffff00, 'BS': [0, 0, 0, 1]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xffffffff, 'BS': [0, 0, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip( "ab 35 EDITPAT", function(assert) {
});

QUnit.test( "ab 36 PROB", function(assert) {
  var state = {'ROAR': 0x49c, 'AMWP': 0xe};
  roarAB(state, {'AB': 36});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'AMWP': 1};
  roarAB(state, {'AB': 36});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip( "ab 37 TIMUP", function(assert) {
});

// 38 unused

QUnit.test( "ab 39 (GZ/MB3)", function(assert) {
  var state = {'ROAR': 0x49c, 'G1': 0, 'G2': 0, 'MB': 1};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 2); // G == 0
  state = {'ROAR': 0x49c, 'G1': 1, 'G2': 1, 'MB': 3};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 2); // MB = 3
  state = {'ROAR': 0x49c, 'G1': 0, 'G2': 1, 'MB': 2};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 0); // G != 0 and MB != 3
  state = {'ROAR': 0x49c, 'G1': 2, 'G2': 0, 'MB': 0};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 0); // G != 0 and MB != 3
});


// 40 Unused

QUnit.skip("ab 41 LOG", function(assert) {
});

QUnit.skip("ab 42 STC=0", function(assert) {
});

QUnit.test("ab 43 G2<=LB", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'G2': 3, 'LB': 2};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 0};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  state = {'ROAR': 0x49c, 'G2': 3, 'LB': 3};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 0, 'LB': 1};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 3};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 0, 'LB': 0};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 44 unused

QUnit.test("ab 45 D(7)", function(assert) {
  // Negative case
  var state = {'ROAR': 0x49c, 'MS': {0x100: 0xfeffffff}, 'SAR': 0x100};
  roarAB(state, {'AB': 45});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive case
  state = {'ROAR': 0x49c, 'MS': {0x100: 0xffffffff}, 'SAR': 0x100};
  roarAB(state, {'AB': 45});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test("ab 46 SCPS", function(assert) {
  var state = {'ROAR': 0x49c, 'SCPS': 0};
  roarAB(state, {'AB': 46});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'SCPS': 1};
  roarAB(state, {'AB': 46});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test("ab 47 SCFS", function(assert) {
  var state = {'ROAR': 0x49c, 'SCFS': 0};
  roarAB(state, {'AB': 47});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'SCFS': 1};
  roarAB(state, {'AB': 47});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 48 unused?

// Note: sets A and B
QUnit.test("ab 49 W(67)→AB", function(assert) {
  var state = {'ROAR': 0x49c, 'W': 0};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 9};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 1); // B set

  state = {'ROAR': 0x49c, 'W': 6};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2); // A set

  state = {'ROAR': 0x49c, 'W': 7};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 3); // A,B set
});

// 50-53 unused?

QUnit.skip("ab 54 CANG", function(assert) {
});

QUnit.skip("ab 55 CHLOG", function(assert) {
});

// Sets A and B
QUnit.test("ab 56 I-FETCH", function(assert) {
  // off-bounds fetch (i.e. halfword, not word aligned)
  state = {'ROAR': 0x49c, 'IAR': 0x102, 'REFETCH': 0};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);

  // off-bounds refetch
  state = {'ROAR': 0x49c, 'IAR': 0x102, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 1);

  // on-bounds
  state = {'ROAR': 0x49c, 'IAR': 0x104, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2);

  // Invalid address
  state = {'ROAR': 0x49c, 'IAR': 0x105, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 3);
});

QUnit.test( "ab 57 IA(30)", function(assert) {
  var state = {'ROAR': 0x49c, 'IAR': 0x12340000};
  roarAB(state, {'AB': 57});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'IAR': 0x12340002};
  roarAB(state, {'AB': 57});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip("ab 58 EXT,CHIRPT", function(assert) {
});

// 59 not used?

QUnit.test("ab 60 PSS", function(assert) {
  var state = {'ROAR': 0x49c, 'PSS': 0};
  roarAB(state, {'AB': 60});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'PSS': 1};
  roarAB(state, {'AB': 60});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 61 not used?

// 62 not used

QUnit.test( "ab 63 RX.S0", function(assert) {
  var state = {'ROAR': 0x49c, 'M': 0x30000000, 'S':[0]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0); // Not M:01, not S0
  state = {'ROAR': 0x49c, 'M': 0x70000000, 'S':[0]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0); // M:01, not S0
  state = {'ROAR': 0x49c, 'M': 0x70000000, 'S':[1]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 2); // M:01, S0
  state = {'ROAR': 0x49c, 'M': 0x90000000, 'S':[1]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0); // not M:01, S0
});
QUnit.test("bb 0 0", function(assert) {
  var state = {'ROAR': 0x49c};
  roarBB(state, {'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test("bb 1 1", function(assert) {
  var state = {'ROAR': 0x49c};
  roarBB(state, {'BB': 1});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 2 (S0)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 2});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 2});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 3 (S1)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 3});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 1, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 3});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 4 (S2)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 4});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 1, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 4});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 5 (S3)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 5});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 1, 0, 0, 0, 0]};
  roarBB(state, {'BB': 5});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 6 (S4)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 6});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 1, 0, 0, 0]};
  roarBB(state, {'BB': 6});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 7 (S5)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 7});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 1, 0, 0]};
  roarBB(state, {'BB': 7});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 8 (S6)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 8});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 1, 0]};
  roarBB(state, {'BB': 8});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 9 (S7)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 9});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 1]};
  roarBB(state, {'BB': 9});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 10 RSGNS", function(assert) {
  var state = {'ROAR': 0x49c, 'RSGNS': 0};
  roarBB(state, {'BB': 10});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'RSGNS': 1};
  roarBB(state, {'BB': 10});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 11: HSCH

QUnit.test("bb 12 EXC", function(assert) {
  var state = {'ROAR': 0x49c, 'EXC': 0};
  roarBB(state, {'BB': 12});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'EXC': 1};
  roarBB(state, {'BB': 12});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 13 WR=0", function(assert) {
  var state = {'ROAR': 0x49c, 'WR': 1};
  roarBB(state, {'BB': 13});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'WR': 0};
  roarBB(state, {'BB': 13});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 14 unused

QUnit.test( "bb 15 (T13=0)", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0x00040000};
  roarBB(state, {'BB': 15});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T': 0x00030000};
  roarBB(state, {'BB': 15});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 16 T(0)", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0x80000000};
  roarBB(state, {'BB': 16});
  assert.equal(state['ROAR'], 0x49c | 1);
  state = {'ROAR': 0x49c, 'T': 0x7fffffff};
  roarBB(state, {'BB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test( "bb 17 T=0", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0};
  roarBB(state, {'BB': 17});
  assert.equal(state['ROAR'], 0x49c | 1);
  state = {'ROAR': 0x49c, 'T': 1};
  roarBB(state, {'BB': 17});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test("bb 18 TZ*BS", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'T': 0x05000000, 'BS': [1, 0, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00800000, 'BS': [0, 1, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00001000, 'BS': [1, 0, 1, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00000004, 'BS': [1, 1, 1, 1]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  var state = {'ROAR': 0x49c, 'T': 0x00ffffff, 'BS': [1, 0, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xff00ffff, 'BS': [0, 1, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xffff00ff, 'BS': [0, 0, 1, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xffffff00, 'BS': [0, 0, 0, 1]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xffffffff, 'BS': [0, 0, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 19 W=1", function(assert) {
  var state = {'ROAR': 0x49c, 'W': 0}
  roarBB(state, {'BB': 19});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 7}
  roarBB(state, {'BB': 19});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 1}
  roarBB(state, {'BB': 19});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 20 LB=0", function(assert) {
  var state = {'ROAR': 0x49c, 'LB': 1}
  roarBB(state, {'BB': 20});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'LB': 0}
  roarBB(state, {'BB': 20});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 21 LB=3", function(assert) {
  var state = {'ROAR': 0x49c, 'LB': 1}
  roarBB(state, {'BB': 21});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'LB': 0}
  roarBB(state, {'BB': 21});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'LB': 3}
  roarBB(state, {'BB': 21});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 22 MD=0", function(assert) {
  var state = {'ROAR': 0x49c, 'MD': 1}
  roarBB(state, {'BB': 22});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'MD': 0}
  roarBB(state, {'BB': 22});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 23 G2=0", function(assert) {
  var state = {'ROAR': 0x49c, 'G2': 1}
  roarBB(state, {'BB': 23});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2': 0}
  roarBB(state, {'BB': 23});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 24 G2<0", function(assert) {
  var state = {'ROAR': 0x49c, 'G2NEG': 0}
  roarBB(state, {'BB': 24});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2NEG': 1}
  roarBB(state, {'BB': 24});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 25 G2LBZ", function(assert) {
  var state = {'ROAR': 0x49c, 'G2': 1, 'LB': 1}
  roarBB(state, {'BB': 25});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2': 0, 'LB': 1}
  roarBB(state, {'BB': 25});
  assert.equal(state['ROAR'], 0x49c | 1);
  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 0}
  roarBB(state, {'BB': 25});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 26 I/O

QUnit.test( "bb 27 (MD/JI)", function(assert) {
  var state = {'ROAR': 0x49c, 'MD': 7, 'J': 14};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'MD': 14, 'J': 7};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'MD': 9, 'J': 14};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 1); // MD odd, > 8
  state = {'ROAR': 0x49c, 'MD': 7, 'J': 15};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 1); // J odd, > 8
});

QUnit.skip("bb 28 IVA", function(assert) {
  var state = {'ROAR': 0x49c, 'SAR': 0x102};
  roarBB(state, {'BB': 28});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'SAR': 0x101};
  roarBB(state, {'BB': 28});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 29 I/O

QUnit.test( "bb 30 (CAR)", function(assert) {
  var state = {'ROAR': 0x49c, 'CAR': 0};
  roarBB(state, {'BB': 30});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'CAR': 1};
  roarBB(state, {'BB': 30});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 31 (Z00)", function(assert) {
  var state = {'ROAR': 0x49c, 'T0': 0x7fffffff};
  roarBB(state, {'BB': 31});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T0': 0x80000000};
  roarBB(state, {'BB': 31});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "roar ZN 1 SMIF", function(assert) {
  var state = {};
  roar(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 1});
  assert.equal(state['ROAR'], 0x49c);
});

QUnit.test( "roar AB 56 I-FETCH", function(assert) {
  var state = {'ROAR': 0x49c, 'IAR': 0x12340000, 'REFETCH': 0}; // word aligned (on-bounds), no refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'IAR': 0x12340000, 'REFETCH': 1}; // word aligned (on-bounds), refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'IAR': 0x12340002, 'REFETCH': 0}; // halfword aligned (off-bounds), no refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'IAR': 0x12340002, 'REFETCH': 1}; // halfword aligned (off-bounds), refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 1);

  state = {'ROAR': 0x49c, 'IAR': 0x12340001, 'REFETCH': 0}; // alignment exception
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 3);
});

// ----------- SS tests

// SS 1, 2: unused

QUnit.test( "stat SS 3 D→CR*BS", function(assert) {
  var state = {'SAR': 0x30, 'MS': {}, 'BS': [1, 0, 0, 0]};
  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 0 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x71234567; // Leftmost bit of byte 0 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

  state = {'SAR': 0x30, 'MS': {}, 'BS': [0, 1, 0, 0]};
  state['MS'][0x30] = 0x81a34567; // Leftmost bit of byte 1 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 1 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

  state = {'SAR': 0x30, 'MS': {}, 'BS': [0, 0, 1, 0]};
  state['MS'][0x30] = 0x8123c567; // Leftmost bit of byte 2 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 2 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

  state = {'SAR': 0x30, 'MS': {}, 'BS': [0, 0, 0, 1]};
  state['MS'][0x30] = 0x812345f7; // Leftmost bit of byte 3 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 3 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

});

QUnit.skip( "stat SS 4 E→SCANCTL", function(assert) {
});

QUnit.test( "stat SS 5 L,RSGNS", function(assert) {
  for (var i = 0; i < 16; i++) {
    var state = {'U': 0x40 | i}; // 4 is arbitrary
    if (i < 10) {
      assert.throws(function() { stat(state, {'SS': 5})});
    } else if (i == 0xb || i == 0xd) {
      stat(state, {'SS': 5});
      assert.equal(state['LSGNS'], 1, 'LSGNS ' + i, i); // Negative
      assert.equal(state['RSGNS'], 0, 'RSGNS ' + i, i); // Cleared
    } else {
      stat(state, {'SS': 5});
      assert.equal(state['LSGNS'], 0, 'LSGNS ' + i, i); // Positive
      assert.equal(state['RSGNS'], undefined, 'RSGNS ' + i, i); // Unchanged
    }
  }
});

QUnit.skip( "stat SS 6 IVD/RSGNS", function(assert) {
});

QUnit.skip( "stat SS 7 EDITSGN", function(assert) {
});

QUnit.test( "stat8 E→S03", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 3, 'SS': 8});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat9 S03ΩE,1→LSGN", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 3, 'SS': 9});
  assert.deepEqual(state['S'], [1, 0, 1, 1, 0, 0, 0, 1]);
  assert.equal(state['LSGNS'], 1);
});

QUnit.test( "stat10 S03ΩE", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 3, 'SS': 10});
  assert.deepEqual(state['S'], [1, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat11 S03ΩE,0→BS", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1], 'BS': []};
  stat(state, {'CE': 3, 'SS': 11});
  assert.deepEqual(state['S'], [1, 0, 1, 1, 0, 0, 0, 1]);
  assert.deepEqual(state['BS'], [0, 0, 0, 0]);
});

// Unclear exactly which half of the word X0 and B0 come from
QUnit.test( "stat12: X0,B0,1SYL", function(assert) {
  // X=0, B=0
  var state = {'T': 0x02305678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 1); // X=0, i.e. T(12-15)
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=0
  state = {'T': 0x02340678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15)
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=5
  state = {'T': 0x12345678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15)
  assert.equal(state['S'][1], 0); // B!=0, i.e. T(0-3)

  // X=0, B=5
  state = {'T': 0x12305678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 1); // X=0, i.e. T(12-15)
  assert.equal(state['S'][1], 0); // B=0, i.e. T(0-3)

  // Now test 1SYL
  for (var i = 0; i < 16; i++) {
    state = {'T': i << 28, 'S': []};
    stat(state, {'SS': 12});
    if (i <= 3) {
      assert.equal(state['1SYL'], 1);
    } else {
      assert.equal(state['1SYL'], 0);
    }
  }
});

QUnit.skip( "stat SS 13: FPZERO", function(assert) {
});

QUnit.skip( "stat SS 14: FPZERO,E→FN", function(assert) {
});

QUnit.test( "stat15: B0,1SYL", function(assert) {
  // X=0, B=0
  var state = {'T': 0x02305678, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], 0); // X=0, i.e. T(12-15)
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=0
  var state = {'T': 0x02340678, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15)
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=5
  var state = {'T': 0x12345678, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], 0, 'X=4,B=5:S0'); // X!=0, i.e. T(12-15)
  assert.equal(state['S'][1], 0, 'X=4,B=5:S1'); // B!=0, i.e. T(0-3)

  // X=0, B=5
  var state = {'T': 0x12305678, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], 0); // X=0, i.e. T(12-15)
  assert.equal(state['S'][1], 0, 'X=0,B=5:S1'); // B=0, i.e. T(0-3)

  // Now test 1SYL
  for (var i = 0; i < 16; i++) {
    state = {'T': i << 28, 'S': []};
    stat(state, {'SS': 15});
    if (i <= 3) {
      assert.equal(state['1SYL'], 1);
    } else {
      assert.equal(state['1SYL'], 0);
    }
  }
});

QUnit.test( "stat16: S03.¬E", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 6, 'SS': 16});
  assert.deepEqual(state['S'], [0, 0, 0, 1, 0, 0, 0, 1]);

  state = {'S': [1, 1, 1, 1, 1, 1, 1, 1]};
  stat(state, {'CE': 15, 'SS': 16});
  assert.deepEqual(state['S'], [0, 0, 0, 0, 1, 1, 1, 1]);
});

QUnit.skip( "stat SS 17: (T=0)→S3", function(assert) {
});

QUnit.test( "stat18: E→BS,T30→S3", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1], 'T': 0, 'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 6, 'SS': 18});
  assert.deepEqual(state['BS'], [0, 1, 1, 0]);
  assert.deepEqual(state['S'], [0, 0, 1, 0, 0, 0, 0, 1]);

  state = {'S': [0, 0, 1, 1, 0, 0, 0, 1], 'T': 2, 'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 15, 'SS': 18});
  assert.deepEqual(state['BS'], [1, 1, 1, 1]);
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat SS 19: E→BS", function(assert) {
  var state = {'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 15, 'SS': 19});
  assert.deepEqual(state['BS'], [1, 1, 1, 1]);

  var state = {'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 3, 'SS': 19});
  assert.deepEqual(state['BS'], [0, 0, 1, 1]);
});

QUnit.test( "stat20: 1→BS*MB", function(assert) {
  var state = {'BS': [0, 0, 0, 0,], 'MB': 2};
  stat(state, {'SS': 20});
  assert.equal(state['BS'][2], 1);
});

// SS 21: unused

// SS 22: unused

QUnit.skip( "stat SS 23: MANUAL→STOP", function(assert) {
});

QUnit.test( "stat24: E→S47", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 6, 'SS': 24});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 1, 1, 0]);
});

QUnit.test( "stat25: S47ΩE", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 6, 'SS': 25});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 1, 1, 1]);
});

QUnit.test( "stat26: S47.¬E", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 1, 1]};
  stat(state, {'CE': 6, 'SS': 26});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.skip( "stat SS 27: S47,ED*FP", function(assert) {
});

QUnit.skip( "stat SS 28: OPPANEL→S47", function(assert) {
});

QUnit.test( "stat29: CAR,(T≠0)→CR", function(assert) {
  var state = {'CAR': 0, 'T': 0};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 0);
  state = {'CAR': 0, 'T': 0x10000};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 1);
  state = {'CAR': 1, 'T': 0};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 2);
  state = {'CAR': 1, 'T': 0xffffffff};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 3);
});

QUnit.test( "stat30: KEY→F", function(assert) {
  var state = {'SAR': 0x12345670, 'KEYS': {}};
  state['KEYS'][0x12345670 & 0x00fff100] = 4;
  stat(state, {'SS': 30});
  assert.equal(state['F'], 4);
});

QUnit.test( "stat31: F→KEY", function(assert) {
  var state = {'F': 4, 'SAR': 0x12345670, 'KEYS': {}};
  stat(state, {'SS': 31});
  assert.equal(state['KEYS'][0x12345670 & 0x00fff100], 4);
});

QUnit.test( "stat32: 1→LSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 32});
  assert.deepEqual(state['LSGNS'], 1);
});

QUnit.test( "stat33: 0→LSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 33});
  assert.deepEqual(state['LSGNS'], 0);
});

QUnit.test( "stat34: 1→RSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 34});
  assert.deepEqual(state['RSGNS'], 1);
});

QUnit.test( "stat35: 0→RSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 35});
  assert.deepEqual(state['RSGNS'], 0);
});

QUnit.test( "stat36: L(0)→LSGNS", function(assert) {
  var state = {'L': 0x76543210};
  stat(state, {'SS': 36});
  assert.deepEqual(state['LSGNS'], 0);
  state = {'L': 0x86543210};
  stat(state, {'SS': 36});
  assert.deepEqual(state['LSGNS'], 1);
});

QUnit.test( "stat37: R(0)→RSGNS", function(assert) {
  var state = {'R': 0x76543210};
  stat(state, {'SS': 37});
  assert.deepEqual(state['RSGNS'], 0);
  state = {'R': 0x86543210};
  stat(state, {'SS': 37});
  assert.deepEqual(state['RSGNS'], 1);
});

QUnit.test( "stat38: E(13)→WFN", function(assert) {
  var state = {};
  stat(state, {'SS': 38, 'CE': 0xe});
  assert.equal(state['WFN'], 6);
});

QUnit.test( "stat SS 39: E(23)→FN", function(assert) {
  var state = {};
  stat(state, {'SS': 39, 'CE': 0xe});
  assert.equal(state['FN'], 2);
});

QUnit.test( "stat SS 40: E(23)→CR", function(assert) {
  var state = {};
  stat(state, {'SS': 40, 'CE': 0xe});
  assert.equal(state['CR'], 2);
});

QUnit.test( "stat41: SETCRALG", function(assert) {
  var state = {'T': 0};
  stat(state, {'SS': 41, 'CE': 0xe});
  assert.equal(state['CR'], 0); // Zero

  state = {'T': 0x80000001};
  stat(state, {'SS': 41, 'CE': 0xe});
  assert.equal(state['CR'], 1); // Negative

  state = {'T': 0x7fffffff};
  stat(state, {'SS': 41, 'CE': 0xe});
  assert.equal(state['CR'], 2); // Positive
});

QUnit.test( "stat SS 42: SETCRLOG", function(assert) {
  var state = {'T': 0x00110022, 'BS': [1, 0, 1, 0], 'c0': 1};
  stat(state, {'SS': 42});
  assert.equal(state['CR'], 0); // Zero

  state = {'T': 0x00110022, 'BS': [1, 0, 1, 1], 'c0': 0};
  stat(state, {'SS': 42});
  assert.equal(state['CR'], 1); // First lower

  state = {'T': 0x00110022, 'BS': [0, 0, 0, 1], 'c0': 1};
  stat(state, {'SS': 42});
  assert.equal(state['CR'], 2); // First higher
});

QUnit.skip( "stat SS 43: ¬S4,S4→CR", function(assert) {
});

QUnit.skip( "stat SS 44: S4,¬S4→CR", function(assert) {
});

QUnit.skip( "stat SS 45: 1→REFETCH", function(assert) {
});

QUnit.skip( "stat SS 46: SYNC→OPPANEL", function(assert) {
});

QUnit.skip( "stat SS 47: SCAN*E,10", function(assert) {
});

// SS 48, 49: I/O

QUnit.skip( "stat SS 50: E(0)→IBFULL", function(assert) {
});

// SS 51: unused

QUnit.skip( "stat SS 52: E→CH", function(assert) {
});

// SS 53: unused

QUnit.skip( "stat SS 54: 1→TIMERIRPT", function(assert) {
});

// T to AMWP bits
QUnit.test( "stat55  T→PSW,IPL→T", function(assert) {
  var state = {'T': 0x12345678};
  stat(state, {'SS': 55});
  assert.equal(state['AMWP'], 4);
  assert.equal(state['T'], 0x0c000000); // Hardwored card reader IPl
});

// T to AMWP bits
QUnit.test( "stat56 T→PSW", function(assert) {
  var state = {'T': 0x123f5678};
  stat(state, {'SS': 56});
  assert.equal(state['AMWP'], 0xf);
});

QUnit.test( "stat57", function(assert) {
  // 57: SCAN*E00
  var state = {};
  stat(state, {'SS': 57, 'CE': 0x3});
  assert.equal(state['SCANCTRL'], 0x0c);
});

QUnit.skip( "stat SS 58: 1→IOMODE", function(assert) {
});

// SS 59-63: I/O

// ----- AL tests

// test shifter

QUnit.test("sr1", function(assert) {
  // Start with right field empty
  assert.deepEqual(sr1(0, 0x12345678, 0), [0x091a2b3c, 0]);
  assert.deepEqual(sr1(0, 0x12345679, 0), [0x091a2b3c, 8]);
  assert.deepEqual(sr1(1, 0x12345678, 0), [0x891a2b3c, 0]);
  assert.deepEqual(sr1(1, 0x12345679, 0), [0x891a2b3c, 8]);
  // Now with content in right field
  assert.deepEqual(sr1(0, 0x82345678, 3), [0x411a2b3c, 1]);
  assert.deepEqual(sr1(0, 0x82345679, 5), [0x411a2b3c, 0xa]);
  assert.deepEqual(sr1(1, 0x82345678, 8), [0xc11a2b3c, 4]);
  assert.deepEqual(sr1(1, 0x82345679, 0xf), [0xc11a2b3c, 0xf]);
});

QUnit.test("sl1", function(assert) {
  // Start with dest (left) field empty
  assert.deepEqual(sl1(0, 0x12345678, 0), [0x2468acf0, 0]);
  assert.deepEqual(sl1(0, 0x92345678, 0), [0x2468acf0, 1]);
  assert.deepEqual(sl1(8, 0x12345678, 0), [0x2468acf1, 0]);
  assert.deepEqual(sl1(8, 0x92345678, 0), [0x2468acf1, 1]);
  // Now with contents in dest field
  assert.deepEqual(sl1(0, 0x12345678, 0xf), [0x2468acf0, 0xe]);
  assert.deepEqual(sl1(0, 0x92345678, 0x8), [0x2468acf0, 1]);
  assert.deepEqual(sl1(8, 0x12345678, 0x5), [0x2468acf1, 0xa]);
  assert.deepEqual(sl1(8, 0x92345678, 0x2), [0x2468acf1, 5]);
});

QUnit.test("sr4", function(assert) {
  assert.deepEqual(sr4(0, 0x12345678), [0x01234567, 8]);
  assert.deepEqual(sr4(0xf, 0x12345673), [0xf1234567, 3]);
});

QUnit.test("sl4", function(assert) {
  assert.deepEqual(sl4(0x1, 0x12345678), [0x23456781, 1]);
  assert.deepEqual(sl4(0xf, 0x12345678), [0x2345678f, 1]);
  assert.deepEqual(sl4(0, 0xff345678), [0xf3456780, 0xf]);
});

QUnit.skip( "al1 Q→SR1→F", function(assert) {
  var state = {'T': 0x12345678, 'Q': 1, 'F': 5};
  adderDG(state, {'AL': 1, 'DG': 0});
  assert.equal(state['T0'], 0x80000000 | (0x12345678 >> 1));
  assert.equal(state['F'], 0xa);
  assert.equal(state['Q'], 0);
});

QUnit.skip( "al 2 L0,¬S4→", function(assert) {
});

QUnit.test( "al3 +SGN→", function(assert) {
  var state = {'T0': 0x12345678};
  adderAL(state, {'AL': 3});
  assert.equal(state['T'], 0x12345678);
});

QUnit.test( "al4 -SGN→", function(assert) {
  var state = {'T0': 0x12345678};
  adderAL(state, {'AL': 4});
  assert.equal(state['T'], 0x92345678);
});

QUnit.test( "al4 -SGN→", function(assert) {
  var state = {'T0': 0x92345678};
  adderAL(state, {'AL': 4});
  assert.equal(state['T'], 0x92345678);
});

QUnit.skip( "al5 L0,S4→", function(assert) {
});

QUnit.test( "al6 IA→H", function(assert) {
  var state = {'IAR': 0x12345678};
  adderAL(state, {'AL': 6});
  assert.equal(state['H'], 0x12345678);
});

QUnit.test( "al7 Q→SL→-F", function(assert) {
  var state = {'T0': 0x12345678, 'Q': 0, 'F': 0xf};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x2468acf0);
  assert.equal(state['F'], 0xf); // 0 inverted, shifted in

  state = {'T0': 0x92345678, 'Q': 0, 'F': 0xf};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x2468acf0);
  assert.equal(state['F'], 0xe);

  state = {'T0': 0x12345678, 'Q': 1, 'F': 0xf};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x2468acf1);
  assert.equal(state['F'], 0xf);
});

QUnit.test( "al8 Q→SL1→F", function(assert) {
  var state = {'Q': 0, 'T0': 0x72345678, 'F': 0xc}; // Shift 0 in, 0 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], (0x72345678 << 1) >>> 0);
  assert.equal(state['F'], 0x8); // 1100 -> 1000

  state = {'Q': 1, 'T0': 0x72345678, 'F': 0xc}; // Shift 1 in, 0 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], ((0x72345678 << 1) | 1) >>> 0);
  assert.equal(state['F'], 0x8);

  state = {'Q': 0, 'T0': 0x92345678, 'F': 0xc}; // Shift 0 in, 1 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], (0x92345678 << 1) >>> 0);
  assert.equal(state['F'], 0x9);

  state = {'Q': 1, 'T0': 0x92345678, 'F': 0xc}; // Shift 1 in, 1 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], ((0x92345678 << 1) | 1) >>> 0);
  assert.equal(state['F'], 0x9);
});

// Overflow bits from T spill into F, which is shifted into T.
QUnit.test( "al9 F→SL1→F", function(assert) {
  var state = {'T0': 0x92345678, 'F': 0xc};
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 1) | 1) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x9);
  state['T0'] = state['T'];
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 2) | 3) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x2);
  state['T0'] = state['T'];
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 3) | 6) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x4);
  state['T0'] = state['T'];
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 4) | 0xc) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x9);
});

QUnit.test( "al10 SL1→Q", function(assert) {
  var state = {'T0': 0x92345678};
  adderAL(state, {'AL': 10});
  assert.equal(state['T'], (0x92345678 << 1) & 0xffffffff, state['T'].toString(16));
  assert.equal(state['Q'], 0x1);
});


QUnit.test( "al11 Q→SL1", function(assert) {
  var state = {'T0': 0x92345678, 'Q': 0};
  adderAL(state, {'AL': 11});
  assert.equal(state['T'], 0x2468acf0);

  state = {'T0': 0x92345678, 'Q': 1};
  adderAL(state, {'AL': 11});
  assert.equal(state['T'], 0x2468acf1);
});

QUnit.test( "al12 SR1→F", function(assert) {
  var state = {'T0': 0x12345679, 'F': 3};
  adderAL(state, {'AL': 12});
  assert.equal(state['T'], 0x12345679 >> 1);
  assert.equal(state['F'], 9);
});

QUnit.test( "al13 SR1→Q", function(assert) {
  var state = {'T0': 0x12345679};
  adderAL(state, {'AL': 13});
  assert.equal(state['T'], 0x12345679 >> 1);
  assert.equal(state['Q'], 0x1);
});

QUnit.test( "al14 Q→SR1→Q", function(assert) {
  var state = {'T0': 0x92345679, 'Q': 0};
  adderAL(state, {'AL': 14});
  assert.equal(state['T'], 0x491a2b3c);
  assert.equal(state['Q'], 0x1);

  var state = {'T0': 0x92345678, 'Q': 1};
  adderAL(state, {'AL': 14});
  assert.equal(state['T'], 0xc91a2b3c);
  assert.equal(state['Q'], 0x0);
});

QUnit.test( "al15 F→SL1→Q", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x9, 'Q': 0};
  adderAL(state, {'AL': 15});
  assert.equal(state['F'], 9); // Assuming unchanged
  assert.equal(state['T'], 0x2468acf1);
  assert.equal(state['Q'], 0x0);

  state = {'T0': 0x92345678, 'F': 0x7, 'Q': 0};
  adderAL(state, {'AL': 15});
  assert.equal(state['F'], 0x7); // Assuming unchanged
  assert.equal(state['T'], 0x2468acf0);
  assert.equal(state['Q'], 0x1);
});

QUnit.test( "al16 SL4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 16});
  assert.equal(state['T'], 0x23456780);
  assert.equal(state['F'], 0x1);
});

QUnit.test( "al17 F→SL4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 17});
  assert.equal(state['T'], 0x23456783);
  assert.equal(state['F'], 0x1);
});

QUnit.test( "al18 FPSL4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 18});
  assert.equal(state['T'], 0x23456780);
  assert.equal(state['F'], 0x3);
});

QUnit.test( "al19 F→FPSL4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 19});
  assert.equal(state['T'], 0x23456783);
  assert.equal(state['F'], 0x3);
});

QUnit.test( "al20 SR4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 20});
  assert.equal(state['T'], 0x01234567);
  assert.equal(state['F'], 0x8);
});

QUnit.test( "al21", function(assert) {
  // F->SR4->F: guess as to function
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 21});
  assert.equal(state['T'], 0x31234567);
  assert.equal(state['F'], 0x8);
});

QUnit.skip( "al22 FPSR4→F", function(assert) {
});

QUnit.test( "al23 1→FPSR4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 23});
  assert.equal(state['T'], 0x11234567);
  assert.equal(state['F'], 0x8);
});

QUnit.skip( "al24 SR4→H", function(assert) {
});

QUnit.test( "al25 F→SR4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 25});
  assert.equal(state['T'], 0x31234567);
  assert.equal(state['F'], 0x3);
});

QUnit.test( "al26 E→FPSL4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 26, 'CE': 0x4});
  assert.equal(state['T'], 0x23456784);
  assert.equal(state['F'], 0x3);
});

QUnit.test( "al27 F→SR1→Q", function(assert) {
  var state = {'T0': 0x92345678, 'F': 0};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0x491a2b3c);
  assert.equal(state['Q'], 0);

  state = {'T0': 0x92345679, 'F': 0xe};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0x491a2b3c);
  assert.equal(state['Q'], 1);

  var state = {'T0': 0x92345678, 'F': 3};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0xc91a2b3c);
  assert.equal(state['Q'], 0);
});

QUnit.skip( "al28 DKEY→", function(assert) {
});

// al 29 is I/O

QUnit.test( "al30 D→", function(assert) {
  var state = {'SAR': 0x30};
  state['MS'] = [];
  state['MS'][0x30] = 0x12345678;
  adderAL(state, {'AL': 30, 'CE': 0x4});
  assert.equal(state['T'], 0x12345678);
});

QUnit.skip( "al31 AKEY→", function(assert) {
});

</script>
</body>
</html>
