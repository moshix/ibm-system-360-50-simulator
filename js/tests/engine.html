<!DOCTYPE html>
<html>
<!--
This file holds unittests for engine.js, using qunit
-->
<head>
  <meta charset="utf-8">
  <title>Engine unittests</title>
  <link rel="stylesheet" href="qunit-2.9.2.css" >
  <script src="data.js"></script>
  <script src="../out/utils.js"></script>
  <script src="../out/decode.js"></script>
  <script src="../out/engine.js"></script>
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>

  <script src="qunit-2.9.2.js"></script>
  <script>

// Format d as 3 hex bytes
function fmt3(d) {
  return d.toString(16).padStart(6, '0');
}

// Format d as 4 hex bytes
function fmt4(d) {
  return d.toString(16).padStart(8, '0');
}

function alert(msg) {
  QUnit.assert.equal(0, 1, msg);
}

// Helper to call all the adder routines
function adder(state, entry) {
  adderLX(state, entry);
    adderRY(state, entry);
    adderDG(state, entry);
    adderT(state, entry);
}

// QUnit.config.collapse = false; // Expand all failures

QUnit.test( "adder", function(assert) {
  var state = {'L': 0x12345678, 'R': 0x23456789};
  var entry = {'LX': 1 /* L */, 'RY': 1 /* R */, 'TC': 1 /* add */, 'AD': 1 /* default op */, 'AL': 0 /* shift */, 'DG': 0 /* default */};
  adder(state, entry);
  assert.equal(state['T0'], 0x12345678 + 0x23456789);
});

QUnit.test( "adder2", function(assert) {
  var state = {'L': 0x1234, 'H': 0x1233};
  var entry = {'LX': 1 /* L */, 'RY': 4 /* H */, 'TC': 0 /* sub */, 'AD': 1 /* default op */, 'AL': 0 /* shift */, 'DG': 0 /* default */};
  adder(state, entry);
  assert.equal(state['T0'], 0xfffffffe); // H - L, 1's complement
});

QUnit.test( "adder3", function(assert) {
  var state = {'M': 0x12345678};
  var entry = {'CE': 4, 'LX': 3 /* E */, 'RY': 3 /* M23 */, 'TC': 1 /* add */, 'AD': 1 /* default op */, 'AL': 0 /* shift */, 'DG': 0 /* default */};
  adder(state, entry);
  assert.equal(state['T0'], (4 << 1) + 0x5678);
});

QUnit.test( "adder lx 0 0", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 0});
  assert.equal(state['XG'], 0);
});

QUnit.test( "adder lx 1 L", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 1});
  assert.equal(state['XG'], 0x12345678);
});

QUnit.test( "adder lx 2 SGN", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 2});
  assert.equal(state['XG'], 0x80000000);
});

QUnit.test( "adder lx 3 E", function(assert) { // E shifted left one
  var state = {};
  adderLX(state, {'LX': 3, 'CE': 0x9});
  assert.equal(state['XG'], 0x12);
});

QUnit.test( "adder lx 4 LRL", function(assert) {
  var state = {'L': 0x12345678};
  adderLX(state, {'LX': 4 /* LRL */});
  assert.equal(state['XG'], 0x56780000);
});

// Gate L reg to XG. OR ones into XG bits 30-31 and Y input bits 30-31.
QUnit.test( "adder lx 5 LWA", function(assert) {
  var state = {'L': 0x12345678}
  adderLX(state, {'LX': 5});
  assert.equal(state['XG'], 0x1234567b);
  adderRY(state, {'LX': 5, 'RY': 0});
  assert.equal(state['Y'], 3);
});

QUnit.test( "adder lx 6 4", function(assert) {
  var state = {};
  adderLX(state, {'LX': 6});
  assert.equal(state['XG'], 4);
});

QUnit.test( "adder lx 7 64C", function(assert) {
  var state = {};
  adderLX(state, {'LX': 7});
  assert.equal(state['XG'], 0xc0000000); // Complement of 64
});

// No operation
QUnit.test( "adder RY 0 0", function(assert) {
  var state = {};
  adderRY(state, {'RY': 0});
  assert.equal(state['Y'], 0);
});

// Gate R register to Y
QUnit.test( "adder RY 1 R", function(assert) {
  var state = {'R': 0x12345678};
  adderRY(state, {'RY': 1});
  assert.equal(state['Y'], 0x12345678);
});

// Gate M register to Y
QUnit.test( "adder RY 2 M", function(assert) {
  var state = {'M': 0x12345678};
  adderRY(state, {'RY': 2});
  assert.equal(state['Y'], 0x12345678);
});

// Get M reg bits 16-31 to Y bits 16-31. Gate zeros to bits 0-15.
QUnit.test( "adder RY 3 M23", function(assert) {
  var state = {'M': 0x12345678};
  adderRY(state, {'RY': 3});
  assert.equal(state['Y'], 0x5678);
});

// Gate H register to Y.
QUnit.test( "adder RY 4 H", function(assert) {
  var state = {'H': 0x12345678};
  adderRY(state, {'RY': 4});
  assert.equal(state['Y'], 0x12345678);
});

// OR the four SDR parity bits into the four emit field bits.
QUnit.skip( "adder RY 5 SEMT", function(assert) {
  var state = {'SDR': 0x00ff0110};
  assert.deepEqual(state['E'], [1, 1, 0, 0]);
});

  // Based on 02D3
QUnit.test( "adder-dec", function(assert) {
  var state = {'R': 0};
  adder(state, {'RY': 1, 'TC': 0, 'LX': 0, 'TR': 1, 'AD': 1, 'AL': 0, 'DG': 0});
  assert.equal(state['T0'], 0xffffffff);
});

  // The default adder inputs when nothing happens
QUnit.test( "adder-default", function(assert) {
  var state = {};
  adder(state, {'RY': 0, 'TC': 1, 'LX': 0, 'TR': 7, 'AD': 1, 'AL': 0, 'DG': 0});
  assert.equal(state['T0'], 0);
});

// Add. No carry saved. If F reg equals zero, insert carry into position 31.
QUnit.test( "adder ad 2 BCF0", function(assert) {
  let state = {'XG': 0xffffffff, 'Y': 0x00000000, 'CIN': 0, 'F': 0};
  adderT(state, {'AD': 2 /* BCF0 */});
  assert.equal(state['T0'], 0x00000000, 'sum');

  state = {'XG': 0xffffffff, 'Y': 0x00000000, 'CIN': 0, 'F': 1};
  adderT(state, {'AD': 2 /* BCF0 */});
  assert.equal(state['T0'], 0xffffffff, 'sum2');
});

QUnit.test( "adder-carry0 ad 4 BC0", function(assert) {
  var state = {'XG': 0xffffffff, 'Y': 0x00000001, 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0);

  state = {'R': 0xfffffffe, 'L': 0x00000001, 'CIN': 0};
  adder(state, {'RY': 1 /* R */, 'TC': 1, 'LX': 1 /* L */, 'TR': 7, 'AD': 4 /* BC0 */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xffffffff);

  state = {'R': 0xffffffff, 'L': 0x10000000, 'CIN': 0};
  adder(state, {'RY': 1 /* R */, 'TC': 1, 'LX': 1 /* L */, 'TR': 7, 'AD': 4 /* BC0 */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x0fffffff);
});

// 32-bit not
function not(x) {
  return (~x) >>> 0;
}

QUnit.test( "adder-carry0 sub ad 4 BC0", function(assert) {
  // Basic subtraction is 1's complement
  var state = {'Y': 0x00000000, 'XG': not(0x00000001), 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe); // R - L, subtraction is one short without carry-in

  state = {'Y': 0xffffffff, 'XG': not(0x00000000), 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xfffffffe); // subtraction is one short

  state = {'Y': 0xefffffff, 'XG': not(0x10000000), 'CIN': 0};
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xdffffffe); // subtraction is one short
});

QUnit.test( "adder-carry0 sub +hot1 ad 4 BC0", function(assert) {
  // Add hot1 to get 2's complement subtraction
  var state = {'Y': 0x00000000, 'XG': not(0x00000001)};
  adderDG(state, {'DG': 2 /* HOT1 */});
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 0); // Carry = not borrow
  assert.equal(state['T0'], 0xffffffff);

  state = {'Y': 0xffffffff, 'XG': not(0x00000000)};
  adderDG(state, {'DG': 2 /* HOT1 */});
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xffffffff);

  state = {'Y': 0xefffffff, 'XG': not(0x10000000)};
  adderDG(state, {'DG': 2 /* HOT1 */});
  adderT(state, {'AD': 4 /* BC0 */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xdfffffff);
});

QUnit.test( "adder-overflow ad 5 BC⩝C", function(assert) {
  // Normal positive addition
  var state = {'XG': 0x12345678, 'Y': 0x12345678, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x12345678 + 0x12345678);

  // positive + positive yields negative overflow
  // Normal positive addition
  var state = {'XG': 0x12345678, 'Y': 0x12345678, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x12345678 + 0x12345678);

  // positive + positive yields negative overflow
  state = {'XG': 0x70000000, 'Y': 0x70000000, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0xe0000000);

  // positive + negative okay
  state = {'XG': 0x70000000, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x6fffffff);

  // negative + negative okay
  state = {'XG': 0xffffffff, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe);


  state = {'XG': 0x80000000, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x7fffffff);

  // -1 + 0: no overflow
  state = {'XG': 0x00000000, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xffffffff);

  // -1 + 0 + carry: no overflow
  state = {'XG': 0x00000000, 'Y': 0xffffffff, 'CIN': 1};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0);

  // -1 + 0 + carry: no overflow
  state = {'Y': 0x00000000, 'XG': 0xffffffff, 'CIN': 1};
  adderT(state, {'AD': 5 /* BC⩝C */});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0);
});

QUnit.test( "adder-subtract-overflow ad 5 BC⩝C", function(assert) {
  // Normal positive subtraction: note that L is subtracted from R
  var state = {'R': 0x12345678, 'L': 0x12345677};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0); // 1's complement subtraction

  // positive - positive yields negative
  state = {'R': 0x70000000, 'L': 0x70000001};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe);

  // positive - negative okay
  state = {'R': 0x12345678, 'L': 0xffffffff};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0x12345678);

  // positive - negative overflow
  state = {'R': 0x7fffffff, 'L': 0xfffffffe};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x80000000);

  // negative - negative okay
  state = {'R': 0xfffffffe, 'L': 0xffffffff};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 0);
  assert.equal(state['T0'], 0xfffffffe);

  // negative - positive overflow
  state = {'R': 0x80000000, 'L': 0x00000001};
  adder(state, {'RY': 1 /* R */, 'TC': 0, 'LX': 1 /* L */, 'TR': 7, 'AD': 5 /* BC⩝C */ , 'AL': 0, 'DG': 0});
  assert.equal(state['CAR'], 1);
  assert.equal(state['T0'], 0x7ffffffe);
});

// Block carry from 8, save carry from 1. Used for floating point exponent math.
// Add. Set carry stat to carry out of position 1. Block carry from position 8 to position 7.

QUnit.test( "adder ad 6 BC1B", function(assert) {
  // Make sure carry 8 is blocked
  var state = {'XG': 0x12345678, 'AUX': 0, 'Y': 0x00f00000, 'CIN': 0};
  adderT(state, {'AD': 6});
  assert.equal(state['T0'], 0x12245678, 'sum');
  assert.equal(state['CAR'], 0, 'carry');

  // Another test, generating carry
  var state = {'XG': 0x12345678, 'AUX': 0, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 6});
  assert.equal(state['T0'], 0x11345677, 'sum2');
  assert.equal(state['CAR'], 1, 'carry2'); // Carry

  // Test carry-out from bit 0
  var state = {'XG': 0xffffffff, 'AUX': 0, 'Y': 0x80000000, 'CIN': 0};
  adderT(state, {'AD': 6});
  assert.equal(state['T0'], 0x7fffffff, 'sum3');
  assert.equal(state['CAR'], 0, 'carry3');

  // Test carry-out from bit 1
  var state = {'XG': 0xffffffff, 'AUX': 0, 'Y': 0x40000000, 'CIN': 0};
  adderT(state, {'AD': 6});
  assert.equal(state['T0'], 0x3fffffff, 'sum4');
  assert.equal(state['CAR'], 1, 'carry4');

  // Make sure blocked carry doesn't trigger a carry from bit 1.
  var state = {'XG': 0xffffffff, 'AUX': 0, 'Y': 0x00000000, 'CIN': 1};
  adderT(state, {'AD': 6});
  assert.equal(state['T0'], 0xff000000, 'sum5');
  assert.equal(state['CAR'], 0, 'carry 5');

  // Test hot carry AL23
  var state = {'XG': 0xffffffff, 'AUX': 0, 'Y': 0x00000000, 'CIN': 1};
  adderT(state, {'AD': 6, 'AL': 23});
  assert.equal(state['T0'], 0x00000000, 'sum 6');
  assert.equal(state['CAR'], 1, 'carry 6');
});

// Carry out of pos 8
QUnit.test( "adderT ad 7 BC8", function(assert) {
  var state = {'XG': 0x00000000, 'AUX': 0, 'Y': 0xffffffff, 'CIN': 0};
  adderT(state, {'AD': 7});
  assert.equal(state['CAR'], 0);

  state = {'XG': 0x00800000, 'AUX': 0, 'Y': 0x00800000, 'CIN': 0};
  adderT(state, {'AD': 7});
  assert.equal(state['CAR'], 1);

  state = {'XG': 0x00ffffff, 'AUX': 0, 'Y': 0x00000001, 'CIN': 0};
  adderT(state, {'AD': 7});
  assert.equal(state['CAR'], 1);
});

// Decimal halve (low order). Bit 2 of each digit of the sum is tested. If the bit is one,
// the next digit position to the right in the L reg is set to 0110. If the bit is zero, the
// digit in L reg is set to 0000. The leftmost digit in the L reg is set in the same way from the auxiliary trigger.
QUnit.test( "adderT ad 8 DHL", function(assert) {
  var state = {'XG': 0xdddddddd, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['pending']['L'], 0, 'No correction');

  state = {'XG': 0xdddddd2d, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['pending']['L'], 0x6, 'Low-order');

  state = {'XG': 0x22222222, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['pending']['L'], 0x06666666, 'All correction');

  var state = {'XG': 0xdddddddd, 'AUX': 1, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['pending']['L'], 0x60000000, 'Aux correction');

  state = {'XG': 0xdddddd22, 'AUX': 1, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['pending']['L'], 0x60000006, 'Low-order, aux');

  state = {'XG': 0x22222220, 'AUX': 1, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 8});
  assert.equal(state['pending']['L'], 0x66666666, 'All correction, AUX');
});

// Decimal add. Set stat 1 to carry out of position 0. Insert
// previous value of stat 1 as carry into position 31. Test
// carry out of each digit position. If carry, set corresponding
// digit position in L reg to 0000. If no carry, set digit in L reg to 0110.
QUnit.test( "adder ad 9 DC0", function(assert) {
  var state = {'S': [0, 0, 0, 0, 0, 0, 0, 0], 'XG': 0xff00ff0f, 'Y': 0x01010100, 'CIN': 1};
  adderT(state, {'AD': 9, 'DG': 0});
  assert.equal(state['S'][1], 1, 'state');
  assert.equal(state['pending']['L'], 0x00660066, 'Corrections');
  assert.equal(state['T0'], 0x0002000f, 'sum');

  var state = {'S': [0, 1, 0, 0, 0, 0, 0, 0], 'XG': 0xff00ff0f, 'Y': 0x01010100, 'CIN': 1};
  adderT(state, {'AD': 9, 'DG': 0});
  assert.equal(state['S'][1], 1, 'state 2');
  assert.equal(state['pending']['L'], 0x00660060, 'Corrections 2');
  assert.equal(state['T0'], 0x00020010, 'sum 2');

  var state = {'S': [0, 1, 0, 0, 0, 0, 0, 0], 'XG': 0xef00ff0f, 'Y': 0x01010100, 'CIN': 1};
  adderT(state, {'AD': 9, 'DG': 0});
  assert.equal(state['S'][1], 0, 'state 3');
  assert.equal(state['pending']['L'], 0x60660060, 'Corrections 3');
  assert.equal(state['T0'], 0xf0020010, 'sum 3');
});

// Decimal double. Set stat 1 to carry out of position 0. Insert previous value of stat 1
// as carry into position 31. Test each digit of sum. If 5 or greater, set corresponding digit
// position in L reg is set to 0000. If less than 5, set digit in L reg to 0000.
QUnit.test( "adder ad 10 DDC0", function(assert) {
  var state = {'S': [0, 1, 0, 0, 0, 0, 0, 0], 'XG': 0x98765431, 'Y': 0x00000000};
  adderT(state, {'AD': 10, 'DG': 0});
  assert.equal(state['T0'], 0x98765432, 'sum 1'); // Carry from stat
  assert.equal(state['S'][1], 0, 'stat carry');
  assert.equal(state['pending']['L'], 0x66666000, 'Corrections 1');

  var state = {'S': [0, 0, 0, 0, 0, 0, 0, 0], 'XG': 0x44444444, 'Y': 0x01010101};
  adderT(state, {'AD': 10, 'DG': 0});
  assert.equal(state['T0'], 0x45454545, 'sum 2');
  assert.equal(state['S'][1], 0, 'stat carry 2');
  assert.equal(state['pending']['L'], 0x06060606, 'Corrections 2');

  var state = {'S': [0, 1, 0, 0, 0, 0, 0, 0], 'XG': 0xfedc3210, 'Y': 0x10000000};
  adderT(state, {'AD': 10, 'DG': 0});
  assert.equal(state['T0'], 0x0edc3211, 'sum 3');
  assert.equal(state['S'][1], 1, 'stat carry 3');
  assert.equal(state['pending']['L'], 0x06660000, 'Corrections 3');

});

// Decimal halve (high order). Bit 2 of each digit of the sum is tested. If the bit is one, the next digit
// position to the right in the L reg is set to 0110. If the bit is zero, the digit in
// the L reg is set to 0000. The leftmost digit in L reg is set to 0000. The auxiliary trigger is set to bit
// 2 of the rightmost sum digit (sum bit 30).
QUnit.test( "adderT ad 11 DHH", function(assert) {
  var state = {'XG': 0xdddddddd, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['pending']['L'], 0, 'No correction');
  assert.equal(state['AUX'], 0);

  state = {'XG': 0xddddddd2, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['pending']['L'], 0, 'No correction, aux');
  assert.equal(state['AUX'], 1);

  state = {'XG': 0x22222220, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['pending']['L'], 0x06666666, 'All correction');
  assert.equal(state['AUX'], 0);

  state = {'XG': 0xffffffff, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['pending']['L'], 0x06666666, 'All correction, AUX');
  assert.equal(state['AUX'], 1);

  state = {'XG': 0x22002002, 'AUX': 0, 'Y': 0, 'CIN': 0};
  adderT(state, {'AD': 11});
  assert.equal(state['pending']['L'], 0x06600600, 'Some correction, AUX');
  assert.equal(state['AUX'], 1);
});

// Decimal add. Set stat 1 to carry out of leftmost byte position for which a byte stat is on.
// Insert previous value of stat 1 as carry into position 1[?]. Test carry out of each digit position.
// If carry, set corresponding digit position in L reg to 0000. If no carry, set digit in L reg to 0110.
// Note: The text says carry into position 1, but that doesn't make any sense so I'm assuming position 31.
QUnit.test( "adder ad 12 DCBS", function(assert) {
  // Carry-in
  var state = {'XG': 0x0000ffff, 'Y': 0, 'BS': [0, 0, 1, 0], 'S': [0, 1, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x00010000, 'Sum with carry in');
  assert.equal(state['pending']['L'], 0x66660000, 'Correction with carry-in');
  assert.equal(state['S']['1'], 1, 'Carry out stat');

  // No carry-in
  var state = {'XG': 0x0000ffff, 'Y': 0, 'BS': [0, 0, 1, 0], 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x00000ffff, 'Sum with no carry in');
  assert.equal(state['pending']['L'], 0x66666666, 'Correction with no carry-in');
  assert.equal(state['S']['1'], 0, 'Carry out stat, no carry in');

  // No carry-out from byte stat
  var state = {'XG': 0xffffefff, 'Y': 0x00010001, 'BS': [0, 0, 1, 0], 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x0000f000, 'Sum 3');
  assert.equal(state['pending']['L'], 0x00006000, 'Correction 3');
  assert.equal(state['S']['1'], 0, 'Carry out stat');

  // Test byte-stat 0
  var state = {'XG': 0xffffffff, 'Y': 0x01000000, 'BS': [1, 0, 0, 0], 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x00ffffff, 'sum, bs 0');
  assert.equal(state['S']['1'], 1, 'Carry out stat, bs 0');

  // Test byte-stat 1
  var state = {'XG': 0xffffffff, 'Y': 0x00010000, 'BS': [0, 1, 0, 0], 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x0000ffff, 'sum, bs 1');
  assert.equal(state['S']['1'], 1, 'Carry out stat, bs 1');

  // Test byte-stat 2
  var state = {'XG': 0xffffffff, 'Y': 0x00000100, 'BS': [0, 0, 1, 0], 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x000000ff, 'sum, bs 2');
  assert.equal(state['S']['1'], 1, 'Carry out stat, bs 2');

  // Test byte-stat 3
  var state = {'XG': 0xffffffff, 'Y': 0x00000001, 'BS': [0, 0, 0, 1], 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  adderT(state, {'AD': 12});
  assert.equal(state['T0'], 0x00000000, 'sum, bs 3');
  assert.equal(state['S']['1'], 1, 'Carry out stat, bs 3');
});

QUnit.test( "adder dg 1 CSTAT→ADDER", function(assert) {
  var state = {'CSTAT': 0};
  adderDG(state, {'DG': 1 /* CSTAT→ADDER */});
  assert.equal(state['CIN'], 0);

  state = {'CSTAT': 1};
  adderDG(state, {'DG': 1 /* CSTAT→ADDER */});
  assert.equal(state['CIN'], 1);
});

QUnit.test( "adder dg2 HOT1→ADDER", function(assert) {
  var state = {'L': 0x12345678};
  adder(state, {'LX': 1 /* L */, 'RY': 0 /* 0 */, 'TC': 1 /* add */, 'AD': 1 /* default op */, 'DG': 2 /* HOT1→ADDER */});
  assert.equal(state['T0'], 0x12345679);
});

QUnit.test( "adder dg 3 G1-1", function(assert) {
  var state = {'G1': 1};
  adderDG(state, {'DG': 3 /* G1-1 */});
  assert.equal(state['G1NEG'], 0);
  assert.equal(state['pending']['G1'], 0);

  state = {'G1': 0};
  adderDG(state, {'DG': 3 /* G1-1 */});
  assert.equal(state['G1NEG'], 1);
  assert.equal(state['pending']['G1'], undefined); // No change
});

QUnit.test( "adder dg 4 HOT1,G-1", function(assert) {
  var state = {'G1': 2, 'G2':1};
  adderDG(state, {'DG': 4});
  assert.equal(state['pending']['G1'], undefined); // no change
  assert.equal(state['pending']['G2'], 0);
  assert.equal(state['CIN'], 1);

  state = {'G1': 2, 'G2':0};
  adderDG(state, {'DG': 4});
  assert.equal(state['pending']['G1'], 1);
  assert.equal(state['pending']['G2'], 0xf);
  assert.equal(state['CIN'], 1);
});

QUnit.test( "adder dg 5 G2-1", function(assert) {
  var state = {'G2': 1};
  adderDG(state, {'DG': 5 /* G2-1 */});
  assert.equal(state['G2NEG'], 0);
  assert.equal(state['pending']['G2'], 0);

  state = {'G2': 0};
  adderDG(state, {'DG': 5 /* G2-1 */});
  assert.equal(state['G2NEG'], 1);
  assert.equal(state['pending']['G2'], undefined); // No change below 0
});

QUnit.test( "adder dg 6 G-1", function(assert) {
  var state = {'G1': 2, 'G2':1};
  adderDG(state, {'DG': 6});
  assert.equal(state['pending']['G1'], undefined); // No change
  assert.equal(state['pending']['G2'], 0);

  state = {'G1': 2, 'G2':0};
  adderDG(state, {'DG': 6});
  assert.equal(state['pending']['G1'], 1);
  assert.equal(state['pending']['G2'], 0xf);
});

QUnit.test( "adder dg 7 G1,2-1", function(assert) {
  var state = {'G1': 0, 'G2': 1};
  adderDG(state, {'DG': 7});
  assert.equal(state['G1NEG'], 1);
  assert.equal(state['G2NEG'], 0);
  assert.equal(state['pending']['G1'], undefined); // No change
  assert.equal(state['pending']['G2'], 0);

  var state = {'G1': 0xf, 'G2': 0};
  adderDG(state, {'DG': 7});
  assert.equal(state['G1NEG'], 0);
  assert.equal(state['G2NEG'], 1);
  assert.equal(state['pending']['G1'], 0xe);
  assert.equal(state['pending']['G2'], undefined); // No change
});


QUnit.test( "iar0", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  iar(state, {'IV': 0});
  assert.expect(0);
});

QUnit.test( "iar iv 1 WL→IVD", function(assert) {
  var state = {'WL': 0x0};
  iar(state, {'IV': 1}); // Nop, implemented in iar2
  iar2(state, {'IV': 1});
  state = {'WL': 0x9};
  iar2(state, {'IV': 1});
  assert.throws(function() {
    state = {'WL': 0xa}; // Invalid digit
    iar2(state, {'IV': 1});
  });
});

QUnit.test( "iar iv 2 WR→IVD", function(assert) {
  var state = {'WR': 0x0};
  iar(state, {'IV': 2}); // Nop, implemented in iar2
  iar2(state, {'IV': 2});
  state = {'WR': 0x9};
  iar2(state, {'IV': 2});
  assert.throws(function() {
    state = {'WR': 0xa}; // Invalid digit
    iar2(state, {'IV': 2});
  });
});

QUnit.test( "iar iv 3 W→IVD", function(assert) {
  var state = {'WL': 0x0, 'WR': 0x4};
  iar(state, {'IV': 3}); // Nop, implemented in iar2
  iar2(state, {'IV': 3});
  assert.throws(function() {
    state = {'WL': 0xa}; // Invalid digit
    iar2(state, {'IV': 3});
  });
  assert.throws(function() {
    state = {'WL': 0x0, 'WR': 0xf}; // Invalid digit
    iar2(state, {'IV': 3});
  });
});

QUnit.test( "iar iv 4 IA/4→A,IA", function(assert) {
  var state = {'IAR': 0x12340000};
  iar(state, {'IV': 4});
  assert.equal(state['IAR'], 0x12340004);
  assert.equal(state['SAR'], 0x12340004);
  assert.equal(state['IAS'], 0);

  var state = {'IAR': 0x12340002};
  iar(state, {'IV': 4});
  assert.equal(state['IAR'], 0x12340006);
  assert.equal(state['SAR'], 0x12340006);
  assert.equal(state['IAS'], 1, "invalid address stat");
});

QUnit.test( "iar iv 5 IA+2/4", function(assert) {
  // ILC 0
  var state = {'ILC': 0, 'IAR': 0x00123450};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x00123452);

  // ILC 1
  var state = {'ILC': 1, 'IAR': 0x00123450};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x00123452);

  // ILC 2
  var state = {'ILC': 2, 'IAR': 0x00123450};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x00123454);

  // ILC 3
  var state = {'ILC': 3, 'IAR': 0x00123450};
  iar(state, {'IV': 5});
  assert.equal(state['IAR'], 0x00123454);
});

QUnit.test( "iar iv 6 IA+2", function(assert) {
  var state = {'IAR': 0x12340000};
  iar(state, {'IV': 6});
  assert.equal(state['IAR'], 0x12340002);
});

QUnit.test( "iar iv 7 IA+0/2→A", function(assert) {
  // Refetch stat off cases, increment by 2
  var state = {'IAR': 0x00123450, 'REFETCH': 0};
  iar(state, {'IV': 7});
  assert.equal(state['IAR'], 0x00123450);
  assert.equal(state['SAR'], 0x00123452);
  assert.equal(state['IAS'], 1, "invalid address stat");

  var state = {'IAR': 0x00123452, 'REFETCH': 0};
  iar(state, {'IV': 7});
  assert.equal(state['IAR'], 0x00123452);
  assert.equal(state['SAR'], 0x00123454);
  assert.equal(state['IAS'], 0, "invalid address stat");

  var state = {'IAR': 0x00123452, 'REFETCH': 0}; // with SMIF: skip fetch if off word boundary
  iar(state, {'IV': 7, 'ZN': 1}); // ZN=1 for SMIF
  assert.equal(state['IAR'], 0x00123452);
  assert.equal(state['SAR'], undefined, "fetch skipped");

  var state = {'IAR': 0x00123450, 'REFETCH': 0};
  iar(state, {'IV': 7, 'ZN': 1});
  assert.equal(state['IAR'], 0x00123450);
  assert.equal(state['SAR'], 0x00123452);

  // Refetch stat on cases
  var state = {'IAR': 0x00123450, 'REFETCH': 1};
  iar(state, {'IV': 7});
  assert.equal(state['IAR'], 0x00123450);
  assert.equal(state['SAR'], 0x00123450);
  assert.equal(state['IAS'], 0, "invalid address stat");

  var state = {'IAR': 0x00123452, 'REFETCH': 1};
  iar(state, {'IV': 7});
  assert.equal(state['IAR'], 0x00123452);
  assert.equal(state['SAR'], 0x00123452);
  assert.equal(state['IAS'], 1, "invalid address stat");

  var state = {'IAR': 0x00123450, 'REFETCH': 1}; // with SMIF: skip fetch if off word boundary
  iar(state, {'IV': 7, 'ZN': 1});
  assert.equal(state['IAR'], 0x00123450);
  assert.equal(state['SAR'], 0x00123450);
  assert.equal(state['IAS'], 0, "invalid address stat");

  var state = {'IAR': 0x00123452, 'REFETCH': 1};
  iar(state, {'IV': 7, 'ZN': 1});
  assert.equal(state['IAR'], 0x00123452);
  assert.equal(state['SAR'], 0x00123452);
  assert.equal(state['IAS'], 1, "invalid address stat");
});

QUnit.test( "latch tr 1 R", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  var entry = {'TR': 1 /* R */};
  adderLatch(state, entry);
  assert.equal(state['R'], 0x12345678);
});

QUnit.test( "latch tr 2 R0", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  var entry = {'TR': 2 /* R0 */};
  adderLatch(state, entry);
  assert.equal(state['R'], 0x12781234);
});

QUnit.test( "latch tr 3 M", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  var entry = {'TR': 3 /* M */};
  adderLatch(state, entry);
  assert.equal(state['M'], 0x12345678);
});

QUnit.test( "latch tr 4 D", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234, 'SAR': 0x20};
  state['MS'] = [];
  adderLatch(state, {'TR': 4 /* M */});
  assert.equal(state['SDR'], 0x12345678);
  assert.equal(state['MS'][0x20], 0x12345678);
});

QUnit.test( "latch tr 5 L0", function(assert) {
  var state = {'T': 0x12345678, 'L': 0x56781234};
  adderLatch(state, {'TR': 5 /* L0 */});
  assert.equal(state['L'], 0x12781234);
});

QUnit.test( "latch tr 6 R,A", function(assert) {
  var state = {'T': 0x12345678, 'R': 0x56781234};
  adderLatch(state, {'TR': 6 /* R,A */});
  assert.equal(state['R'], 0x12345678);
  assert.equal(state['SAR'], 0x345678);
});

QUnit.test( "latch tr 7 L", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 7 /* L */});
  assert.equal(state['L'], 0x12345678);
});

QUnit.skip( "latch tr 8 HA→A", function(assert) {
});

QUnit.test( "latch tr 9 R,AN", function(assert) {
  var state = {'T': 0x12345679};
  adderLatch(state, {'TR': 9 /* R,AN */});
  assert.equal(state['R'], 0x12345679);
  assert.equal(state['SAR'], 0x345679);
  assert.equal(state['TRAP'], undefined);
});

QUnit.test( "latch tr 10 R,AW", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 10 /* R,AW */});
  assert.equal(state['R'], 0x12345678);
  assert.equal(state['SAR'], 0x345678);
  assert.equal(state['TRAP'], undefined);
  state = {'T': 0x12345672}; // Halfword
  });

QUnit.test( "latch tr 11 R,AD", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 11 /* R,AD */});
  assert.equal(state['R'], 0x12345678);
  assert.equal(state['SAR'], 0x345678);
  state = {'T': 0x12345674}; // Word
});

QUnit.test( "latch tr 12 D→IAR", function(assert) {
  var state = {'T': 0x12345678, 'SAR': 0x10};
  state['MS'] = [];
  state['MS'][0x10] = 0x3456789a;
  adderLatch(state, {'TR': 12 /* IAR */});
  assert.equal(state['IAR'], 0x0006789a);
});

QUnit.skip( "latch tr 13 SCAN→D", function(assert) {
});

QUnit.test( "latch tr 14 R13", function(assert) {
  var state = {'T': 0x12345678, 'R': 0xaabbccdd};
  adderLatch(state, {'TR': 14});
  assert.equal(state['R'], 0xaa345678);
});

QUnit.test( "latch tr 15 A", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 15});
  assert.equal(state['SAR'], 0x345678);
});

QUnit.test( "latch tr 16 L,A", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 16});
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['SAR'], 0x345678);
});

// 17: I/O

// 18: unused

// 19: I/O

QUnit.test( "latch tr 20 H", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 20 /* H */});
  assert.equal(state['H'], 0x12345678);
});

QUnit.test( "latch tr 21 IA", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 21});
  assert.equal(state['IAR'], 0x00345678);
});

QUnit.skip( "latch tr 22 FOLD→D", function(assert) {
});

// 23: unused

QUnit.test( "latch tr 24 L,M", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 24});
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['M'], 0x12345678);
});

  // Complex instruction decoding
QUnit.test( "latch 25 MLJK", function(assert) {
  // X=0, B=0
  var state = {'T': 0x12300678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 0);
  assert.equal(state['MD'], 0);
  assert.equal(state['S'][0], 1, 'j'); // X=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 1, 'b'); // B=0, i.e. T(16-19), MD

  // X=4, B=0
  state = {'T': 0x12340678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 4);
  assert.equal(state['MD'], 0);
  assert.equal(state['S'][0], 0, 'j'); // X!=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 1, 'b'); // B=0, i.e. T(16-19), MD

  // X=4, B=5
  state = {'T': 0x12345678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 4);
  assert.equal(state['MD'], 5);
  assert.equal(state['S'][0], 0, 'j'); // X!=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 0, 'b'); // B!=0, i.e. T(16-19)

  // X=0, B=5
  state = {'T': 0x12305678, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['L'], state['T']);
  assert.equal(state['M'], state['T']);
  assert.equal(state['REFETCH'], 0);
  assert.equal(state['J'], 0);
  assert.equal(state['MD'], 5);
  assert.equal(state['S'][0], 1, 'j'); // X=0, i.e. T(12-15), J
  assert.equal(state['S'][1], 0, 'b'); // B=0, i.e. T(16-19), MD

  // Test 1SYL
  state = {'T': 0x00000000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['1SYL'], 1);

  state = {'T': 0x00004000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['1SYL'], 0);

  state = {'T': 0x00008000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['1SYL'], 0);

  state = {'T': 0x0000c000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['1SYL'], 0);

  // Test ILC
  state = {'T': 0x00000000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['ILC'], 1);

  state = {'T': 0x40000000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['ILC'], 2);

  state = {'T': 0x80000000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['ILC'], 2);

  state = {'T': 0xc0000000, 'S': []};
  adderLatch(state, {'TR': 25});
  assert.equal(state['ILC'], 3);

});

QUnit.test( "latch tr 26 MHL", function(assert) {
  var state = {'T': 0x12345678, 'M': 0x11223344};
  adderLatch(state, {'TR': 26});
  assert.equal(state['MD'], 0x1);
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['M'], 0x11221234);
});

QUnit.test( "latch tr 27 MD", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 27});
  assert.equal(state['MD'], 0x3);
});

QUnit.test( "latch tr 28 M,SP", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 28});
  assert.equal(state['M'], 0x12345678);
  assert.equal(state['KEY'], 0x3);
});

QUnit.test( "latch29 D*BS", function(assert) {
  // BS = 0011: only modify last two memory words
  var state = {'T': 0x12345678, 'BS': [0, 0, 1, 1], 'SAR': 0x30};
  state['MS'] = [];
  state['MS'][0x30] = 0x9abcdef0;
  adderLatch(state, {'TR': 29});
  assert.equal(state['SDR'], 0x9abc5678);
  assert.equal(state['MS'][0x30], 0x9abc5678);
});

QUnit.test( "latch tr 30 L13", function(assert) {
  var state = {'T': 0x12345678, 'L': 0xaabbccdd};
  adderLatch(state, {'TR': 30});
  assert.equal(state['L'], 0xaa345678);
});

QUnit.test( "latch tr 31 J", function(assert) {
  var state = {'T': 0x12345678};
  adderLatch(state, {'TR': 31 /* J */});
  assert.equal(state['J'], 0x4); // Note bits 12-15
});

QUnit.test( "mover", function(assert) {
  // Extract 5 from E, 8 from M3
  var state = {'M': 0x12345678, 'MB': 3};
  var entry = {'LU': 0, 'MV': 2 /* MMB */, 'UL': 0 /* E */, 'UR': 2 /* V */, 'WM': 6 /* WL->J */, 'CE': 0x5};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x58);
  assert.equal(state['WL'], 0x5);
  assert.equal(state['J'], 0x5);
  assert.equal(state['WR'], 0x8);
});

QUnit.test( "mover lu 4 XTR", function(assert) {
  var state = {'M': 0x12345678, 'MB': 3};
  var entry = {'LU': 4 /* XTR */, 'MV': 2 /* MMB */, 'UL': 0 /* E */, 'UR': 2 /* V */, 'WM': 6 /* WL->J */, 'CE': 0x5};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['U'], 0);
});

QUnit.test( "mover2", function(assert) {
  // E->WR, W->MMB
  var state = {'MB': 0, 'M': 0x12345678};
  var entry = {'LU': 0, 'MV': 0, 'UL': 1, 'UR': 0, 'WM': 1, 'RY': 0, 'CE': 7};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 7);
  assert.equal(state['WL'], 0);
  assert.equal(state['WR'], 7);
  assert.equal(state['M'], 0x07345678);
});

QUnit.test( "movers", function(assert) {
  // E->WR, W->MMB
  var state = { 'LB': 0, 'L': 0x34000000, 'MB': 0, 'M': 0x12000000};
  // LLB -> U, MLB -> V, ?->WL, ?->WR
  var entry = {'LU': 7, 'MV': 2, 'UL': 3, 'UR': 3, 'WM': 0};
  state['WFN'] = 1; // or
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x12 | 0x34);

  state['WFN'] = 2; // and
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x12 & 0x34);

  state['WFN'] = 3; // xor
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x12 ^ 0x34);

  state['WFN'] = 4; // char
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x34);

  state['WFN'] = 5; // zone
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x32); // Assuming w's zone is overwritten, keep numeric

  state['WFN'] = 6; // numeric
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x14);

  state['WFN'] = 0; // cross
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  assert.equal(state['W'], 0x43);
});

QUnit.test("moverU 0", function(assert) {
  state = {};
  moverU(state, {'LU': 0});
  assert.equal(state['U'], 0);
});

QUnit.test("moverU 1 MD,F", function(assert) {
  state = {'MD': 0x3, 'F': 0x4};
  moverU(state, {'LU': 1});
  assert.equal(state['U'], 0x34);
});

QUnit.test("moverU 2 R3", function(assert) {
  state = {'R': 0x11223344};
  moverU(state, {'LU': 2});
  assert.equal(state['U'], 0x44);
});

QUnit.test("moverU 4 XTR", function(assert) {
  state = {};
  moverU(state, {'LU': 4});
  assert.equal(state['U'], 0);
});

QUnit.test("moverU 5 PSW4", function(assert) {
  state = {'ILC': 2, 'CR': 3, 'PROGMASK': 0xa};
  moverU(state, {'LU': 5});
  assert.equal(state['U'], 0xba);
});

QUnit.test("moverU 6 LMB", function(assert) {
  state = {'L': 0x11223344, 'MB': 2};
  moverU(state, {'LU': 6});
  assert.equal(state['U'], 0x33);
});

QUnit.test("moverU 7 LLB", function(assert) {
  state = {'L': 0x11223344, 'LB': 1};
  moverU(state, {'LU': 7});
  assert.equal(state['U'], 0x22);
});

QUnit.test("moverV 0 0", function(assert) {
  state = {};
  moverV(state, {'MV': 0});
  assert.equal(state['V'], 0);
});

QUnit.test("moverV 1 MLB", function(assert) {
  state = {'M': 0x11223344, 'LB': 1};
  moverV(state, {'MV': 1});
  assert.equal(state['V'], 0x22);
});

QUnit.test("moverV 2 MMB", function(assert) {
  state = {'M': 0x11223344, 'MB': 2};
  moverV(state, {'MV': 2});
  assert.equal(state['V'], 0x33);
});

QUnit.test("storeMover WM 1 W→MMB", function(assert) {
  var state = {'W': 0x89, 'WL': 0x8, 'WR': 0x9, 'MB': 2, 'M': 0x11223344};
  storeMover(state, {'WM': 1});
  assert.equal(state['M'], 0x11228944);
});

QUnit.test("storeMover WM 2 W67→MB", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 2});
  assert.equal(state['MB'], 1);
});

QUnit.test("storeMover WM 3 W67→LB", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 3});
  assert.equal(state['LB'], 1);
});

QUnit.test("storeMover WM 4 W27→PSW4", function(assert) {
  var state = {'W': 0x98, 'WL': 9, 'WR': 8};
  storeMover(state, {'WM': 4});
  assert.equal(state['CR'], 0x1);
  assert.equal(state['PROGMASK'], 0x8);
});

QUnit.test("storeMover WM 5 W→PSW0", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 5});
  assert.equal(state['SYSMASK'], 0x89);
});

QUnit.test("storeMover WM 6 WL→J", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 6});
  assert.equal(state['J'], 8);
});

QUnit.skip("storeMover WM 7 W→CHCTL", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
});

QUnit.test("storeMover WM 8 W,E→A(BUMP)", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 8, 'CE': 7});
  assert.equal(state['SAR'], 0x100089c);
});

QUnit.test("storeMover WM 9 WL→G1", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 9});
  assert.equal(state['G1'], 8);
});

QUnit.test("storeMover WM 10 WR→G2", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 10});
  assert.equal(state['G2'], 9);
});

QUnit.test("storeMover WM 11 W→G", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 11});
  assert.equal(state['G1'], 8);
  assert.equal(state['G2'], 9);
});

QUnit.skip("storeMover WM 12 W→MMB(E?)", function(assert) {
});

QUnit.test("storeMover WM 13 WL→MD", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 13});
  assert.equal(state['MD'], 8);
});

QUnit.test("storeMover WM 14 WR→F", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 14});
  assert.equal(state['F'], 9);
});

QUnit.test("storeMover WM 15 W→MD,F", function(assert) {
  var state = {'W': 0x89, 'WL': 8, 'WR': 9};
  storeMover(state, {'WM': 15});
  assert.equal(state['MD'], 8);
  assert.equal(state['F'], 9);
});

QUnit.test( "counters", function(assert) {
  var state = {'LB': 1, 'MB': 1, 'MD': 1};
  var entry = {'UP': 0 /* 0 -> */, 'LB': 1, 'MB': 0, 'MD': 0};
  counters(state, entry);
  assert.equal(state['LB'], 0);
  assert.equal(state['MB'], 1);
  assert.equal(state['MD'], 1);
  entry = {'UP': 1 /* 3 -> */, 'LB': 0, 'MB': 1, 'MD': 0};
  counters(state, entry);
  assert.equal(state['LB'], 0);
  assert.equal(state['MB'], 3);
  assert.equal(state['MD'], 1);
  entry = {'UP': 2 /* dec */, 'LB': 0, 'MB': 1, 'MD': 1};
  counters(state, entry);
  assert.equal(state['LB'], 0);
  assert.equal(state['MB'], 2);
  assert.equal(state['MD'], 0);
  entry = {'UP': 3 /* inc */, 'LB': 1, 'MB': 1, 'MD': 0};
  counters(state, entry);
  assert.equal(state['LB'], 1);
  assert.equal(state['MB'], 3);
  assert.equal(state['MD'], 0);
});

QUnit.test( "localStorage", function(assert) {
  var ls = new Array(64);
  for (var i = 0; i < 64; i++) {
    ls[i] = i;
  }
  var state = {'LS': ls};
  var entry = {'WS': 1 /* WS1 -> LSA */, 'SF': 2 /* LS->R->LS */};
  localStorageLSAR(state, {'WS': 1 /* WS1 -> LSA */});
  assert.equal(state['LSAR'], 17); // LSFN = 0b110001
  localStore(state, {'SF': 2 /* LS->R->LS */});
  assert.equal(state['R'], 17);
});

QUnit.test("localStorage LSAR 1 WS1→LSA", function(assert) {
  var state = {};
  localStorageLSAR(state, {'WS': 1});
  assert.equal(state['LSAR'], 0x11);
});

QUnit.test("localStorage LSAR 2 WS2→LSA", function(assert) {
  var state = {};
  localStorageLSAR(state, {'WS': 2});
  assert.equal(state['LSAR'], 0x12);
});

QUnit.test("localStorage LSAR 3 WS,E→LSA", function(assert) {
  var state = {};
  localStorageLSAR(state, {'WS': 3, 'CE': 5});
  assert.equal(state['LSAR'], 0x15);
});

QUnit.test("localStorage LSAR 4 FN,J→LSA", function(assert) {
  var state = {'FN': 2, 'J': 3};
  localStorageLSAR(state, {'WS': 4, 'SF': 7});
  assert.equal(state['LSAR'], undefined); // Blocked by SF=7
  var state = {'FN': 2, 'J': 3, 'WS': 0};
  localStorageLSAR(state, {'WS': 4, 'SF': 0});
  assert.equal(state['LSAR'], 0x23);
});

QUnit.test("localStorage LSAR 5 FN,JΩ1→LSA", function(assert) {
  var state = {'FN': 2, 'J': 2};
  localStorageLSAR(state, {'WS': 5});
  assert.equal(state['LSAR'], 0x23);
});

QUnit.test("localStorage LSAR 6 FN,MD→LSA", function(assert) {
  var state = {'FN': 2, 'MD': 7};
  localStorageLSAR(state, {'WS': 6});
  assert.equal(state['LSAR'], 0x27);
});

QUnit.test("localStorage LSAR 7 FN,MDΩ1→LSA", function(assert) {
  var state = {'FN': 2, 'MD': 6};
  localStorageLSAR(state, {'WS': 7});
  assert.equal(state['LSAR'], 0x27);
});

QUnit.test( "localStorage SF=0 R→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'R': 0x11223344};
  localStore(state, {'SF': 0});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['R'], 0x11223344);
});

QUnit.test( "localStorage SF=1 LS→L,R→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'R': 0x11223344};
  localStore(state, {'SF': 1});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['L'], 0x12345678);
  assert.equal(state['R'], 0x11223344);
});

QUnit.test( "localStorage WS=2 WS2→LSA, SF=2 LS→R→LS", function(assert) {
  var state = {'LS':{0x12: 0x12345678}, 'R': 0x11223344};
  localStorageLSAR(state, {'WS': 2}); // WS2→LSA
  assert.equal(state['LSAR'], 0x12);
  localStore(state, {'SF': 2});
  assert.equal(state['R'], 0x12345678);
});

QUnit.test( "localStorage SF=4 L→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'L': 0x11223344};
  localStore(state, {'SF': 4});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['L'], 0x11223344);
});

QUnit.test( "localStorage SF=5 LS→R,L→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'L': 0x11223344, 'R': 0x55667788};
  localStore(state, {'SF': 5});
  assert.equal(state['LS'][0x32], 0x11223344);
  assert.equal(state['L'], 0x11223344);
  assert.equal(state['R'], 0x12345678);
});

QUnit.test( "localStorage SF=6 LS→L→LS", function(assert) {
  var state = {'LSAR': 0x32, 'LS':{0x32: 0x12345678}, 'L': 0x11223344};
  localStore(state, {'SF': 6});
  assert.equal(state['LS'][0x32], 0x12345678);
  assert.equal(state['L'], 0x12345678);
});

QUnit.test( "ls sf 0 R→LS", function(assert) {
  var state = {'LS':[], 'R': 0x12345678, 'LSAR': 0x31};
  // Update LSA
  localStorageLSAR(state, {'CE': 4, 'WS': 3 /* WS,E→LSA */});
  // Update LS
  localStore(state, {'SF': 0 /* R→LS */});
  assert.equal(state['LS'][0x14], 0x12345678);
});

QUnit.test( "ls3  WS,E→LSA", function(assert) {
  var state = {'LS': [], 'R': 0x12345678};
  localStorageLSAR(state, {'CE': 5, 'WS': 3 /* WS,E→LSA */});
  assert.equal(state['LSAR'], 0x15); // LSFN = 0b110101
  localStore(state, {'SF': 0 /* R→LS */});
  assert.equal(state['LS'][0x15], 0x12345678);
});

QUnit.test( "roar1", function(assert) {
  var state = {};
  roar(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 4});
  assert.equal(state['ROAR'], 0x49c);
  roarAB(state, {'AB': 1});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar-zn", function(assert) {
  // Test ZN functions
  var state = {'ROAR': 0x49c};
  roarZN(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 2 /* AΩ(B=0)→A */});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c};
  roarZN(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 3 /* AΩ(B=1)→A */});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c};
  roarZN(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 6 /* BΩ(A=0)→B */});
  assert.equal(state['ROAR'], 0x49c | 1);
});

  // Test ZF functions (ZN = 0)
QUnit.test( "roar-zf", function(assert) {
  var state = {'ROAR': 0x480, 'F': 3};
  roarZN(state, {'ZP': 0x12, 'ZF': 10 /* F->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], (0x12 << 6) | (0x3 << 2));

  var state = {'ROAR': 0x4ff, 'ED': 0xf};
  roarZN(state, {'ZP': 0x12, 'ZF': 12 /* ED->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], 0x4ff);

  var state = {'ROAR': 0x4ff, 'ED': 0};
  roarZN(state, {'ZP': 0x12, 'ZF': 12 /* ED->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], 0x4c3);

  state = {'ROAR': 0x480, 'M': 0x24ffffff};
  roarZN(state, {'ZP': 0x12, 'ZF': 6 /* M(03)->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], (0x12 << 6) | (0x2 << 2));

  state = {'ROAR': 0x480, 'M': 0x24ffffff};
  roarZN(state, {'ZP': 0x12, 'ZF': 8 /* M(47)->ROAR */, 'ZN': 0});
  assert.equal(state['ROAR'], (0x12 << 6) | (0x4 << 2));
});

QUnit.test( "ab 0 (0)", function(assert) {
  var state = {'ROAR': 0x49c};
  roarAB(state, {'AB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test( "ab 1 (1)", function(assert) {
  var state = {'ROAR': 0x49c};
  roarAB(state, {'AB': 1});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 2 (S0)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 2});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 2});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 3 (S1)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 3});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 1, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 3});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 4 (S2)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 4});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 1, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 4});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 5 (S3)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 5});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 1, 0, 0, 0, 0]};
  roarAB(state, {'AB': 5});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 6 (S4)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 6});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 1, 0, 0, 0]};
  roarAB(state, {'AB': 6});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 7 (S5)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 7});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 1, 0, 0]};
  roarAB(state, {'AB': 7});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 8 (S6)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 8});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 1, 0]};
  roarAB(state, {'AB': 8});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 9 (S7)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarAB(state, {'AB': 9});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 1]};
  roarAB(state, {'AB': 9});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 10 (CSTAT)", function(assert) {
  var state = {'ROAR': 0x49c, 'CSTAT': 0};
  roarAB(state, {'AB': 10});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'CSTAT': 1};
  roarAB(state, {'AB': 10});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 11 unused

QUnit.test( "ab 12 (1SYLS)", function(assert) {
  var state = {'ROAR': 0x49c, '1SYLS': 0};
  roarAB(state, {'AB': 12});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, '1SYLS': 1};
  roarAB(state, {'AB': 12});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 13 (LSGNS)", function(assert) {
  var state = {'ROAR': 0x49c, 'LSGNS': 0};
  roarAB(state, {'AB': 13});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'LSGNS': 1};
  roarAB(state, {'AB': 13});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 14 (⩝SGNS)", function(assert) {
  var state = {'ROAR': 0x49c, 'LSGNS': 0, 'RSGNS': 0};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'LSGNS': 1, 'RSGNS': 0};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 2);
  state = {'ROAR': 0x49c, 'LSGNS': 0, 'RSGNS': 1};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 2);
  state = {'ROAR': 0x49c, 'LSGNS': 1, 'RSGNS': 1};
  roarAB(state, {'AB': 14});
  assert.equal(state['ROAR'], 0x49c | 0);
});

// 15 unused

QUnit.test( "roar ab 16 CRMD", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'CR': 0, 'MD': 7};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'CR': 1, 'MD': 11};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'CR': 2, 'MD': 13};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'CR': 3, 'MD': 14};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  var state = {'ROAR': 0x49c, 'CR': 0, 'MD': 8};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'CR': 1, 'MD': 4};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'CR': 2, 'MD': 2};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'CR': 3, 'MD': 1};
  roarAB(state, {'AB': 16});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 17 W=0", function(assert) {
  var state = {'ROAR': 0x49c, 'W': 1};
  roarAB(state, {'AB': 17});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 0};
  roarAB(state, {'AB': 17});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 18 WL=0", function(assert) {
  var state = {'ROAR': 0x49c, 'WL': 1};
  roarAB(state, {'AB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'WL': 0};
  roarAB(state, {'AB': 18});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 19 WR=0", function(assert) {
  var state = {'ROAR': 0x49c, 'WR': 1};
  roarAB(state, {'AB': 19});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'WR': 0};
  roarAB(state, {'AB': 19});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 20 MD=FP", function(assert) {
  for (var i = 0; i < 16; i++) {
    var state = {'ROAR': 0x49c, 'MD': i};
    roarAB(state, {'AB': 20});
    if (i == 0 || i == 2 || i == 4 || i == 6) {
      assert.equal(state['ROAR'], 0x49c | 2);
    } else {
      assert.equal(state['ROAR'], 0x49c | 0);
    }
  }
});

QUnit.test( "roar ab 21 MB=3", function(assert) {
  var state = {'ROAR': 0x49c, 'MB': 2};
  roarAB(state, {'AB': 21});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'MB': 3};
  roarAB(state, {'AB': 21});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "roar ab 22 G1=0", function(assert) {
  var state = {'ROAR': 0x49c, 'MD': 0xe};
  roarAB(state, {'AB': 22 /* MD3=0 */});
  assert.equal(state['ROAR'], 0x49c | 2);
  state = {'ROAR': 0x49c, 'MD': 0xf};
  roarAB(state, {'AB': 22 /* MD3=0 */});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test( "roar ab 23 G1=0", function(assert) {
  var state = {'ROAR': 0x49c, 'G1': 1};
  roarAB(state, {'AB': 23});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G1': 0};
  roarAB(state, {'AB': 23});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 24 (G1NEG)", function(assert) {
  var state = {'ROAR': 0x49c, 'G1NEG': 0};
  roarAB(state, {'AB': 24});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'G1NEG': 1};
  roarAB(state, {'AB': 24});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 25 (G<4)", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'G1': 0, 'G2': 4};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'G1': 1, 'G2': 1};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  state = {'ROAR': 0x49c, 'G1': 0, 'G2': 3};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 2);

  // G1 sign negative case
  state = {'ROAR': 0x49c, 'G1': 1, 'G2': 3, 'G1NEG': 1};
  roarAB(state, {'AB': 25});
  assert.equal(state['ROAR'], 0x49c | 2, 'G1 negative');
});

QUnit.test( "ab 26 (G1MBZ)", function(assert) {
  var state = {'ROAR': 0x49c, 'G1': 1, 'MB': 1};
  roarAB(state, {'AB': 26});
  assert.equal(state['ROAR'], 0x49c | 0);
  var state = {'ROAR': 0x49c, 'G1': 0};
  roarAB(state, {'AB': 26});
  assert.equal(state['ROAR'], 0x49c | 2);
  var state = {'ROAR': 0x49c, 'G1': 1, 'MB': 0};
  roarAB(state, {'AB': 26});
  assert.equal(state['ROAR'], 0x49c | 2);
});

// 27: I/O

// 28: I/O

QUnit.test( "ab 29 R(31)", function(assert) {
  var state = {'ROAR': 0x49c, 'R': 0xfffffffe};
  roarAB(state, {'AB': 29});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'R': 1};
  roarAB(state, {'AB': 29});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 30 F(2)", function(assert) {
  var state = {'ROAR': 0x49c, 'F': 13};
  roarAB(state, {'AB': 30});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'F': 2};
  roarAB(state, {'AB': 30});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 31 L(0)", function(assert) {
  var state = {'ROAR': 0x49c, 'L': 0x7fffffff};
  roarAB(state, {'AB': 31});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'L': 0x80000000};
  roarAB(state, {'AB': 31});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 32 F=0", function(assert) {
  var state = {'ROAR': 0x49c, 'F': 1};
  roarAB(state, {'AB': 32});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'F': 0};
  roarAB(state, {'AB': 32});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 33 (UNORM)", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0xff0fffff, 'S': [0]};
  roarAB(state, {'AB': 33});
  assert.equal(state['ROAR'], 0x49c | 2); // T8-11 == 0, not stat 0
  state = {'ROAR': 0x49c, 'S': [1]};
  roarAB(state, {'AB': 33});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T': 0xff1fffff, 'S': [0]};
  roarAB(state, {'AB': 33});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test("ab 34 TZ*BS", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'T': 0x05000000, 'BS': [1, 0, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00800000, 'BS': [0, 1, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00001000, 'BS': [1, 0, 1, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00000004, 'BS': [1, 1, 1, 1]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  var state = {'ROAR': 0x49c, 'T': 0x00ffffff, 'BS': [1, 0, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xff00ffff, 'BS': [0, 1, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xffff00ff, 'BS': [0, 0, 1, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xffffff00, 'BS': [0, 0, 0, 1]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'T': 0xffffffff, 'BS': [0, 0, 0, 0]};
  roarAB(state, {'AB': 34});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test( "ab 35 EDITPAT", function(assert) {
  var state = {'ROAR': 0x49c, 'ES': [0, 0, 0]};
  roarAB(state, {'AB': 35});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'ES': [0, 0, 1]};
  roarAB(state, {'AB': 35});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'ES': [0, 1, 0]};
  roarAB(state, {'AB': 35});
  assert.equal(state['ROAR'], 0x49c | 2);

  var state = {'ROAR': 0x49c, 'ES': [0, 1, 1]};
  roarAB(state, {'AB': 35});
  assert.equal(state['ROAR'], 0x49c | 3);
});

QUnit.test( "ab 36 PROB", function(assert) {
  var state = {'ROAR': 0x49c, 'AMWP': 0xe};
  roarAB(state, {'AB': 36});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'AMWP': 1};
  roarAB(state, {'AB': 36});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip( "ab 37 TIMUP", function(assert) {
  state = {'ROAR': 0x49c, 'TIMUP': 0};
  roarAB(state, {'AB': 37});
  assert.equal(state['ROAR'], 0x49c | 0, 'No timer update');

  state = {'ROAR': 0x49c, 'TIMUP': 1};
  roarAB(state, {'AB': 37});
  assert.equal(state['ROAR'], 0x49c | 2, 'Timer update');
  assert.equal(state['TIMUP'], 0, 'Timer update reset');
});

// 38 unused

QUnit.test( "ab 39 (GZ/MB3)", function(assert) {
  var state = {'ROAR': 0x49c, 'G1': 0, 'G2': 0, 'MB': 1};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 2); // G == 0
  state = {'ROAR': 0x49c, 'G1': 1, 'G2': 1, 'MB': 3};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 2); // MB = 3
  state = {'ROAR': 0x49c, 'G1': 0, 'G2': 1, 'MB': 2};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 0); // G != 0 and MB != 3
  state = {'ROAR': 0x49c, 'G1': 2, 'G2': 0, 'MB': 0};
  roarAB(state, {'AB': 39});
  assert.equal(state['ROAR'], 0x49c | 0); // G != 0 and MB != 3
});


// 40 Unused

QUnit.test("ab 41 LOG", function(assert) {
  var state = {'ROAR': 0x49c, 'LSS': 0};
  roarAB(state, {'AB': 41});
  assert.equal(state['ROAR'], 0x49c | 0, 'Log/scan stat clear');

  var state = {'ROAR': 0x49c, 'LSS': 1};
  roarAB(state, {'AB': 41});
  assert.equal(state['ROAR'], 0x49c | 2, 'Log/scan stat set');
});

QUnit.test("ab 42 STC=0", function(assert) {
  var state = {'ROAR': 0x49c, 'STC': 0};
  roarAB(state, {'AB': 42});
  assert.equal(state['ROAR'], 0x49c | 0, 'Scan Test Counter clear');

  var state = {'ROAR': 0x49c, 'STC': 1};
  roarAB(state, {'AB': 42});
  assert.equal(state['ROAR'], 0x49c | 2, 'Scan Test Counter set');
});

QUnit.test("ab 43 G2<=LB", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'G2': 3, 'LB': 2};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 0};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  state = {'ROAR': 0x49c, 'G2': 3, 'LB': 3};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 0, 'LB': 1};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 3};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 0, 'LB': 0};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 2, 'G1NEG': 1, 'G2NEG': 1};
  roarAB(state, {'AB': 43});
  assert.equal(state['ROAR'], 0x49c | 2, 'Signs should be ignored');
});

// 44 unused

QUnit.test("ab 45 D(7)", function(assert) {
  // Negative case
  var state = {'ROAR': 0x49c, 'MS': {0x100: 0xfeffffff}, 'SAR': 0x100};
  roarAB(state, {'AB': 45});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive case
  state = {'ROAR': 0x49c, 'MS': {0x100: 0xffffffff}, 'SAR': 0x100};
  roarAB(state, {'AB': 45});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test("ab 46 SCPS", function(assert) {
  var state = {'ROAR': 0x49c, 'SCPS': 0};
  roarAB(state, {'AB': 46});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'SCPS': 1};
  roarAB(state, {'AB': 46});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.test("ab 47 SCFS", function(assert) {
  var state = {'ROAR': 0x49c, 'SCFS': 0};
  roarAB(state, {'AB': 47});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'SCFS': 1};
  roarAB(state, {'AB': 47});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip("ab 48 STORV", function(assert) {
});

// Note: sets A and B
QUnit.test("ab 49 W(67)→AB", function(assert) {
  var state = {'ROAR': 0x49c, 'W': 0};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 9};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 1); // B set

  state = {'ROAR': 0x49c, 'W': 6};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2); // A set

  state = {'ROAR': 0x49c, 'W': 7};
  roarAB(state, {'AB': 49, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 3); // A,B set
});

QUnit.test("ab 50 Z23≠0", function(assert) {
  state = {'ROAR': 0x49c, 'T': 0xffff0000};
  roarAB(state, {'AB': 50, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0, 'bits 0');

  state = {'ROAR': 0x49c, 'T': 0xffff0001};
  roarAB(state, {'AB': 50, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2, 'bits 1');

  state = {'ROAR': 0x49c, 'T': 0xffff8000};
  roarAB(state, {'AB': 50, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2, 'bits 1');
});


QUnit.test("ab 51 Z23≠0", function(assert) {
  state = {'ROAR': 0x49c, 'SDR': 0x00000001};
  roarAB(state, {'AB': 51, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0, 'nonzero');

  state = {'ROAR': 0x49c, 'SDR': 0x04000000};
  roarAB(state, {'AB': 51, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0, 'nonzero');

  state = {'ROAR': 0x49c, 'SDR': 0x01000000};
  roarAB(state, {'AB': 51, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0, 'nonzero');

  state = {'ROAR': 0x49c, 'SDR': 0x01008000};
  roarAB(state, {'AB': 51, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0, 'nonzero');

  state = {'ROAR': 0x49c, 'SDR': 0xf8ff0000};
  roarAB(state, {'AB': 51, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2, 'all zero');
});

QUnit.skip("ab 52 MXBIO", function(assert) {
});

QUnit.skip("ab 53 IBFULL", function(assert) {
});

QUnit.test("ab 54 CANG", function(assert) {
  state = {'ROAR': 0x49c, 'T': 0xfffffff8};
  roarAB(state, {'AB': 54, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0, 'address bits 0');

  state = {'ROAR': 0x49c, 'T': 0xfffffff4};
  roarAB(state, {'AB': 54, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2, 'address bit set');

  state = {'ROAR': 0x49c, 'T': 0xfffffff0, 'IAS': 1}; // Set invalid address stat
  roarAB(state, {'AB': 54, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip("ab 55 CHLOG", function(assert) {
});

// Sets A and B
QUnit.test("ab 56 I-FETCH", function(assert) {
  // off-bounds fetch (i.e. halfword, not word aligned)
  state = {'ROAR': 0x49c, 'IAR': 0x102, 'REFETCH': 0};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);

  // off-bounds refetch
  state = {'ROAR': 0x49c, 'IAR': 0x102, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 1);

  // on-bounds
  state = {'ROAR': 0x49c, 'IAR': 0x104, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2);

  // on-bounds
  state = {'ROAR': 0x49c, 'IAR': 0x105, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 2, 'IAS alignment should be ignored');

  // Invalid address
  state = {'ROAR': 0x49c, 'IAS': 1, 'REFETCH': 1};
  roarAB(state, {'AB': 56, 'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 3);
});

QUnit.test( "ab 57 IA(30)", function(assert) {
  var state = {'ROAR': 0x49c, 'IAR': 0x12340000};
  roarAB(state, {'AB': 57});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'IAR': 0x12340002};
  roarAB(state, {'AB': 57});
  assert.equal(state['ROAR'], 0x49c | 2);
});

QUnit.skip("ab 58 EXT,CHIRPT", function(assert) {
});

// 59 not used?

QUnit.test("ab 60 PSS", function(assert) {
  var state = {'ROAR': 0x49c, 'PSS': 0};
  roarAB(state, {'AB': 60});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'PSS': 1, 'SS': 0, 'ESS': 1};
  roarAB(state, {'AB': 60});
  assert.equal(state['ROAR'], 0x49c | 2);
  assert.equal(state['PSS'], 0, 'PSS cleared');

  state = {'ROAR': 0x49c, 'PSS': 1, 'SS': 1, 'ESS': 0};
  roarAB(state, {'AB': 60});
  assert.equal(state['ROAR'], 0x49c | 2);
  assert.equal(state['PSS'], 1, 'PSS not cleared');
});

QUnit.skip("ab 61 IOS4", function(assert) {
});

QUnit.test("ab 63 RX,S0", function(assert) {
  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0], 'M': 0x4fffffff};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0], 'M': 0x40000000};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0], 'M': 0x40000000};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0, 'not taken: S');

  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0], 'M': 0xffffffff};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0, 'not taken: M');

  var state = {'ROAR': 0x49c, 'M': 0x30000000, 'S':[0]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0); // Not M:01, not S0
  state = {'ROAR': 0x49c, 'M': 0x70000000, 'S':[0]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0); // M:01, not S0
  state = {'ROAR': 0x49c, 'M': 0x70000000, 'S':[1]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 2); // M:01, S0
  state = {'ROAR': 0x49c, 'M': 0x90000000, 'S':[1]};
  roarAB(state, {'AB': 63});
  assert.equal(state['ROAR'], 0x49c | 0); // not M:01, S0
});
QUnit.test("bb 0 0", function(assert) {
  var state = {'ROAR': 0x49c};
  roarBB(state, {'BB': 0});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test("bb 1 1", function(assert) {
  var state = {'ROAR': 0x49c};
  roarBB(state, {'BB': 1});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 2 (S0)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 2});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [1, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 2});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 3 (S1)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 3});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 1, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 3});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 4 (S2)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 4});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 1, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 4});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 5 (S3)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 5});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 1, 0, 0, 0, 0]};
  roarBB(state, {'BB': 5});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 6 (S4)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 6});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 1, 0, 0, 0]};
  roarBB(state, {'BB': 6});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 7 (S5)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 7});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 1, 0, 0]};
  roarBB(state, {'BB': 7});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 8 (S6)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 8});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 1, 0]};
  roarBB(state, {'BB': 8});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 9 (S7)", function(assert) {
  var state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  roarBB(state, {'BB': 9});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'S': [0, 0, 0, 0, 0, 0, 0, 1]};
  roarBB(state, {'BB': 9});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 10 RSGNS", function(assert) {
  var state = {'ROAR': 0x49c, 'RSGNS': 0};
  roarBB(state, {'BB': 10});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'RSGNS': 1};
  roarBB(state, {'BB': 10});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 11: HSCH

QUnit.test("bb 12 EXC", function(assert) {
  var state = {'ROAR': 0x49c, 'EXC': 0};
  roarBB(state, {'BB': 12});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'EXC': 1};
  roarBB(state, {'BB': 12});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 13 WR=0", function(assert) {
  var state = {'ROAR': 0x49c, 'WR': 1};
  roarBB(state, {'BB': 13});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'WR': 0};
  roarBB(state, {'BB': 13});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 14 unused

// Inexplicably, T13=0 seems to mean T bits 8 to 31 are 0 (i.e. fraction in a float)
QUnit.test( "bb 15 (T13=0)", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0x00800000};
  roarBB(state, {'BB': 15});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T': 0x00000001};
  roarBB(state, {'BB': 15});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T': 0xff000000};
  roarBB(state, {'BB': 15});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 16 T(0)", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0x80000000};
  roarBB(state, {'BB': 16});
  assert.equal(state['ROAR'], 0x49c | 1);
  state = {'ROAR': 0x49c, 'T': 0x7fffffff};
  roarBB(state, {'BB': 16});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test( "bb 17 T=0", function(assert) {
  var state = {'ROAR': 0x49c, 'T': 0};
  roarBB(state, {'BB': 17});
  assert.equal(state['ROAR'], 0x49c | 1);
  state = {'ROAR': 0x49c, 'T': 1};
  roarBB(state, {'BB': 17});
  assert.equal(state['ROAR'], 0x49c | 0);
});

QUnit.test("bb 18 TZ*BS", function(assert) {
  // Negative cases
  var state = {'ROAR': 0x49c, 'T': 0x05000000, 'BS': [1, 0, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00800000, 'BS': [0, 1, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00001000, 'BS': [1, 0, 1, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  var state = {'ROAR': 0x49c, 'T': 0x00000004, 'BS': [1, 1, 1, 1]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 0);

  // Positive cases
  var state = {'ROAR': 0x49c, 'T': 0x00ffffff, 'BS': [1, 0, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xff00ffff, 'BS': [0, 1, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xffff00ff, 'BS': [0, 0, 1, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xffffff00, 'BS': [0, 0, 0, 1]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);

  var state = {'ROAR': 0x49c, 'T': 0xffffffff, 'BS': [0, 0, 0, 0]};
  roarBB(state, {'BB': 18});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 19 W=1", function(assert) {
  var state = {'ROAR': 0x49c, 'W': 0}
  roarBB(state, {'BB': 19});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 7}
  roarBB(state, {'BB': 19});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'W': 1}
  roarBB(state, {'BB': 19});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 20 LB=0", function(assert) {
  var state = {'ROAR': 0x49c, 'LB': 1}
  roarBB(state, {'BB': 20});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'LB': 0}
  roarBB(state, {'BB': 20});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 21 LB=3", function(assert) {
  var state = {'ROAR': 0x49c, 'LB': 1}
  roarBB(state, {'BB': 21});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'LB': 0}
  roarBB(state, {'BB': 21});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'LB': 3}
  roarBB(state, {'BB': 21});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 22 MD=0", function(assert) {
  var state = {'ROAR': 0x49c, 'MD': 1}
  roarBB(state, {'BB': 22});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'MD': 0}
  roarBB(state, {'BB': 22});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 23 G2=0", function(assert) {
  var state = {'ROAR': 0x49c, 'G2': 1}
  roarBB(state, {'BB': 23});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2': 0}
  roarBB(state, {'BB': 23});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 24 G2<0", function(assert) {
  var state = {'ROAR': 0x49c, 'G2NEG': 0}
  roarBB(state, {'BB': 24});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2NEG': 1}
  roarBB(state, {'BB': 24});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 25 G2LBZ", function(assert) {
  var state = {'ROAR': 0x49c, 'G2': 1, 'LB': 1}
  roarBB(state, {'BB': 25});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'G2': 0, 'LB': 1}
  roarBB(state, {'BB': 25});
  assert.equal(state['ROAR'], 0x49c | 1);
  state = {'ROAR': 0x49c, 'G2': 1, 'LB': 0}
  roarBB(state, {'BB': 25});
  assert.equal(state['ROAR'], 0x49c | 1);
});

// 26 I/O

QUnit.test( "bb 27 (MD/JI)", function(assert) {
  var state = {'ROAR': 0x49c, 'MD': 2, 'J': 4}; // FP register # must be 0, 2, 4, 6
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'MD': 2, 'J': 5};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 1);

  state = {'ROAR': 0x49c, 'MD': 2, 'J': 8};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 1);

  state = {'ROAR': 0x49c, 'MD': 1, 'J': 4};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 1);

  state = {'ROAR': 0x49c, 'MD': 12, 'J': 4};
  roarBB(state, {'BB': 27});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test("bb 28 IVA", function(assert) {
  var state = {'ROAR': 0x49c, 'SAR': 0x102};
  roarBB(state, {'BB': 28});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'SAR': 0x101};
  roarBB(state, {'BB': 28});
  assert.equal(state['ROAR'], 0x49c | 0, 'ignore SAR value');

  state = {'ROAR': 0x49c, 'SAR': 0x101, 'IAS': 1};
  roarBB(state, {'BB': 28});
  assert.equal(state['ROAR'], 0x49c | 1, 'Invalid Address Stat');
});

// 29 I/O

QUnit.test( "bb 30 (CAR)", function(assert) {
  var state = {'ROAR': 0x49c, 'CAR': 0};
  roarBB(state, {'BB': 30});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'CAR': 1};
  roarBB(state, {'BB': 30});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "bb 31 (Z00)", function(assert) {
  var state = {'ROAR': 0x49c, 'T0': 0x7fffffff};
  roarBB(state, {'BB': 31});
  assert.equal(state['ROAR'], 0x49c | 0);
  state = {'ROAR': 0x49c, 'T0': 0x80000000};
  roarBB(state, {'BB': 31});
  assert.equal(state['ROAR'], 0x49c | 1);
});

QUnit.test( "roar ZN 1 SMIF", function(assert) {
  var state = {};
  roar(state, {'ZP': 0x12, 'ZF': 0x7, 'ZN': 1});
  assert.equal(state['ROAR'], 0x49c);
});

QUnit.test( "roar AB 56 I-FETCH", function(assert) {
  var state = {'ROAR': 0x49c, 'IAR': 0x12340000, 'REFETCH': 0}; // word aligned (on-bounds), no refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'IAR': 0x12340000, 'REFETCH': 1}; // word aligned (on-bounds), refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'IAR': 0x12340002, 'REFETCH': 0}; // halfword aligned (off-bounds), no refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 0);

  state = {'ROAR': 0x49c, 'IAR': 0x12340002, 'REFETCH': 1}; // halfword aligned (off-bounds), refetch
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 1);

  state = {'ROAR': 0x49c, 'IAR': 0x12340001, 'REFETCH': 0}; // alignment exception in IAR ignored
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 2);

  state = {'ROAR': 0x49c, 'IAR': 0x12340001, 'REFETCH': 0, 'IAS': 1}; // alignment exception stat
  roarAB(state, {'AB': 56});
  assert.equal(state['ROAR'], 0x49c | 3);
});

// ----------- SS tests

// SS 1, 2: unused

QUnit.test( "stat SS 3 D→CR*BS", function(assert) {
  var state = {'SAR': 0x30, 'MS': {}, 'BS': [1, 0, 0, 0]};
  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 0 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x71234567; // Leftmost bit of byte 0 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

  state = {'SAR': 0x30, 'MS': {}, 'BS': [0, 1, 0, 0]};
  state['MS'][0x30] = 0x81a34567; // Leftmost bit of byte 1 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 1 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

  state = {'SAR': 0x30, 'MS': {}, 'BS': [0, 0, 1, 0]};
  state['MS'][0x30] = 0x8123c567; // Leftmost bit of byte 2 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 2 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

  state = {'SAR': 0x30, 'MS': {}, 'BS': [0, 0, 0, 1]};
  state['MS'][0x30] = 0x812345f7; // Leftmost bit of byte 3 set
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 1);

  state['MS'][0x30] = 0x81234567; // Leftmost bit of byte 3 clear
  stat(state, {'SS': 3});
  assert.equal(state['CR'], 0);

});

QUnit.skip( "stat SS 4 E→SCANCTL", function(assert) {
});

QUnit.test( "stat SS 5 L,RSGNS", function(assert) {
  for (var i = 0; i < 16; i++) {
    var state = {'U': 0x40 | i}; // 4 is arbitrary
    if (i < 10) {
      assert.throws(function() { stat(state, {'SS': 5})});
    } else if (i == 0xb || i == 0xd) {
      stat(state, {'SS': 5});
      assert.equal(state['LSGNS'], 1, 'LSGNS ' + i, i); // Negative
      assert.equal(state['RSGNS'], 1, 'RSGNS ' + i, i); // Flipped
    } else {
      stat(state, {'SS': 5});
      assert.equal(state['LSGNS'], 0, 'LSGNS ' + i, i); // Positive
      assert.equal(state['RSGNS'], undefined, 'RSGNS ' + i, i); // Unchanged
    }
  }
});

QUnit.test( "stat SS 6 IVD/RSGNS", function(assert) {
  for (var i = 0; i < 16; i++) {
    var state = {'RSGNS': 1, 'U': 0x40 | i}; // 4 is arbitrary
    if (i < 10) {
      assert.throws(function() { stat(state, {'SS': 6})});
    } else if (i == 0xb || i == 0xd) {
      stat(state, {'SS': 6});
      assert.equal(state['RSGNS'], 0, i); // Cleared
    } else {
      stat(state, {'SS': 6});
      assert.equal(state['RSGNS'], 1, i); // Unchanged
    }
  }
});

QUnit.test( "stat SS 7 EDITSGN", function(assert) {
  for (let wr = 0; wr < 16; wr++) {
    var state = {'LSGNS': 1, 'WR': wr};
    stat(state, {'SS': 7});
    if (wr > 9) {
      assert.equal(state['RSGNS'], 1, 'RSGNS set ' + wr);
    } else {
      assert.equal(state['RSGNS'], 0, 'RSGNS clear ' + wr);
    }
    if (wr == 10 || wr == 12 || wr == 14 || wr == 15) {
      assert.equal(state['LSGNS'], 0, 'LSGNS clear ' + wr);
    } else {
      assert.equal(state['LSGNS'], 1, 'LSGNS stays set ' + wr);
    }
  }
});

QUnit.test( "stat8 E→S03", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 3, 'SS': 8});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat9 S03ΩE,1→LSGN", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 3, 'SS': 9});
  assert.deepEqual(state['S'], [1, 0, 1, 1, 0, 0, 0, 1]);
  assert.equal(state['LSGNS'], 1);
});

QUnit.test( "stat10 S03ΩE", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 3, 'SS': 10});
  assert.deepEqual(state['S'], [1, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat11 S03ΩE,0→BS", function(assert) {
  var state = {'S': [1, 0, 0, 1, 0, 0, 0, 1], 'BS': []};
  stat(state, {'CE': 3, 'SS': 11});
  assert.deepEqual(state['S'], [1, 0, 1, 1, 0, 0, 0, 1]);
  assert.deepEqual(state['pending']['BS'], [0, 0, 0, 0]);
});

QUnit.test( "stat12: X0,B0,1SYL", function(assert) {
  // X=0, B=0
  var state = {'T': 0x12300678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 1); // X=0, i.e. T(12-15)
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=0
  state = {'T': 0x12340678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15)
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=5
  state = {'T': 0x12345678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 0); // X!=0, i.e. T(12-15)
  assert.equal(state['S'][1], 0); // B!=0, i.e. T(0-3)

  // X=0, B=5
  state = {'T': 0x12305678, 'S': []};
  stat(state, {'SS': 12});
  assert.equal(state['S'][0], 1); // X=0, i.e. T(12-15)
  assert.equal(state['S'][1], 0); // B=0, i.e. T(0-3)

  // Now test 1SYL
  for (var i = 0; i < 16; i++) {
    state = {'T': i << 12, 'S': []};
    stat(state, {'SS': 12});
    if (i <= 3) {
      assert.equal(state['1SYL'], 1, "1sil " + i);
    } else {
      assert.equal(state['1SYL'], 0, "1sil " + i);
    }
  }
});

// Tests if value is floating point zero (ignoring sign, exponent)
QUnit.test( "stat SS 13: FPZERO", function(assert) {
  testFpzero(13, assert);
});

function testFpzero(ss, assert) {
  var state = {'T': 0x12000000, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 1, 'latch 0, F zero, stat 3 on');

  var state = {'T': 0x82000000, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 1, 'latch 0, F zero, stat 3 on');

  var state = {'T': 0x00000000, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 1, 'latch 0, F zero, stat 3 on');

  var state = {'T': 0x00000001, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 0, 'latch 1, F zero, stat 3 on: off');

  var state = {'T': 0x00800000, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 0, 'latch 1, F zero, stat 3 on: off');

  var state = {'T': 0xff000001, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 0, 'latch 1, F zero, stat 3 on: off');

  var state = {'T': 0x00000000, 'S': [undefined, 0, 0, 1, 0, 0, 0, 0], 'F': 1}; // Need F=0
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 0, 'latch 0, F 1, stat 3 on: off');

  var state = {'T': 0x00000000, 'S': [undefined, 0, 0, 0, 0, 0, 0, 0], 'F': 0}; // Need S3
  stat(state, {'SS': ss});
  assert.equal(state['S'][0], 0, 'latch 0, F 0, stat 3 off: off');
};

QUnit.test( "stat SS 14: FPZERO,E→FN", function(assert) {
  testFpzero(14, assert);

  var state = {'T': 0x00000001, 'S': [0, 0, 0, 0, 0, 0, 0, 0], 'F': 0};
  stat(state, {'SS': 14, 'CE': 7});
  assert.equal(state['FN'], 3);
});

QUnit.test( "stat15: B0,1SYL", function(assert) {
  // X=0, B=0
  var state = {'T': 0x02305678, 'S': [undefined, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], undefined, 'stat 0 unchanged');
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=0
  var state = {'T': 0x02340678, 'S': [undefined, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], undefined, 'stat 0 unchanged');
  assert.equal(state['S'][1], 1); // B=0, i.e. T(0-3)

  // X=4, B=5
  var state = {'T': 0x12345678, 'S': [undefined, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], undefined, 'stat 0 unchanged');
  assert.equal(state['S'][1], 0, 'X=4,B=5:S1'); // B!=0, i.e. T(0-3)

  // X=0, B=5
  var state = {'T': 0x12305678, 'S': [undefined, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 15});
  assert.equal(state['S'][0], undefined, 'stat 0 unchanged');
  assert.equal(state['S'][1], 0, 'X=0,B=5:S1'); // B=0, i.e. T(0-3)

  // Now test 1SYL
  for (var i = 0; i < 16; i++) {
    state = {'T': i << 12, 'S': []};
    stat(state, {'SS': 15});
    if (i <= 3) {
      assert.equal(state['1SYL'], 1);
    } else {
      assert.equal(state['1SYL'], 0);
    }
  }
});

QUnit.test( "stat16: S03.¬E", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 6, 'SS': 16});
  assert.deepEqual(state['S'], [0, 0, 0, 1, 0, 0, 0, 1]);

  state = {'S': [1, 1, 1, 1, 1, 1, 1, 1]};
  stat(state, {'CE': 15, 'SS': 16});
  assert.deepEqual(state['S'], [0, 0, 0, 0, 1, 1, 1, 1]);
});

QUnit.test( "stat SS 17: (T=0)→S3", function(assert) {
  var state = {'S': [0, 0, 0, 0, 0, 0, 0, 0], 'T': 0};
  stat(state, {'SS': 17});
  assert.equal(state['S'][3], 1);
});

QUnit.test( "stat18: E→BS,T30→S3", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1], 'T': 0, 'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 6, 'SS': 18});
  assert.deepEqual(state['pending']['BS'], [0, 1, 1, 0]);
  assert.deepEqual(state['S'], [0, 0, 1, 0, 0, 0, 0, 1]);

  state = {'S': [0, 0, 1, 1, 0, 0, 0, 1], 'T': 2, 'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 15, 'SS': 18});
  assert.deepEqual(state['pending']['BS'], [1, 1, 1, 1]);
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat SS 19: E→BS", function(assert) {
  var state = {'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 15, 'SS': 19});
  assert.deepEqual(state['pending']['BS'], [1, 1, 1, 1]);

  var state = {'BS': [0, 0, 0, 0]};
  stat(state, {'CE': 3, 'SS': 19});
  assert.deepEqual(state['pending']['BS'], [0, 0, 1, 1]);
});

QUnit.test( "stat20: 1→BS*MB", function(assert) {
  var state = {'BS': [0, 0, 0, 0,], 'MB': 2};
  stat(state, {'SS': 20});
  assert.equal(state['pending']['BS'][2], 1);
});

// SS 21: unused

// SS 22: unused

QUnit.skip( "stat SS 23: MANUAL→STOP", function(assert) {
});

QUnit.test( "stat24: E→S47", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 6, 'SS': 24});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 1, 1, 0]);
});

QUnit.test( "stat25: S47ΩE", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 0, 1]};
  stat(state, {'CE': 6, 'SS': 25});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 1, 1, 1]);
});

QUnit.test( "stat26: S47.¬E", function(assert) {
  var state = {'S': [0, 0, 1, 1, 0, 0, 1, 1]};
  stat(state, {'CE': 6, 'SS': 26});
  assert.deepEqual(state['S'], [0, 0, 1, 1, 0, 0, 0, 1]);
});

QUnit.test( "stat SS 27: S47,ED*FP", function(assert) {
  // SS 27 is complex. It is implemented in adderT() because it deals with the adder and carries.

  /* Set Stats 4-7 and exponent difference reg for floating point as follows.
   * Stat 4 turned on if:
   *    Stat 0 or Stat 1 is on and right adder input bit 0 is one and there is a carry out of position 1. [This should be no carry out.]
   *  or
   *    Stat 0 or Stat 1 is on, there is a carry out of position 1, and either left adder input bit 0 is one or stat 1 is on but not both (add type, result minus)
   *  or
   *    Both Stat 0 and Stat 1 are off and left adder input bit 0 is not equal to right adder input bit 0 (multiply or divide, signs unlike).
   * Absence of turn on condition causes stat to be turned off.
   */
  // The idea is sort of that the exponents are subtracted to determine the larger, and stat 4 (normal sign) should match the sign of the larger argument.
  // But there is also true vs complement addition, so recomplementing may flip the sign. So the pattern is not obvious.

  // Note that the XG values are subtracted; we complement them here because we're bypassing the TC complement step.
  neg = x => (~x & 0xffffffff) >>> 0; // 32-bit negation

  var state = {'XG':  neg(0x45000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // positive + positive, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,+ add');

  var state = {'XG':  neg(0xc5000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // negative + positive, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,+ add');

  var state = {'XG':  neg(0x45000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // positive + negative, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,- add');

  var state = {'XG':  neg(0xc5000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // negative + negative, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,- add');

  var state = {'XG':  neg(0x46000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // positive + positive, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,+ add');

  var state = {'XG':  neg(0xc6000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // negative + positive, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,+ add');

  var state = {'XG':  neg(0x46000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // positive + negative, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,- add');

  var state = {'XG':  neg(0xc6000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // negative + negative, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,- add');

  var state = {'XG':  neg(0x44000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // positive + positive, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,+ add');

  var state = {'XG':  neg(0xc4000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // negative + positive, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,+ add');

  var state = {'XG':  neg(0x44000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // positive + negative, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,- add');

  var state = {'XG':  neg(0xc4000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [1, 0, 0, 0]}; // negative + negative, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,- sub');

  var state = {'XG':  neg(0x45000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // positive - positive, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,+ sub');

  var state = {'XG':  neg(0xc5000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // negative - positive, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,+ sub');

  var state = {'XG':  neg(0x45000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // positive - negative, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,- sub');

  var state = {'XG':  neg(0xc5000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // negative - negative, exponents equal
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,- sub');

  var state = {'XG':  neg(0x46000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // positive - positive, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,+ sub');

  var state = {'XG':  neg(0xc6000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // negative - positive, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,+ sub');

  var state = {'XG':  neg(0x46000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // positive - negative, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,- sub');

  var state = {'XG':  neg(0xc6000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // negative - negative, left exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,- sub');

  var state = {'XG':  neg(0x44000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // positive - positive, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,+ sub');

  var state = {'XG':  neg(0xc4000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // negative - positive, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,+ sub');

  var state = {'XG':  neg(0x44000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // positive - negative, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,- sub');

  var state = {'XG':  neg(0xc4000000), 'Y': 0xc5000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // negative - negative, right exponent larger
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,- sub');

  var state = {'XG':  neg(0x44000000), 'Y': 0x44000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // positive * positive
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '+,+ mult');

  var state = {'XG':  neg(0xc4000000), 'Y': 0x44000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // negative * positive
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '-,+ mult');

  var state = {'XG':  neg(0x44000000), 'Y': 0xc4000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // positive * negative
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 1, '+,- mult');

  var state = {'XG':  neg(0xc4000000), 'Y': 0xc4000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // negative * negative
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][4], 0, '-,- mult');

    // Stat 5 turned on if left adder input bit 0, right adder input bit 0 and Stat 1 contain an even number of ones. (True add required).

  var state = {'XG':  neg(0x44000000), 'Y': 0x44000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 0, 0, 0
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][5], 1, 'stat 5');

  var state = {'XG':  neg(0xc4000000), 'Y': 0x44000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 1, 0, 0
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][5], 0, 'stat 5');

  var state = {'XG':  neg(0x44000000), 'Y': 0xc4000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 0, 1, 0
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][5], 0, 'stat 5');

  var state = {'XG':  neg(0x44000000), 'Y': 0x44000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // 0, 0, 1
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][5], 0, 'stat 5');

  var state = {'XG':  neg(0xc4000000), 'Y': 0xc4000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 1, 1, 0
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][5], 1, 'stat 5');

  var state = {'XG':  neg(0xc4000000), 'Y': 0xc4000000, 'CIN': 0, 'F': 0, S: [0, 1, 0, 0]}; // 1, 1, 1
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][5], 0, 'stat 5');

   /*
     * Exponent difference reg set as follows:
     *  Bit 0 set to one if carry from adder pos 1 and sum bits 1-4 non zero, or if no carry from pos 1 and sum bits 1-4 equal 1111.
     *  Bits 1-3 set equal to adder sum bits 5-7.
     */
    // Stat 6 turned on if value of exponent difference reg is less than 16 (dec) in absolute value.
    // This is a bit unclear since the exponent difference reg is 4 bits so it must be less than 16.
    // I'm assuming they mean the absolute value of the exponent difference (not the register) is less than 16.
  var state = {'XG':  neg(0x10000000), 'Y': 0x10000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 10, 10
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][6], 1, 'stat 6');

  var state = {'XG':  neg(0x10000000), 'Y': 0x1f000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 10, 1f
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][6], 1, 'stat 6');

  var state = {'XG':  neg(0x1f000000), 'Y': 0x10000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 1f, 10
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][6], 1, 'stat 6');

  var state = {'XG':  neg(0x10000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 10, 20
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][6], 0, 'stat 6');

  var state = {'XG':  neg(0x20000000), 'Y': 0x10000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 20, 10
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][6], 0, 'stat 6');

  var state = {'XG':  neg(0x00000000), 'Y': 0xff000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 00, ff
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][6], 0, 'stat 6');

    // Stat 7 turned on if value of exponent difference reg is zero.
  var state = {'XG':  neg(0x80000000), 'Y': 0x00ffffff, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 0, 0 (with other bits different)
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][7], 1, 'stat 7');

  var state = {'XG':  neg(0x7fffffff), 'Y': 0xff000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 7f, 7f
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][7], 1, 'stat 7');

  var state = {'XG':  neg(0x00000000), 'Y': 0x01000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 00, 01
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][7], 0, 'stat 7');

  var state = {'XG':  neg(0x00000000), 'Y': 0x02000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 00, 01
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][7], 0, 'stat 7');

  var state = {'XG':  neg(0x00000000), 'Y': 0x40000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]}; // 00, 40
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['S'][7], 0, 'stat 7');

  // Tests of ED computation

  var state = {'XG': neg(0x20000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 0, 'ED 0');

  var state = {'XG': neg(0x21000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 15, 'ED -1');

  var state = {'XG': neg(0x27000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 9, 'ED -7');

  var state = {'XG': neg(0x28000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 8, 'ED -8');

  var state = {'XG': neg(0x2F000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 1, 'ED -15');

  var state = {'XG': neg(0x1F000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 1, 'ED 1');

  var state = {'XG': neg(0x11000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 15, 'ED 15');

  var state = {'XG': neg(0x91000000), 'Y': 0x20000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 15, 'ED 15, sign');

  var state = {'XG': neg(0x21000000), 'Y': 0x00000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 7, 'ED -33');

  var state = {'XG': neg(0x45000000), 'Y': 0x00000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 3, 'ED -0x45');

  var state = {'XG': neg(0x00000000), 'Y': 0x45000000, 'CIN': 0, 'F': 0, S: [0, 0, 0, 0]};
  adderT(state, {'AD': 6, 'SS': 27, 'AL': 23}); // BC1B: block carry from position 8, AL:23 forces hot 1 into position 7
  assert.equal(state['ED'], 13, 'ED 0x45');
});

QUnit.skip( "stat SS 28: OPPANEL→S47", function(assert) {
});

QUnit.test( "stat29: CAR,(T≠0)→CR", function(assert) {
  var state = {'CAR': 0, 'T': 0};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 0);
  state = {'CAR': 0, 'T': 0x10000};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 1);
  state = {'CAR': 1, 'T': 0};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 2);
  state = {'CAR': 1, 'T': 0xffffffff};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 3);
});

QUnit.test( "stat30: KEY→F", function(assert) {
  var state = {'SAR': 0x12345670, 'KEYS': {}};
  state['KEYS'][0x12345670 & 0x00fff100] = 4;
  stat(state, {'SS': 30});
  assert.equal(state['F'], 4);
});

QUnit.test( "stat31: F→KEY", function(assert) {
  var state = {'F': 4, 'SAR': 0x12345670, 'KEYS': {}};
  stat(state, {'SS': 31});
  assert.equal(state['KEYS'][0x12345670 & 0x00fff100], 4);
});

QUnit.skip( "stat SS 28: OPPANEL→S47", function(assert) {
});

QUnit.test( "stat29: CAR,(T≠0)→CR", function(assert) {
  var state = {'CAR': 0, 'T': 0};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 0);
  state = {'CAR': 0, 'T': 0x10000};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 1);
  state = {'CAR': 1, 'T': 0};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 2);
  state = {'CAR': 1, 'T': 0xffffffff};
  stat(state, {'CE': 6, 'SS': 29});
  assert.deepEqual(state['CR'], 3);
});

QUnit.test( "stat30: KEY→F", function(assert) {
  var state = {'SAR': 0x12345670, 'KEYS': {}};
  state['KEYS'][0x12345670 & 0x00fff100] = 4;
  stat(state, {'SS': 30});
  assert.equal(state['F'], 4);
});

QUnit.test( "stat31: F→KEY", function(assert) {
  var state = {'F': 4, 'SAR': 0x12345670, 'KEYS': {}};
  stat(state, {'SS': 31});
  assert.equal(state['KEYS'][0x12345670 & 0x00fff100], 4);
});

QUnit.test( "stat32: 1→LSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 32});
  assert.deepEqual(state['LSGNS'], 1);
});

QUnit.test( "stat33: 0→LSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 33});
  assert.deepEqual(state['LSGNS'], 0);
});

QUnit.test( "stat34: 1→RSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 34});
  assert.deepEqual(state['RSGNS'], 1);
});

QUnit.test( "stat35: 0→RSGNS", function(assert) {
  var state = {};
  stat(state, {'SS': 35});
  assert.deepEqual(state['RSGNS'], 0);
});

QUnit.test( "stat36: L(0)→LSGNS", function(assert) {
  var state = {'L': 0x76543210};
  stat(state, {'SS': 36});
  assert.deepEqual(state['LSGNS'], 0);
  state = {'L': 0x86543210};
  stat(state, {'SS': 36});
  assert.deepEqual(state['LSGNS'], 1);
});

QUnit.test( "stat37: R(0)→RSGNS", function(assert) {
  var state = {'R': 0x76543210};
  stat(state, {'SS': 37});
  assert.deepEqual(state['RSGNS'], 0);
  state = {'R': 0x86543210};
  stat(state, {'SS': 37});
  assert.deepEqual(state['RSGNS'], 1);
});

QUnit.test( "stat38: E(13)→WFN", function(assert) {
  var state = {};
  stat(state, {'SS': 38, 'CE': 0xe});
  assert.equal(state['WFN'], 6);
});

QUnit.test( "stat SS 39: E(23)→FN", function(assert) {
  var state = {};
  stat(state, {'SS': 39, 'CE': 0xe});
  assert.equal(state['FN'], 2);
});

QUnit.test( "stat SS 40: E(23)→CR", function(assert) {
  var state = {};
  stat(state, {'SS': 40, 'CE': 0xe});
  assert.equal(state['CR'], 2);
});

QUnit.test( "stat41: SETCRALG", function(assert) {
  var state = {'T': 0};
  stat(state, {'SS': 41, 'CE': 0xe});
  assert.equal(state['CR'], 0); // Zero

  state = {'T': 0x80000001};
  stat(state, {'SS': 41, 'CE': 0xe});
  assert.equal(state['CR'], 1); // Negative

  state = {'T': 0x7fffffff};
  stat(state, {'SS': 41, 'CE': 0xe});
  assert.equal(state['CR'], 2); // Positive
});

QUnit.test( "stat SS 42: SETCRLOG", function(assert) {
  var state = {'T': 0x00110022, 'BS': [1, 0, 1, 0], 'c0': 1};
  stat(state, {'SS': 42});
  assert.equal(state['CR'], 0); // Zero

  state = {'T': 0x00110022, 'BS': [1, 0, 1, 1], 'c0': 0};
  stat(state, {'SS': 42});
  assert.equal(state['CR'], 1); // First lower

  state = {'T': 0x00110022, 'BS': [0, 0, 0, 1], 'c0': 1};
  stat(state, {'SS': 42});
  assert.equal(state['CR'], 2); // First higher
});

QUnit.test( "stat SS 43: ¬S4,S4→CR", function(assert) {
  var state = {'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 43});
  assert.equal(state['CR'], 2);

  var state = {'S': [0, 0, 0, 0, 1, 0, 0, 0]};
  stat(state, {'SS': 43});
  assert.equal(state['CR'], 1);
});

QUnit.test( "stat SS 44: S4,¬S4→CR", function(assert) {
  var state = {'S': [0, 0, 0, 0, 0, 0, 0, 0]};
  stat(state, {'SS': 44});
  assert.equal(state['CR'], 1);

  var state = {'S': [0, 0, 0, 0, 1, 0, 0, 0]};
  stat(state, {'SS': 44});
  assert.equal(state['CR'], 2);
});

QUnit.test( "stat SS 45: 1→REFETCH", function(assert) {
  var state = {};
  stat(state, {'SS': 45});
  assert.equal(state['REFETCH'], 1);
});

QUnit.skip( "stat SS 46: SYNC→OPPANEL", function(assert) {
});

QUnit.skip( "stat SS 47: SCAN*E,10", function(assert) {
});

// SS 48, 49: I/O

QUnit.skip( "stat SS 50: E(0)→IBFULL", function(assert) {
});

// SS 51: unused

QUnit.skip( "stat SS 52: E→CH", function(assert) {
});

// SS 53: unused

QUnit.skip( "stat SS 54: 1→TIMERIRPT", function(assert) {
});

// T to AMWP bits
QUnit.test( "stat55  T→PSW,IPL→T", function(assert) {
  var state = {'T': 0x12345678};
  stat(state, {'SS': 55});
  assert.equal(state['AMWP'], 4);
  assert.equal(state['T'], 0x0c000000); // Hardwored card reader IPl
});

// T to AMWP bits
QUnit.test( "stat56 T→PSW", function(assert) {
  var state = {'T': 0x123f5678};
  stat(state, {'SS': 56});
  assert.equal(state['AMWP'], 0xf);
});

QUnit.test( "stat57", function(assert) {
  // 57: SCAN*E00
  var state = {};
  stat(state, {'SS': 57, 'CE': 0x3});
  assert.equal(state['SCANCTRL'], 0x0c);
});

QUnit.skip( "stat SS 58: 1→IOMODE", function(assert) {
});

// SS 59-63: I/O

// ----- AL tests

// test shifter

QUnit.test("sr1", function(assert) {
  // Start with right field empty
  assert.deepEqual(sr1(0, 0x12345678, 0), [0x091a2b3c, 0]);
  assert.deepEqual(sr1(0, 0x12345679, 0), [0x091a2b3c, 8]);
  assert.deepEqual(sr1(1, 0x12345678, 0), [0x891a2b3c, 0]);
  assert.deepEqual(sr1(1, 0x12345679, 0), [0x891a2b3c, 8]);
  // Now with content in right field
  assert.deepEqual(sr1(0, 0x82345678, 3), [0x411a2b3c, 1]);
  assert.deepEqual(sr1(0, 0x82345679, 5), [0x411a2b3c, 0xa]);
  assert.deepEqual(sr1(1, 0x82345678, 8), [0xc11a2b3c, 4]);
  assert.deepEqual(sr1(1, 0x82345679, 0xf), [0xc11a2b3c, 0xf]);
});

QUnit.test("sl1", function(assert) {
  // Start with dest (left) field empty
  assert.deepEqual(sl1(0, 0x12345678, 0), [0x2468acf0, 0]);
  assert.deepEqual(sl1(0, 0x92345678, 0), [0x2468acf0, 1]);
  assert.deepEqual(sl1(8, 0x12345678, 0), [0x2468acf1, 0]);
  assert.deepEqual(sl1(8, 0x92345678, 0), [0x2468acf1, 1]);
  // Now with contents in dest field
  assert.deepEqual(sl1(0, 0x12345678, 0xf), [0x2468acf0, 0xe]);
  assert.deepEqual(sl1(0, 0x92345678, 0x8), [0x2468acf0, 1]);
  assert.deepEqual(sl1(8, 0x12345678, 0x5), [0x2468acf1, 0xa]);
  assert.deepEqual(sl1(8, 0x92345678, 0x2), [0x2468acf1, 5]);
});

QUnit.test("sr4", function(assert) {
  assert.deepEqual(sr4(0, 0x12345678), [0x01234567, 8]);
  assert.deepEqual(sr4(0xf, 0x12345673), [0xf1234567, 3]);
});

QUnit.test("sl4", function(assert) {
  assert.deepEqual(sl4(0x1, 0x12345678), [0x23456781, 1]);
  assert.deepEqual(sl4(0xf, 0x12345678), [0x2345678f, 1]);
  assert.deepEqual(sl4(0, 0xff345678), [0xf3456780, 0xf]);
});

QUnit.test( "al1 Q→SR1→F", function(assert) {
  var state = {'T0': 0x12345679, 'Q': 1, 'F': 5};
  adderAL(state, {'AL': 1, 'DG': 0});
  assert.equal(state['T'], (0x80000000 | (0x12345678 >> 1)) >>> 0);

  var state = {'T0': 0x12345678, 'Q': 0, 'F': 5};
  adderAL(state, {'AL': 1, 'DG': 0});
  assert.equal(state['T'], (0x00000000 | (0x12345678 >> 1)) >>> 0);
  assert.equal(state['F'], 0x2);
});

QUnit.test( "al 2 L0,¬S4→", function(assert) {
  var state = {'T0': 0x12345678, 'L': 0x78901234, 'S': {4: 0}};
  adderAL(state, {'AL': 2});
  assert.equal(state['T'], 0xf8345678);

  var state = {'T0': 0x12345678, 'L': 0x78901234, 'S': {4: 1}};
  adderAL(state, {'AL': 2});
  assert.equal(state['T'], 0x78345678);

  var state = {'T0': 0x12345678, 'L': 0xffffffff, 'S': {4: 1}};
  adderAL(state, {'AL': 2});
  assert.equal(state['T'], 0x7f345678);
});

QUnit.test( "al3 +SGN→", function(assert) {
  var state = {'T0': 0x12345678};
  adderAL(state, {'AL': 3});
  assert.equal(state['T'], 0x12345678);

  var state = {'T0': 0x92345678};
  adderAL(state, {'AL': 3});
  assert.equal(state['T'], 0x12345678);
});

QUnit.test( "al4 -SGN→", function(assert) {
  var state = {'T0': 0x92345678};
  adderAL(state, {'AL': 4});
  assert.equal(state['T'], 0x92345678);

  var state = {'T0': 0x12345678};
  adderAL(state, {'AL': 4});
  assert.equal(state['T'], 0x92345678);
});

QUnit.test( "al5 L0,S4→", function(assert) {
  var state = {'T0': 0x12345678, 'L': 0x78901234, 'S': {4: 0}};
  adderAL(state, {'AL': 5});
  assert.equal(state['T'], 0x78345678);

  var state = {'T0': 0x12345678, 'L': 0xf8901234, 'S': {4: 0}};
  adderAL(state, {'AL': 5});
  assert.equal(state['T'], 0x78345678);

  var state = {'T0': 0x12345678, 'L': 0x78901234, 'S': {4: 1}};
  adderAL(state, {'AL': 5});
  assert.equal(state['T'], 0xf8345678);

  var state = {'T0': 0x12345678, 'L': 0xffffffff, 'S': {4: 0}};
  adderAL(state, {'AL': 5});
  assert.equal(state['T'], 0x7f345678);
});

QUnit.test( "al6 IA→H", function(assert) {
  var state = {'IAR': 0x12345678, 'H': 0x98765432};
  adderAL(state, {'AL': 6});
  assert.equal(state['H'], 0x98345678);
});

QUnit.test( "al7 Q→SL→-F", function(assert) {
  var state = {'T0': 0x12345678, 'Q': 0, 'F': 0xf};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x2468acf0);
  assert.equal(state['F'], 0xf); // 0 inverted, shifted in

  state = {'T0': 0x92345678, 'Q': 0, 'F': 0xf};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x2468acf0);
  assert.equal(state['F'], 0xe);

  state = {'T0': 0x12345678, 'Q': 1, 'F': 0xf};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x2468acf1);
  assert.equal(state['F'], 0xf);

  state = {'T0': 0x80000000, 'Q': 1, 'F': 0x0};
  adderAL(state, {'AL': 7});
  assert.equal(state['T'], 0x00000001);
  assert.equal(state['F'], 0x0);
});

QUnit.test( "al8 Q→SL1→F", function(assert) {
  var state = {'Q': 0, 'T0': 0x72345678, 'F': 0xc}; // Shift 0 in, 0 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], (0x72345678 << 1) >>> 0);
  assert.equal(state['F'], 0x8); // 1100 -> 1000

  state = {'Q': 1, 'T0': 0x72345678, 'F': 0xc}; // Shift 1 in, 0 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], ((0x72345678 << 1) | 1) >>> 0);
  assert.equal(state['F'], 0x8);

  state = {'Q': 0, 'T0': 0x92345678, 'F': 0xc}; // Shift 0 in, 1 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], (0x92345678 << 1) >>> 0);
  assert.equal(state['F'], 0x9);

  state = {'Q': 1, 'T0': 0x92345678, 'F': 0xc}; // Shift 1 in, 1 out
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], ((0x92345678 << 1) | 1) >>> 0);
  assert.equal(state['F'], 0x9);

  state = {'T0': 0x80000000, 'Q': 1, 'F': 0x0};
  adderAL(state, {'AL': 8});
  assert.equal(state['T'], 0x00000001);
  assert.equal(state['F'], 0x1);
});

// Overflow bits from T spill into F, which is shifted into T.
QUnit.test( "al9 F→SL1→F", function(assert) {
  var state = {'T0': 0x92345678, 'F': 0xc};
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 1) | 1) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x9);
  state['T0'] = state['T'];
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 2) | 3) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x2);
  state['T0'] = state['T'];
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 3) | 6) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x4);
  state['T0'] = state['T'];
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], (((0x92345678 << 4) | 0xc) & 0xffffffff) >>> 0, state['T'].toString(16));
  assert.equal(state['F'], 0x9);

  var state = {'T0': 0x80000000, 'F': 0x8};
  adderAL(state, {'AL': 9});
  assert.equal(state['T'], 0x00000001);
  assert.equal(state['F'], 0x1);
});

QUnit.test( "al10 SL1→Q", function(assert) {
  var state = {'T0': 0x92345678};
  adderAL(state, {'AL': 10});
  assert.equal(state['T'], (0x92345678 << 1) & 0xffffffff, state['T'].toString(16));
  assert.equal(state['Q'], 0x1);

  var state = {'T0': 0x80000000, 'Q': 1};
  adderAL(state, {'AL': 10});
  assert.equal(state['T'], 0x00000000);
  assert.equal(state['Q'], 0x1);
});


QUnit.test( "al11 Q→SL1", function(assert) {
  var state = {'T0': 0x92345678, 'Q': 0};
  adderAL(state, {'AL': 11});
  assert.equal(state['T'], 0x2468acf0);

  state = {'T0': 0x92345678, 'Q': 1};
  adderAL(state, {'AL': 11});
  assert.equal(state['T'], 0x2468acf1);

  state = {'T0': 0x00000000, 'Q': 1};
  adderAL(state, {'AL': 11});
  assert.equal(state['T'], 0x00000001);
  assert.equal(state['Q'], 0x1);
});

QUnit.test( "al12 SR1→F", function(assert) {
  var state = {'T0': 0x12345679, 'F': 3};
  adderAL(state, {'AL': 12});
  assert.equal(state['T'], 0x12345679 >> 1);
  assert.equal(state['F'], 9);

  var state = {'T0': 0x00000001, 'F': 1};
  adderAL(state, {'AL': 12});
  assert.equal(state['T'], 0x00000000);
  assert.equal(state['F'], 8);
});

QUnit.test( "al13 SR1→Q", function(assert) {
  var state = {'T0': 0x12345679};
  adderAL(state, {'AL': 13});
  assert.equal(state['T'], 0x12345679 >> 1);
  assert.equal(state['Q'], 0x1);

  var state = {'T0': 0x00000001};
  adderAL(state, {'AL': 13});
  assert.equal(state['T'], 0x00000000);
  assert.equal(state['Q'], 0x1);
});

QUnit.test( "al14 Q→SR1→Q", function(assert) {
  var state = {'T0': 0x92345679, 'Q': 0};
  adderAL(state, {'AL': 14});
  assert.equal(state['T'], 0x491a2b3c);
  assert.equal(state['Q'], 0x1);

  var state = {'T0': 0x92345678, 'Q': 1};
  adderAL(state, {'AL': 14});
  assert.equal(state['T'], 0xc91a2b3c);
  assert.equal(state['Q'], 0x0);

  var state = {'T0': 0x00000000, 'Q': 1};
  adderAL(state, {'AL': 14});
  assert.equal(state['T'], 0x80000000);
  assert.equal(state['Q'], 0x0);
});

QUnit.test( "al15 F→SL1→Q", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x9, 'Q': 0};
  adderAL(state, {'AL': 15});
  assert.equal(state['F'], 0x2);
  assert.equal(state['T'], 0x2468acf1);
  assert.equal(state['Q'], 0x0);

  state = {'T0': 0x92345678, 'F': 0x7, 'Q': 0};
  adderAL(state, {'AL': 15});
  assert.equal(state['F'], 0xe);
  assert.equal(state['T'], 0x2468acf0);
  assert.equal(state['Q'], 0x1);

  state = {'T0': 0x80000000, 'F': 0x8, 'Q': 0};
  adderAL(state, {'AL': 15});
  assert.equal(state['F'], 0x0);
  assert.equal(state['T'], 0x00000001);
  assert.equal(state['Q'], 0x1);
});

QUnit.test( "al16 SL4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 16});
  assert.equal(state['T'], 0x23456780);
  assert.equal(state['F'], 0x1);

  var state = {'T0': 0xf0000000, 'F': 0x0};
  adderAL(state, {'AL': 16});
  assert.equal(state['T'], 0x00000000);
  assert.equal(state['F'], 0xf);
});

QUnit.test( "al17 F→SL4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 17});
  assert.equal(state['T'], 0x23456783);
  assert.equal(state['F'], 0x1);

  var state = {'T0': 0xe0000000, 'F': 0xf};
  adderAL(state, {'AL': 17});
  assert.equal(state['T'], 0x0000000f);
  assert.equal(state['F'], 0xe);
});

QUnit.test( "al18 FPSL4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0xf};
  adderAL(state, {'AL': 18});
  assert.equal(state['T'], 0x12456780); // Preserve sign, exponent top byte
  assert.equal(state['F'], 0xf);
  assert.equal(state['LB'], undefined);

  var state = {'T0': 0x98765432, 'F': 0xf};
  adderAL(state, {'AL': 18});
  assert.equal(state['T'], 0x98654320);
  assert.equal(state['F'], 0xf);
  assert.equal(state['LB'], undefined);
});

QUnit.test( "al19 F→FPSL4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 19});
  assert.equal(state['T'], 0x12456783);
  assert.equal(state['F'], 0x3);
  assert.equal(state['LB'], undefined);

  var state = {'T0': 0x98765432, 'F': 0x1};
  adderAL(state, {'AL': 19});
  assert.equal(state['T'], 0x98654321);
  assert.equal(state['F'], 0x1);
  assert.equal(state['LB'], undefined);
});

QUnit.test( "al20 SR4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 20});
  assert.equal(state['T'], 0x01234567);
  assert.equal(state['F'], 0x8);

  var state = {'T0': 0xf000000f, 'F': 0x3};
  adderAL(state, {'AL': 20});
  assert.equal(state['T'], 0x0f000000);
  assert.equal(state['F'], 0xf);
});

QUnit.test( "al21", function(assert) {
  // F->SR4->F
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 21});
  assert.equal(state['T'], 0x31234567);
  assert.equal(state['F'], 0x8);

  var state = {'T0': 0xf000000f, 'F': 0x3};
  adderAL(state, {'AL': 21});
  assert.equal(state['T'], 0x3f000000);
  assert.equal(state['F'], 0xf);
});

QUnit.test( "al22 FPSR4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 22});
  assert.equal(state['T'], 0x00034567);
  assert.equal(state['F'], 0x8);

  var state = {'T0': 0xffffffff, 'F': 0x3};
  adderAL(state, {'AL': 22});
  assert.equal(state['T'], 0x000fffff);
  assert.equal(state['F'], 0xf);
});

QUnit.test( "al23 1→FPSR4→F", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 23});
  assert.equal(state['T'], 0x12134567);
  assert.equal(state['F'], 0x8);

  // Test hot carry into AD6
  var state = {'XG': 0x12345678, 'AUX': 0, 'Y': 0x00f00000, 'CIN': 0};
  adderT(state, {'AD': 6});
  assert.equal(state['T0'], 0x12245678, 'sum: no hot carry');
  adderT(state, {'AD': 6, 'AL': 23});
  assert.equal(state['T0'], 0x13245678, 'sum: hot carry');
});

QUnit.test( "al24 SR4→H", function(assert) {
  var state = {'T0': 0x12345678, 'R': 0x98765432, 'H': 0x24681357};
  adderAL(state, {'AL': 24});
  assert.equal(state['T'], 0x01234567);
  assert.equal(state['H'], 0x84681357);
  assert.equal(state['R'], 0x18765432);
});

QUnit.test( "al25 F→SR4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 25});
  assert.equal(state['T'], 0x31234567);
  assert.equal(state['F'], 0x3);

  var state = {'T0': 0x00000000, 'F': 0xf};
  adderAL(state, {'AL': 25});
  assert.equal(state['T'], 0xf0000000);
  assert.equal(state['F'], 0xf);
});

QUnit.test( "al26 E→FPSL4", function(assert) {
  var state = {'T0': 0x12345678, 'F': 0x3};
  adderAL(state, {'AL': 26, 'CE': 0x4});
  assert.equal(state['T'], 0x12456784);
  assert.equal(state['F'], 0x3);
  assert.equal(state['LB'], undefined);

  var state = {'T0': 0xff00000f, 'F': 0x3};
  adderAL(state, {'AL': 26, 'CE': 0xa});
  assert.equal(state['T'], 0xff0000fa);
  assert.equal(state['F'], 0x3);
  assert.equal(state['LB'], undefined);
});

QUnit.test( "al26 E→FPSL4 0", function(assert) {
  var state = {'T0': 0x12045678, 'F': 0x3};
  adderAL(state, {'AL': 26, 'CE': 0x4});
  assert.equal(state['T'], 0x12456784);
  assert.equal(state['F'], 0x3);
  assert.equal(state['LB'], undefined);
});

QUnit.test( "al27 F→SR1→Q", function(assert) {
  var state = {'T0': 0x92345678, 'F': 0};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0x491a2b3c);
  assert.equal(state['Q'], 0);
  assert.equal(state['F'], 0);

  state = {'T0': 0x92345679, 'F': 0xe};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0x491a2b3c);
  assert.equal(state['Q'], 1);
  assert.equal(state['F'], 0xe);

  var state = {'T0': 0x92345678, 'F': 3};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0xc91a2b3c);
  assert.equal(state['Q'], 0);
  assert.equal(state['F'], 3);

  var state = {'T0': 0x00000001, 'F': 0x1};
  adderAL(state, {'AL': 27});
  assert.equal(state['T'], 0x80000000);
  assert.equal(state['Q'], 1);
  assert.equal(state['F'], 1);
});

QUnit.skip( "al28 DKEY→", function(assert) {
});

// al 29 is I/O

QUnit.test( "al30 D→", function(assert) {
  var state = {'SAR': 0x30};
  state['MS'] = [];
  state['MS'][0x30] = 0x12345678;
  adderAL(state, {'AL': 30, 'CE': 0x4});
  assert.equal(state['T'], 0x12345678);
});

QUnit.skip( "al31 AKEY→", function(assert) {
});

</script>
</body>
</html>
