#include "catch.hpp"
#include "engine.hpp"

// Helper to call all the adder routines
void adder(state_t &state, entry_t &entry) {
  adderLX(state, entry);
    adderRY(state, entry);
    adderDG(state, entry);
    adderT(state, entry);
}

TEST_CASE( "adder") {
  state_t state = {"L": 0x12345678, "R": 0x23456789};
  entry_t entry = {"LX": 1 /* L */, "RY": 1 /* R */, "TC": 1 /* add */, "AD": 1 /* default op */, "AL": 0 /* shift */, "DG": 0 /* default */};
  adder(state, entry);
  REQUIRE( state.T0 == 0x12345678 + 0x23456789);
}

TEST_CASE( "adder2") {
  state_t state = {"L": 0x1234, "H": 0x1233};
  entry_t entry = {"LX": 1 /* L */, "RY": 4 /* H */, "TC": 0 /* sub */, "AD": 1 /* default op */, "AL": 0 /* shift */, "DG": 0 /* default */};
  adder(state, entry);
  REQUIRE( state.T0 == 0xfffffffe); // H - L, 1"s complement
}

TEST_CASE( "adder3") {
  state_t state = {"M": 0x12345678};
  entry_t entry = {"CE": 0x1234, "LX": 3 /* E */, "RY": 3 /* M23 */, "TC": 1 /* add */, "AD": 1 /* default op */, "AL": 0 /* shift */, "DG": 0 /* default */};
  adder(state, entry);
  REQUIRE( state.T0 == (0x1234 << 1) + 0x5678);
}

TEST_CASE( "adder lx 0 0") {
  state_t state = {"L": 0x12345678};
  entry_t entry = {"LX": 0};
  adderLX(state, entry);
  REQUIRE( state.XG == 0);
}

TEST_CASE( "adder lx 1 L") {
  state_t state = {"L": 0x12345678};
  entry_t entry = {"LX": 1};
  adderLX(state, entry);
  REQUIRE( state.XG == 0x12345678);
}

TEST_CASE( "adder lx 2 SGN") {
  state_t state = {"L": 0x12345678};
  entry_t entry = {"LX": 2};
  adderLX(state, entry);
  REQUIRE( state.XG == 0x80000000);
}

TEST_CASE( "adder lx 3 E") {
  state_t state = {};
  entry_t entry = {"LX": 3, "CE": 0x9};
  adderLX(state, entry);
  REQUIRE( state.XG == 0x12);
}

TEST_CASE( "adder lx 4 LRL") {
  state_t state = {"L": 0x12345678};
  entry_t entry = {"LX": 4 /* LRL */};
  adderLX(state, entry);
  REQUIRE( state.XG == 0x56780000);
}

TEST_CASE( "adder lx 5 LWA") {
  state_t state = {"L": 0x12345678}
  entry_t entry = {"LX": 5};
  adderLX(state, entry);
  REQUIRE( state.XG == 0x1234567b);
  entry_t entry = {"LX": 5, "RY": 0};
  adderRY(state, entry);
  REQUIRE( state.Y == 3);
}

TEST_CASE( "adder lx 6 4") {
  state_t state = {};
  entry_t entry = {"LX": 6};
  adderLX(state, entry);
  REQUIRE( state.XG == 4);
}

TEST_CASE( "adder lx 7 64C", "[hide]") {
  state_t state = {};
  entry_t entry = {"LX": 7};
  adderLX(state, entry);
  REQUIRE( state.XG == (~64) >>> 0); // Complement of 64
}

TEST_CASE( "adder RY 0 0") {
  state_t state = {};
  entry_t entry = {"RY": 0};
  adderRY(state, entry);
  REQUIRE( state.Y == 0);
}

TEST_CASE( "adder RY 0 0") {
  state_t state = {};
  entry_t entry = {"RY": 0};
  adderRY(state, entry);
  REQUIRE( state.Y == 0);
}

TEST_CASE( "adder RY 1 R") {
  state_t state = {"R": 0x12345678};
  entry_t entry = {"RY": 1};
  adderRY(state, entry);
  REQUIRE( state.Y == 0x12345678);
}

TEST_CASE( "adder RY 2 M") {
  state_t state = {"M": 0x12345678};
  entry_t entry = {"RY": 2};
  adderRY(state, entry);
  REQUIRE( state.Y == 0x12345678);
}

TEST_CASE( "adder RY 3 M23") {
  state_t state = {"M": 0x12345678};
  entry_t entry = {"RY": 3};
  adderRY(state, entry);
  REQUIRE( state.Y == 0x5678);
}

TEST_CASE( "adder RY 4 H") {
  state_t state = {"H": 0x12345678};
  entry_t entry = {"RY": 4};
  adderRY(state, entry);
  REQUIRE( state.Y == 0x12345678);
}

TEST_CASE( "adder RY 5 SEMT", "[hide]") {
}

  // Based on 02D3
TEST_CASE( "adder-dec") {
  state_t state = {"R": 0};
  entry_t entry = {"RY": 1, "TC": 0, "LX": 0, "TR": 1, "AD": 1, "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.T0 == 0xffffffff);
}

  // The default adder inputs when nothing happens
TEST_CASE( "adder-default") {
  state_t state = {};
  entry_t entry = {"RY": 0, "TC": 1, "LX": 0, "TR": 7, "AD": 1, "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.T0 == 0);
}

TEST_CASE( "adder ad 2 BCF0", "[hide]") {
}

TEST_CASE( "adder-carry0 ad 4 BC0") {
  state_t state = {"XG": 0xffffffff, "Y": 0x00000001, "CIN": 0};
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0);

  state = {"R": 0xfffffffe, "L": 0x00000001, "CIN": 0};
  entry_t entry = {"RY": 1 /* R */, "TC": 1, "LX": 1 /* L */, "TR": 7, "AD": 4 /* BC0 */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0xffffffff);

  state = {"R": 0xffffffff, "L": 0x10000000, "CIN": 0};
  entry_t entry = {"RY": 1 /* R */, "TC": 1, "LX": 1 /* L */, "TR": 7, "AD": 4 /* BC0 */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0x0fffffff);
}

// 32-bit not
function not(x) {
  return (~x) >>> 0;
}

TEST_CASE( "adder-carry0 sub ad 4 BC0") {
  // Basic subtraction is 1"s complement
  state_t state = {"Y": 0x00000000, "XG": not(0x00000001), "CIN": 0};
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0xfffffffe); // R - L, subtraction is one short without carry-in

  state = {"Y": 0xffffffff, "XG": not(0x00000000), "CIN": 0};
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0xfffffffe); // subtraction is one short

  state = {"Y": 0xefffffff, "XG": not(0x10000000), "CIN": 0};
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0xdffffffe); // subtraction is one short
}

TEST_CASE( "adder-carry0 sub +hot1 ad 4 BC0") {
  // Add hot1 to get 2"s complement subtraction
  state_t state = {"Y": 0x00000000, "XG": not(0x00000001)};
  entry_t entry = {"DG": 2 /* HOT1 */};
  adderDG(state, entry);
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0); // Carry = not borrow
  REQUIRE( state.T0 == 0xffffffff);

  state = {"Y": 0xffffffff, "XG": not(0x00000000)};
  entry_t entry = {"DG": 2 /* HOT1 */};
  adderDG(state, entry);
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0xffffffff);

  state = {"Y": 0xefffffff, "XG": not(0x10000000)};
  entry_t entry = {"DG": 2 /* HOT1 */};
  adderDG(state, entry);
  entry_t entry = {"AD": 4 /* BC0 */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0xdfffffff);
}

TEST_CASE( "adder-overflow ad 5 BC⩝C") {
  // Normal positive addition
  state_t state = {"XG": 0x12345678, "Y": 0x12345678, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0x12345678 + 0x12345678);

  // positive + positive yields negative overflow
  // Normal positive addition
  state_t state = {"XG": 0x12345678, "Y": 0x12345678, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0x12345678 + 0x12345678);

  // positive + positive yields negative overflow
  state = {"XG": 0x70000000, "Y": 0x70000000, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0xe0000000);

  // positive + negative okay
  state = {"XG": 0x70000000, "Y": 0xffffffff, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0x6fffffff);

  // negative + negative okay
  state = {"XG": 0xffffffff, "Y": 0xffffffff, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0xfffffffe);


  state = {"XG": 0x80000000, "Y": 0xffffffff, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0x7fffffff);

  // -1 + 0: no overflow
  state = {"XG": 0x00000000, "Y": 0xffffffff, "CIN": 0};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0xffffffff);

  // -1 + 0 + carry: no overflow
  state = {"XG": 0x00000000, "Y": 0xffffffff, "CIN": 1};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0);

  // -1 + 0 + carry: no overflow
  state = {"Y": 0x00000000, "XG": 0xffffffff, "CIN": 1};
  entry_t entry = {"AD": 5 /* BC⩝C */};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0);
}

TEST_CASE( "adder-subtract-overflow ad 5 BC⩝C") {
  // Normal positive subtraction: note that L is subtracted from R
  state_t state = {"R": 0x12345678, "L": 0x12345677};
  entry_t entry = {"RY": 1 /* R */, "TC": 0, "LX": 1 /* L */, "TR": 7, "AD": 5 /* BC⩝C */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0); // 1"s complement subtraction

  // positive - positive yields negative
  state = {"R": 0x70000000, "L": 0x70000001};
  entry_t entry = {"RY": 1 /* R */, "TC": 0, "LX": 1 /* L */, "TR": 7, "AD": 5 /* BC⩝C */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0xfffffffe);

  // positive - negative okay
  state = {"R": 0x12345678, "L": 0xffffffff};
  entry_t entry = {"RY": 1 /* R */, "TC": 0, "LX": 1 /* L */, "TR": 7, "AD": 5 /* BC⩝C */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0x12345678);

  // positive - negative overflow
  state = {"R": 0x7fffffff, "L": 0xfffffffe};
  entry_t entry = {"RY": 1 /* R */, "TC": 0, "LX": 1 /* L */, "TR": 7, "AD": 5 /* BC⩝C */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0x80000000);

  // negative - negative okay
  state = {"R": 0xfffffffe, "L": 0xffffffff};
  entry_t entry = {"RY": 1 /* R */, "TC": 0, "LX": 1 /* L */, "TR": 7, "AD": 5 /* BC⩝C */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 0);
  REQUIRE( state.T0 == 0xfffffffe);

  // negative - positive overflow
  state = {"R": 0x80000000, "L": 0x00000001};
  entry_t entry = {"RY": 1 /* R */, "TC": 0, "LX": 1 /* L */, "TR": 7, "AD": 5 /* BC⩝C */ , "AL": 0, "DG": 0};
  adder(state, entry);
  REQUIRE( state.CAR == 1);
  REQUIRE( state.T0 == 0x7ffffffe);
}

// Block carry from 8, save carry from 1. Used for floating point exponent math.
TEST_CASE( "adder ad 6 BC1B") {
  // Exponents equal
  state_t state = {"XG": 0x12345678, "AUX": 0, "Y": (~(0x12345678)) >>> 0, "CIN": 1};
  entry_t entry = {"AD": 6};
  adderT(state, entry);
  REQUIRE( state.T0 == 0x00000000);
  REQUIRE( state.CAR == 1); // Carry

  // Exponents equal, sign different
  state_t state = {"XG": 0x12345678, "AUX": 0, "Y": (~(0x92345678)) >>> 0, "CIN": 1};
  entry_t entry = {"AD": 6};
  adderT(state, entry);
  REQUIRE( state.T0 == 0x80000000);
  REQUIRE( state.CAR == 1); // Carry

  // First exponent smaller
  state_t state = {"XG": 0x11345678, "AUX": 0, "Y": (~(0x12345678)) >>> 0, "CIN": 1};
  entry_t entry = {"AD": 6};
  adderT(state, entry);
  REQUIRE( state.T0 == 0x7f000000);
  REQUIRE( state.CAR == 0); // No carry

  // First exponent larger
  state_t state = {"XG": 0x13345678, "AUX": 0, "Y": (~(0x92345678)) >>> 0, "CIN": 1};
  entry_t entry = {"AD": 6};
  adderT(state, entry);
  REQUIRE( state.T0 == 0x81000000);
  REQUIRE( state.CAR == 1); // Carry
}

// Carry out of pos 8
TEST_CASE( "adderT ad 7 BC8") {
  state_t state = {"XG": 0x00000000, "AUX": 0, "Y": 0xffffffff, "CIN": 0};
  entry_t entry = {"AD": 7};
  adderT(state, entry);
  REQUIRE( state.CAR == 0);

  state = {"XG": 0x00800000, "AUX": 0, "Y": 0x00800000, "CIN": 0};
  entry_t entry = {"AD": 7};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);

  state = {"XG": 0x00ffffff, "AUX": 0, "Y": 0x00000001, "CIN": 0};
  entry_t entry = {"AD": 7};
  adderT(state, entry);
  REQUIRE( state.CAR == 1);
}

TEST_CASE( "adderT ad 8 DHL") {
  state_t state = {"XG": 0xdddddddd, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 8};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0, "No correction");

  state = {"XG": 0xdddddd2d, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 8};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x6, "Low-order");

  state = {"XG": 0x22222222, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 8};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x06666666, "All correction");

  state_t state = {"XG": 0xdddddddd, "AUX": 1, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 8};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x60000000, "Aux correction");
  REQUIRE( state.AUX == 0);

  state = {"XG": 0xdddddd22, "AUX": 1, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 8};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x60000006, "Low-order, aux");

  state = {"XG": 0x22222220, "AUX": 1, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 8};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x66666666, "All correction, AUX");
}

TEST_CASE( "adder ad 9 DC0") {
  state_t state = {"S": [0, 1, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AD": 9, "DG": 0};
  adderDG(state, entry); // Note AD 9 implemented in adderDG
  REQUIRE( state.CIN == 1);
}

TEST_CASE( "adder ad 10 DDC0", "[hide]") {
}

TEST_CASE( "adderT ad 11 DHH") {
  state_t state = {"XG": 0xdddddddd, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 11};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0, "No correction");
  REQUIRE( state.AUX == 0);

  state = {"XG": 0xddddddd2, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 11};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0, "No correction, aux");
  REQUIRE( state.AUX == 1);

  state = {"XG": 0x22222220, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 11};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x06666666, "All correction");
  REQUIRE( state.AUX == 0);

  state = {"XG": 0xffffffff, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 11};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x06666666, "All correction, AUX");
  REQUIRE( state.AUX == 1);

  state = {"XG": 0x22002002, "AUX": 0, "Y": 0, "CIN": 0};
  entry_t entry = {"AD": 11};
  adderT(state, entry);
  REQUIRE( state.pending["L"] == 0x06600600, "Some correction, AUX");
  REQUIRE( state.AUX == 1);
}

TEST_CASE( "adder ad 12 DCBS", "[hide]") {
}

TEST_CASE( "adder dg 1 CSTAT→ADDER") {
  state_t state = {"CSTAT": 0};
  entry_t entry = {"DG": 1 /* CSTAT→ADDER */};
  adderDG(state, entry);
  REQUIRE( state.CIN == 0);

  state = {"CSTAT": 1};
  entry_t entry = {"DG": 1 /* CSTAT→ADDER */};
  adderDG(state, entry);
  REQUIRE( state.CIN == 1);
}

TEST_CASE( "adder dg2 HOT1→ADDER") {
  state_t state = {"L": 0x12345678};
  entry_t entry = {"LX": 1 /* L */, "RY": 0 /* 0 */, "TC": 1 /* add */, "AD": 1 /* default op */, "DG": 2 /* HOT1→ADDER */};
  adder(state, entry);
  REQUIRE( state.T0 == 0x12345679);
}

TEST_CASE( "adder dg 3 G1-1") {
  state_t state = {"G1": 1};
  entry_t entry = {"DG": 3 /* G1-1 */};
  adderDG(state, entry);
  REQUIRE( state.G1NEG == 0);
  REQUIRE( state.pending["G1"] == 0);

  state = {"G1": 0};
  entry_t entry = {"DG": 3 /* G1-1 */};
  adderDG(state, entry);
  REQUIRE( state.G1NEG == 1);
  REQUIRE( state.pending["G1"] == undefined); // No change
}

TEST_CASE( "adder dg 4 HOT1,G-1") {
  state_t state = {"G1": 2, "G2":1};
  entry_t entry = {"DG": 4};
  adderDG(state, entry);
  REQUIRE( state.pending["G1"] == undefined); // no change
  REQUIRE( state.pending["G2"] == 0);
  REQUIRE( state.CIN == 1);

  state = {"G1": 2, "G2":0};
  entry_t entry = {"DG": 4};
  adderDG(state, entry);
  REQUIRE( state.pending["G1"] == 1);
  REQUIRE( state.pending["G2"] == 0xf);
  REQUIRE( state.CIN == 1);
}

TEST_CASE( "adder dg 5 G2-1") {
  state_t state = {"G2": 1};
  entry_t entry = {"DG": 5 /* G2-1 */};
  adderDG(state, entry);
  REQUIRE( state.G2NEG == 0);
  REQUIRE( state.pending["G2"] == 0);

  state = {"G2": 0};
  entry_t entry = {"DG": 5 /* G2-1 */};
  adderDG(state, entry);
  REQUIRE( state.G2NEG == 1);
  REQUIRE( state.pending["G2"] == undefined); // No change below 0
}

TEST_CASE( "adder dg 6 G-1") {
  state_t state = {"G1": 2, "G2":1};
  entry_t entry = {"DG": 6};
  adderDG(state, entry);
  REQUIRE( state.pending["G1"] == undefined); // No change
  REQUIRE( state.pending["G2"] == 0);

  state = {"G1": 2, "G2":0};
  entry_t entry = {"DG": 6};
  adderDG(state, entry);
  REQUIRE( state.pending["G1"] == 1);
  REQUIRE( state.pending["G2"] == 0xf);
}

TEST_CASE( "adder dg 7 G1,2-1") {
  state_t state = {"G1": 0, "G2": 1};
  entry_t entry = {"DG": 7};
  adderDG(state, entry);
  REQUIRE( state.G1NEG == 1);
  REQUIRE( state.G2NEG == 0);
  REQUIRE( state.pending["G1"] == undefined); // No change
  REQUIRE( state.pending["G2"] == 0);

  state_t state = {"G1": 0xf, "G2": 0};
  entry_t entry = {"DG": 7};
  adderDG(state, entry);
  REQUIRE( state.G1NEG == 0);
  REQUIRE( state.G2NEG == 1);
  REQUIRE( state.pending["G1"] == 0xe);
  REQUIRE( state.pending["G2"] == undefined); // No change
}


TEST_CASE( "iar0") {
  state_t state = {"T": 0x12345678, "R": 0x56781234};
  entry_t entry = {"IV": 0};
  iar(state, entry);
  assert.expect(0);
}

TEST_CASE( "iar iv 1 WL→IVD") {
  state_t state = {"WL": 0x0};
  entry_t entry = {"IV": 1};
  iar(state, entry); // Nop, implemented in iar2
  entry_t entry = {"IV": 1};
  iar2(state, entry);
  state = {"WL": 0x9};
  entry_t entry = {"IV": 1};
  iar2(state, entry);
  assert.throws(function() {
    state = {"WL": 0xa}; // Invalid digit
  entry_t entry = {"IV": 1};
    iar2(state, entry);
  }
}

TEST_CASE( "iar iv 2 WR→IVD") {
  state_t state = {"WR": 0x0};
  entry_t entry = {"IV": 2};
  iar(state, entry); // Nop, implemented in iar2
  entry_t entry = {"IV": 2};
  iar2(state, entry);
  state = {"WR": 0x9};
  entry_t entry = {"IV": 2};
  iar2(state, entry);
  assert.throws(function() {
    state = {"WR": 0xa}; // Invalid digit
  entry_t entry = {"IV": 2};
    iar2(state, entry);
  }
}

TEST_CASE( "iar iv 3 W→IVD") {
  state_t state = {"WL": 0x0, "WR": 0x4};
  entry_t entry = {"IV": 3};
  iar(state, entry); // Nop, implemented in iar2
  entry_t entry = {"IV": 3};
  iar2(state, entry);
  assert.throws(function() {
    state = {"WL": 0xa}; // Invalid digit
  entry_t entry = {"IV": 3};
    iar2(state, entry);
  }
  assert.throws(function() {
    state = {"WL": 0x0, "WR": 0xf}; // Invalid digit
  entry_t entry = {"IV": 3};
    iar2(state, entry);
  }
}

TEST_CASE( "iar iv 4 IA/4→A,IA") {
  state_t state = {"IAR": 0x12340000};
  entry_t entry = {"IV": 4};
  iar(state, entry);
  REQUIRE( state.IAR == 0x12340004);
  REQUIRE( state.SAR == 0x12340004);
}

TEST_CASE( "iar iv 5 IA+2/4") {
  // instruction length << 30
  state_t state = {"ILC": 0, "IAR": 0x12340000};
  entry_t entry = {"IV": 5};
  iar(state, entry);
  REQUIRE( state.IAR == 0x12340000);

  state = {"ILC": 1, "IAR": 0x12340000};
  entry_t entry = {"IV": 5};
  iar(state, entry);
  REQUIRE( state.IAR == 0x12340002); // +2

  state = {"ILC": 2, "IAR": 0x12340000};
  entry_t entry = {"IV": 5};
  iar(state, entry);
  REQUIRE( state.IAR == 0x12340004); // +4

  state = {"ILC": 3, "IAR": 0x12340000};
  entry_t entry = {"IV": 5};
  iar(state, entry);)
  REQUIRE( state.IAR == 0x12340004); // +4
}

TEST_CASE( "iar iv 6 IA+2") {
  state_t state = {"IAR": 0x12340000};
  entry_t entry = {"IV": 6};
  iar(state, entry);
  REQUIRE( state.IAR == 0x12340002);
}

TEST_CASE( "iar iv 7 IA+0/2→A") {
  // No refetch: should increment
  state_t state = {"SAR": 1, "IAR": 0x12340002, "REFETCH": 0};
  entry_t entry = {"IV": 7, "ZN": 0};
  iar(state, entry);
  REQUIRE( state.SAR == 0x12340004);
  // Refetch, no increment
  state = {"SAR": 1, "IAR": 0x12340002, "REFETCH": 1};
  entry_t entry = {"IV": 7, "ZN": 0};
  iar(state, entry);
  REQUIRE( state.SAR == 0x12340002);

  // Even halfword, SMIF. Should increment. But rounded down? So no change?
  // Unclear if this case should increment or not or if it matters.
  state = {"SAR": 1, "IAR": 0x12340000, "REFETCH": 0};
  entry_t entry = {"IV": 7, "ZN": 1};
  iar(state, entry);
  REQUIRE( state.SAR == 0x12340000);
  // Odd halfword, no refetch, SMIF. Should skip access.
  state = {"SAR": 1, "IAR": 0x12340002, "REFETCH": 0};
  entry_t entry = {"IV": 7, "ZN": 1};
  iar(state, entry);
  REQUIRE( state.SAR == 1);
  // Odd halfword, refetch, SMIF. Should not increment
  state = {"SAR": 1, "IAR": 0x12340002, "REFETCH": 1};
  entry_t entry = {"IV": 7, "ZN": 1};
  iar(state, entry);
  REQUIRE( state.SAR == 0x12340002);
}

TEST_CASE( "latch tr 1 R") {
  state_t state = {"T": 0x12345678, "R": 0x56781234};
  entry_t entry = {"TR": 1 /* R */};
  adderLatch(state, entry);
  REQUIRE( state.R == 0x12345678);
}

TEST_CASE( "latch tr 2 R0") {
  state_t state = {"T": 0x12345678, "R": 0x56781234};
  entry_t entry = {"TR": 2 /* R0 */};
  adderLatch(state, entry);
  REQUIRE( state.R == 0x12781234);
}

TEST_CASE( "latch tr 3 M") {
  state_t state = {"T": 0x12345678, "R": 0x56781234};
  entry_t entry = {"TR": 3 /* M */};
  adderLatch(state, entry);
  REQUIRE( state.M == 0x12345678);
}

TEST_CASE( "latch tr 4 D") {
  state_t state = {"T": 0x12345678, "R": 0x56781234, "SAR": 0x20};
  state.MS = [];
  entry_t entry = {"TR": 4 /* M */};
  adderLatch(state, entry);
  REQUIRE( state.SDR == 0x12345678);
  REQUIRE( state.MS[0x20] == 0x12345678);
}

TEST_CASE( "latch tr 5 L0") {
  state_t state = {"T": 0x12345678, "L": 0x56781234};
  entry_t entry = {"TR": 5 /* L0 */};
  adderLatch(state, entry);
  REQUIRE( state.L == 0x12781234);
}

TEST_CASE( "latch tr 6 R,A") {
  state_t state = {"T": 0x12345678, "R": 0x56781234};
  entry_t entry = {"TR": 6 /* R,A */};
  adderLatch(state, entry);
  REQUIRE( state.R == 0x12345678);
  REQUIRE( state.SAR == 0x12345678);
}

TEST_CASE( "latch tr 7 L") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 7 /* L */};
  adderLatch(state, entry);
  REQUIRE( state.L == 0x12345678);
}

TEST_CASE( "latch tr 8 HA→A", "[hide]") {
}

TEST_CASE( "latch tr 9 R,AN") {
  state_t state = {"T": 0x12345679};
  entry_t entry = {"TR": 9 /* R,AN */};
  adderLatch(state, entry);
  REQUIRE( state.R == 0x12345679);
  REQUIRE( state.SAR == 0x12345679);
  REQUIRE( state.TRAP == undefined);
}

TEST_CASE( "latch tr 10 R,AW") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 10 /* R,AW */};
  adderLatch(state, entry);
  REQUIRE( state.R == 0x12345678);
  REQUIRE( state.SAR == 0x12345678);
  REQUIRE( state.TRAP == undefined);
  state = {"T": 0x12345672}; // Halfword
  }

TEST_CASE( "latch tr 11 R,AD") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 11 /* R,AD */};
  adderLatch(state, entry);
  REQUIRE( state.R == 0x12345678);
  REQUIRE( state.SAR == 0x12345678);
  state = {"T": 0x12345674}; // Word
}

TEST_CASE( "latch tr 12 D→IAR") {
  state_t state = {"T": 0x12345678, "SAR": 0x10};
  state.MS = [];
  state.MS[0x10] = 0x3456789a;
  entry_t entry = {"TR": 12 /* IAR */};
  adderLatch(state, entry);
  REQUIRE( state.IAR == 0x0006789a);
}

TEST_CASE( "latch tr 13 SCAN→D", "[hide]") {
}

TEST_CASE( "latch tr 14 R13") {
  state_t state = {"T": 0x12345678, "R": 0xaabbccdd};
  entry_t entry = {"TR": 14};
  adderLatch(state, entry);
  REQUIRE( state.R == 0xaa345678);
}

TEST_CASE( "latch tr 15 A") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 15};
  adderLatch(state, entry);
  REQUIRE( state.SAR == 0x12345678);
}

TEST_CASE( "latch tr 16 L,A") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 16};
  adderLatch(state, entry);
  REQUIRE( state.L == 0x12345678);
  REQUIRE( state.SAR == 0x12345678);
}

// 17: I/O

// 18: unused

// 19: I/O

TEST_CASE( "latch tr 20 H") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 20 /* H */};
  adderLatch(state, entry);
  REQUIRE( state.H == 0x12345678);
}

TEST_CASE( "latch tr 21 IA") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 21};
  adderLatch(state, entry);
  REQUIRE( state.IAR == 0x00345678);
}

TEST_CASE( "latch tr 22 FOLD→D", "[hide]") {
}

// 23: unused

TEST_CASE( "latch tr 24 L,M") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 24};
  adderLatch(state, entry);
  REQUIRE( state.L == 0x12345678);
  REQUIRE( state.M == 0x12345678);
}

  // Complex instruction decoding
TEST_CASE( "latch 25 MLJK") {
  // X=0, B=0
  state_t state = {"T": 0x12300678, "S": []};
  entry_t entry = {"TR": 25};
  adderLatch(state, entry);
  REQUIRE( state.L == state["T"]);
  REQUIRE( state.M == state["T"]);
  REQUIRE( state.REFETCH == 0);
  REQUIRE( state.J == 0);
  REQUIRE( state.MD == 0);
  REQUIRE( state.S[0] == 1); // X=0, i.e. T(12-15) == J
  REQUIRE( state.S[1] == 1); // B=0, i.e. T(16-19) == MD

  // X=4, B=0
  state = {"T": 0x12340678, "S": []};
  entry_t entry = {"TR": 25};
  adderLatch(state, entry);
  REQUIRE( state.L == state["T"]);
  REQUIRE( state.M == state["T"]);
  REQUIRE( state.REFETCH == 0);
  REQUIRE( state.J == 4);
  REQUIRE( state.MD == 0);
  REQUIRE( state.S[0] == 0); // X!=0, i.e. T(12-15) == J
  REQUIRE( state.S[1] == 1); // B=0, i.e. T(16-19) == MD

  // X=4, B=5
  state = {"T": 0x12345678, "S": []};
  entry_t entry = {"TR": 25};
  adderLatch(state, entry);
  REQUIRE( state.L == state["T"]);
  REQUIRE( state.M == state["T"]);
  REQUIRE( state.REFETCH == 0);
  REQUIRE( state.J == 4);
  REQUIRE( state.MD == 5);
  REQUIRE( state.S[0] == 0); // X!=0, i.e. T(12-15) == J
  REQUIRE( state.S[1] == 0); // B!=0, i.e. T(16-19) == MD

  // X=0, B=5
  state = {"T": 0x12305678, "S": []};
  entry_t entry = {"TR": 25};
  adderLatch(state, entry);
  REQUIRE( state.L == state["T"]);
  REQUIRE( state.M == state["T"]);
  REQUIRE( state.REFETCH == 0);
  REQUIRE( state.J == 0);
  REQUIRE( state.MD == 5);
  REQUIRE( state.S[0] == 1); // X=0, i.e. T(12-15) == J
  REQUIRE( state.S[1] == 0); // B=0, i.e. T(16-19) == MD

  // Now test ILC, 1SYL
  for (var i = 0; i < 16; i++) {
    state = {"T": i << 28, "S": []};
  entry_t entry = {"TR": 25};
    adderLatch(state, entry);
    var top2 = i >> 2;
    if (top2 == 0) {
      REQUIRE( state.1SYL == 1);
      REQUIRE( state.ILC == 1);
    } else if (top2 == 1 || top2 == 2) {
      REQUIRE( state.1SYL == 0);
      REQUIRE( state.ILC == 2);
    } else {
      REQUIRE( state.1SYL == 0);
      REQUIRE( state.ILC == 3);
    }
  }
}

TEST_CASE( "latch tr 26 MHL") {
  state_t state = {"T": 0x12345678, "M": 0x11223344};
  entry_t entry = {"TR": 26};
  adderLatch(state, entry);
  REQUIRE( state.MD == 0x1);
  REQUIRE( state.M == 0x11221234);
}

TEST_CASE( "latch tr 27 MD") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 27};
  adderLatch(state, entry);
  REQUIRE( state.MD == 0x3);
}

TEST_CASE( "latch tr 28 M,SP") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 28};
  adderLatch(state, entry);
  REQUIRE( state.M == 0x12345678);
  REQUIRE( state.KEY == 0x3);
}

TEST_CASE( "latch29 D*BS") {
  // BS = 0011: only modify last two memory words
  state_t state = {"T": 0x12345678, "BS": [0, 0, 1, 1], "SAR": 0x30};
  state.MS = [];
  state.MS[0x30] = 0x9abcdef0;
  entry_t entry = {"TR": 29};
  adderLatch(state, entry);
  REQUIRE( state.SDR == 0x9abc5678);
  REQUIRE( state.MS[0x30] == 0x9abc5678);
}

TEST_CASE( "latch tr 30 L13") {
  state_t state = {"T": 0x12345678, "L": 0xaabbccdd};
  entry_t entry = {"TR": 30};
  adderLatch(state, entry);
  REQUIRE( state.L == 0xaa345678);
}

TEST_CASE( "latch tr 31 J") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"TR": 31 /* J */};
  adderLatch(state, entry);
  REQUIRE( state.J == 0x4); // Note bits 12-15
}

TEST_CASE( "mover") {
  // Extract 5 from E, 8 from M3
  state_t state = {"M": 0x12345678, "MB": 3};
  entry_t entry = {"LU": 0, "MV": 2 /* MMB */, "UL": 0 /* E */, "UR": 2 /* V */, "WM": 6 /* WL->J */, "CE": 0x5};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x58);
  REQUIRE( state.WL == 0x5);
  REQUIRE( state.J == 0x5);
  REQUIRE( state.WR == 0x8);
}

TEST_CASE( "mover lu 4 XTR") {
  state_t state = {"M": 0x12345678, "MB": 3};
  entry_t entry = {"LU": 4 /* XTR */, "MV": 2 /* MMB */, "UL": 0 /* E */, "UR": 2 /* V */, "WM": 6 /* WL->J */, "CE": 0x5};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.U == 0);
}

TEST_CASE( "mover2") {
  // E->WR, W->MMB
  state_t state = {"MB": 0, "M": 0x12345678};
  entry_t entry = {"LU": 0, "MV": 0, "UL": 1, "UR": 0, "WM": 1, "RY": 0, "CE": 7};
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 7);
  REQUIRE( state.WL == 0);
  REQUIRE( state.WR == 7);
  REQUIRE( state.M == 0x07345678);
}

TEST_CASE( "movers") {
  // E->WR, W->MMB
  state_t state = { "LB": 0, "L": 0x34000000, "MB": 0, "M": 0x12000000};
  // LLB -> U, MLB -> V, ?->WL, ?->WR
  entry_t entry = {"LU": 7, "MV": 2, "UL": 3, "UR": 3, "WM": 0};
  state.WFN = 1; // or
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x12 | 0x34);

  state.WFN = 2; // and
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x12 & 0x34);

  state.WFN = 3; // xor
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x12 ^ 0x34);

  state.WFN = 4; // char
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x34);

  state.WFN = 5; // zone
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x32); // Assuming w"s zone is overwritten, keep numeric

  state.WFN = 6; // numeric
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x14);

  state.WFN = 0; // cross
  moverU(state, entry);
  moverV(state, entry);
  moverWL(state, entry);
  moverWR(state, entry);
  storeMover(state, entry);
  REQUIRE( state.W == 0x43);
}

TEST_CASE("moverU 0") {
  state = {};
  entry_t entry = {"LU": 0};
  moverU(state, entry);
  REQUIRE( state.U == 0);
}

TEST_CASE("moverU 1 MD,F") {
  state = {"MD": 0x3, "F": 0x4};
  entry_t entry = {"LU": 1};
  moverU(state, entry);
  REQUIRE( state.U == 0x34);
}

TEST_CASE("moverU 2 R3") {
  state = {"R": 0x11223344};
  entry_t entry = {"LU": 2};
  moverU(state, entry);
  REQUIRE( state.U == 0x44);
}

TEST_CASE("moverU 4 XTR") {
  state = {};
  entry_t entry = {"LU": 4};
  moverU(state, entry);
  REQUIRE( state.U == 0);
}

TEST_CASE("moverU 5 PSW4") {
  state = {"ILC": 2, "CR": 3, "PROGMASK": 0xa};
  entry_t entry = {"LU": 5};
  moverU(state, entry);
  REQUIRE( state.U == 0xba);
}

TEST_CASE("moverU 6 LMB") {
  state = {"L": 0x11223344, "MB": 2};
  entry_t entry = {"LU": 6};
  moverU(state, entry);
  REQUIRE( state.U == 0x33);
}

TEST_CASE("moverU 7 LLB") {
  state = {"L": 0x11223344, "LB": 1};
  entry_t entry = {"LU": 7};
  moverU(state, entry);
  REQUIRE( state.U == 0x22);
}

TEST_CASE("moverV 0 0") {
  state = {};
  entry_t entry = {"MV": 0};
  moverV(state, entry);
  REQUIRE( state.V == 0);
}

TEST_CASE("moverV 1 MLB") {
  state = {"M": 0x11223344, "LB": 1};
  entry_t entry = {"MV": 1};
  moverV(state, entry);
  REQUIRE( state.V == 0x22);
}

TEST_CASE("moverV 2 MMB") {
  state = {"M": 0x11223344, "MB": 2};
  entry_t entry = {"MV": 2};
  moverV(state, entry);
  REQUIRE( state.V == 0x33);
}

TEST_CASE("storeMover WM 1 W→MMB") {
  state_t state = {"W": 0x89, "WL": 0x8, "WR": 0x9, "MB": 2, "M": 0x11223344};
  entry_t entry = {"WM": 1};
  storeMover(state, entry);
  REQUIRE( state.M == 0x11228944);
}

TEST_CASE("storeMover WM 2 W67→MB") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 2};
  storeMover(state, entry);
  REQUIRE( state.MB == 1);
}

TEST_CASE("storeMover WM 3 W67→LB") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 3};
  storeMover(state, entry);
  REQUIRE( state.LB == 1);
}

TEST_CASE("storeMover WM 4 W27→PSW4") {
  state_t state = {"W": 0x98, "WL": 9, "WR": 8};
  entry_t entry = {"WM": 4};
  storeMover(state, entry);
  REQUIRE( state.CR == 0x1);
  REQUIRE( state.PROGMASK == 0x8);
}

TEST_CASE("storeMover WM 5 W→PSW0") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 5};
  storeMover(state, entry);
  REQUIRE( state.SYSMASK == 0x89);
}

TEST_CASE("storeMover WM 6 WL→J") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 6};
  storeMover(state, entry);
  REQUIRE( state.J == 8);
}

TEST_CASE("storeMover WM 7 W→CHCTL", "[hide]") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
}

TEST_CASE("storeMover WM 8 W,E→A(BUMP)") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 8, "CE": 7};
  storeMover(state, entry);
  REQUIRE( state.SAR == 0x100089c);
}

TEST_CASE("storeMover WM 9 WL→G1") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 9};
  storeMover(state, entry);
  REQUIRE( state.G1 == 8);
}

TEST_CASE("storeMover WM 10 WR→G2") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 10};
  storeMover(state, entry);
  REQUIRE( state.G2 == 9);
}

TEST_CASE("storeMover WM 11 W→G") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 11};
  storeMover(state, entry);
  REQUIRE( state.G1 == 8);
  REQUIRE( state.G2 == 9);
}

TEST_CASE("storeMover WM 12 W→MMB(E?, "[hide]")") {
}

TEST_CASE("storeMover WM 13 WL→MD") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 13};
  storeMover(state, entry);
  REQUIRE( state.MD == 8);
}

TEST_CASE("storeMover WM 14 WR→F") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 14};
  storeMover(state, entry);
  REQUIRE( state.F == 9);
}

TEST_CASE("storeMover WM 15 W→MD,F") {
  state_t state = {"W": 0x89, "WL": 8, "WR": 9};
  entry_t entry = {"WM": 15};
  storeMover(state, entry);
  REQUIRE( state.MD == 8);
  REQUIRE( state.F == 9);
}

TEST_CASE( "counters") {
  state_t state = {"LB": 1, "MB": 1, "MD": 1};
  entry_t entry = {"UP": 0 /* 0 -> */, "LB": 1, "MB": 0, "MD": 0};
  counters(state, entry);
  REQUIRE( state.LB == 0);
  REQUIRE( state.MB == 1);
  REQUIRE( state.MD == 1);
  entry = {"UP": 1 /* 3 -> */, "LB": 0, "MB": 1, "MD": 0};
  counters(state, entry);
  REQUIRE( state.LB == 0);
  REQUIRE( state.MB == 3);
  REQUIRE( state.MD == 1);
  entry = {"UP": 2 /* dec */, "LB": 0, "MB": 1, "MD": 1};
  counters(state, entry);
  REQUIRE( state.LB == 0);
  REQUIRE( state.MB == 2);
  REQUIRE( state.MD == 0);
  entry = {"UP": 3 /* inc */, "LB": 1, "MB": 1, "MD": 0};
  counters(state, entry);
  REQUIRE( state.LB == 1);
  REQUIRE( state.MB == 3);
  REQUIRE( state.MD == 0);
}

TEST_CASE( "localStorage") {
  var ls = new Array(64);
  for (var i = 0; i < 64; i++) {
    ls[i] = i;
  }
  state_t state = {"LS": ls};
  entry_t entry = {"WS": 1 /* WS1 -> LSA */, "SF": 2 /* LS->R->LS */};
  entry_t entry = {"WS": 1 /* WS1 -> LSA */};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 17); // LSFN = 0b110001
  entry_t entry = {"SF": 2 /* LS->R->LS */};
  localStore(state, entry);
  REQUIRE( state.R == 17);
}

TEST_CASE("localStorage LSAR 1 WS1→LSA") {
  state_t state = {};
  entry_t entry = {"WS": 1};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x11);
}

TEST_CASE("localStorage LSAR 2 WS2→LSA") {
  state_t state = {};
  entry_t entry = {"WS": 2};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x12);
}

TEST_CASE("localStorage LSAR 3 WS,E→LSA") {
  state_t state = {};
  entry_t entry = {"WS": 3, "CE": 5};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x15);
}

TEST_CASE("localStorage LSAR 4 FN,J→LSA") {
  state_t state = {"FN": 2, "J": 3};
  entry_t entry = {"WS": 4, "SF": 7};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == undefined); // Blocked by SF=7
  state_t state = {"FN": 2, "J": 3, "WS": 0};
  entry_t entry = {"WS": 4, "SF": 0};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x23);
}

TEST_CASE("localStorage LSAR 5 FN,JΩ1→LSA") {
  state_t state = {"FN": 2, "J": 2};
  entry_t entry = {"WS": 5};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x23);
}

TEST_CASE("localStorage LSAR 6 FN,MD→LSA") {
  state_t state = {"FN": 2, "MD": 7};
  entry_t entry = {"WS": 6};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x27);
}

TEST_CASE("localStorage LSAR 7 FN,MDΩ1→LSA") {
  state_t state = {"FN": 2, "MD": 6};
  entry_t entry = {"WS": 7};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x27);
}

TEST_CASE( "localStorage SF=0 R→LS") {
  state_t state = {"LSAR": 0x32, "LS":{0x32: 0x12345678}, "R": 0x11223344};
  entry_t entry = {"SF": 0};
  localStore(state, entry);
  REQUIRE( state.LS[0x32] == 0x11223344);
  REQUIRE( state.R == 0x11223344);
}

TEST_CASE( "localStorage SF=1 LS→L,R→LS") {
  state_t state = {"LSAR": 0x32, "LS":{0x32: 0x12345678}, "R": 0x11223344};
  entry_t entry = {"SF": 1};
  localStore(state, entry);
  REQUIRE( state.LS[0x32] == 0x11223344);
  REQUIRE( state.L == 0x12345678);
  REQUIRE( state.R == 0x11223344);
}

TEST_CASE( "localStorage WS=2 WS2→LSA, SF=2 LS→R→LS") {
  state_t state = {"LS":{0x12: 0x12345678}, "R": 0x11223344};
  entry_t entry = {"WS": 2};
  localStorageLSAR(state, entry); // WS2→LSA
  REQUIRE( state.LSAR == 0x12);
  entry_t entry = {"SF": 2};
  localStore(state, entry);
  REQUIRE( state.R == 0x12345678);
}

TEST_CASE( "localStorage SF=4 L→LS") {
  state_t state = {"LSAR": 0x32, "LS":{0x32: 0x12345678}, "L": 0x11223344};
  entry_t entry = {"SF": 4};
  localStore(state, entry);
  REQUIRE( state.LS[0x32] == 0x11223344);
  REQUIRE( state.L == 0x11223344);
}

TEST_CASE( "localStorage SF=5 LS→R,L→LS") {
  state_t state = {"LSAR": 0x32, "LS":{0x32: 0x12345678}, "L": 0x11223344, "R": 0x55667788};
  entry_t entry = {"SF": 5};
  localStore(state, entry);
  REQUIRE( state.LS[0x32] == 0x11223344);
  REQUIRE( state.L == 0x11223344);
  REQUIRE( state.R == 0x12345678);
}

TEST_CASE( "localStorage SF=6 LS→L→LS") {
  state_t state = {"LSAR": 0x32, "LS":{0x32: 0x12345678}, "L": 0x11223344};
  entry_t entry = {"SF": 6};
  localStore(state, entry);
  REQUIRE( state.LS[0x32] == 0x12345678);
  REQUIRE( state.L == 0x12345678);
}

TEST_CASE( "ls sf 0 R→LS") {
  state_t state = {"LS":[], "R": 0x12345678, "LSAR": 0x31};
  // Update LSA
  entry_t entry = {"CE": 4, "WS": 3 /* WS,E→LSA */};
  localStorageLSAR(state, entry);
  // Update LS
  entry_t entry = {"SF": 0 /* R→LS */};
  localStore(state, entry);
  REQUIRE( state.LS[0x14] == 0x12345678);
}

TEST_CASE( "ls3  WS,E→LSA") {
  state_t state = {"LS": [], "R": 0x12345678};
  entry_t entry = {"CE": 5, "WS": 3 /* WS,E→LSA */};
  localStorageLSAR(state, entry);
  REQUIRE( state.LSAR == 0x15); // LSFN = 0b110101
  entry_t entry = {"SF": 0 /* R→LS */};
  localStore(state, entry);
  REQUIRE( state.LS[0x15] == 0x12345678);
}

TEST_CASE( "roar1") {
  state_t state = {};
  entry_t entry = {"ZP": 0x12, "ZF": 0x7, "ZN": 4};
  roar(state, entry);
  REQUIRE( state.ROAR == 0x49c);
  entry_t entry = {"AB": 1};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "roar-zn") {
  // Test ZN functions
  state_t state = {"ROAR": 0x49c};
  entry_t entry = {"ZP": 0x12, "ZF": 0x7, "ZN": 2 /* AΩ(B=0)→A */};
  roarZN(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c};
  entry_t entry = {"ZP": 0x12, "ZF": 0x7, "ZN": 3 /* AΩ(B=1)→A */};
  roarZN(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c};
  entry_t entry = {"ZP": 0x12, "ZF": 0x7, "ZN": 6 /* BΩ(A=0)→B */};
  roarZN(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

  // Test ZF functions (ZN = 0)
TEST_CASE( "roar-zf") {
  state_t state = {"ROAR": 0x480, "F": 3};
  entry_t entry = {"ZP": 0x12, "ZF": 10 /* F->ROAR */, "ZN": 0};
  roarZN(state, entry);
  REQUIRE( state.ROAR == (0x12 << 6) | (0x3 << 2));

  state_t state = {"ROAR": 0x4ff, "ED": 0xf};
  entry_t entry = {"ZP": 0x12, "ZF": 12 /* ED->ROAR */, "ZN": 0};
  roarZN(state, entry);
  REQUIRE( state.ROAR == 0x4ff);

  state_t state = {"ROAR": 0x4ff, "ED": 0};
  entry_t entry = {"ZP": 0x12, "ZF": 12 /* ED->ROAR */, "ZN": 0};
  roarZN(state, entry);
  REQUIRE( state.ROAR == 0x4c3);

  state = {"ROAR": 0x480, "M": 0x24ffffff};
  entry_t entry = {"ZP": 0x12, "ZF": 6 /* M(03)->ROAR */, "ZN": 0};
  roarZN(state, entry);
  REQUIRE( state.ROAR == (0x12 << 6) | (0x2 << 2));

  state = {"ROAR": 0x480, "M": 0x24ffffff};
  entry_t entry = {"ZP": 0x12, "ZF": 8 /* M(47)->ROAR */, "ZN": 0};
  roarZN(state, entry);
  REQUIRE( state.ROAR == (0x12 << 6) | (0x4 << 2));
}

TEST_CASE( "ab 0 (0)") {
  state_t state = {"ROAR": 0x49c};
  entry_t entry = {"AB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

TEST_CASE( "ab 1 (1)") {
  state_t state = {"ROAR": 0x49c};
  entry_t entry = {"AB": 1};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 2 (S0)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 2};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [1, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 2};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 3 (S1)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 3};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 1, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 3};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 4 (S2)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 4};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 1, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 4};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 5 (S3)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 5};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 1, 0, 0, 0, 0]};
  entry_t entry = {"AB": 5};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}


TEST_CASE( "ab 6 (S4)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 6};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 1, 0, 0, 0]};
  entry_t entry = {"AB": 6};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 7 (S5)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 7};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 1, 0, 0]};
  entry_t entry = {"AB": 7};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 8 (S6)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 8};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 1, 0]};
  entry_t entry = {"AB": 8};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 9 (S7)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 9};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 1]};
  entry_t entry = {"AB": 9};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 10 (CSTAT)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"AB": 9};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 1]};
  entry_t entry = {"AB": 9};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

// 11 unused

TEST_CASE( "ab 12 (1SYLS)") {
  state_t state = {"ROAR": 0x49c, "1SYLS": 0};
  entry_t entry = {"AB": 12};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "1SYLS": 1};
  entry_t entry = {"AB": 12};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 13 (LSGNS)") {
  state_t state = {"ROAR": 0x49c, "LSGNS": 0};
  entry_t entry = {"AB": 13};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "LSGNS": 1};
  entry_t entry = {"AB": 13};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 14 (⩝SGNS)") {
  state_t state = {"ROAR": 0x49c, "LSGNS": 0, "RSGNS": 0};
  entry_t entry = {"AB": 14};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "LSGNS": 1, "RSGNS": 0};
  entry_t entry = {"AB": 14};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
  state = {"ROAR": 0x49c, "LSGNS": 0, "RSGNS": 1};
  entry_t entry = {"AB": 14};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
  state = {"ROAR": 0x49c, "LSGNS": 1, "RSGNS": 1};
  entry_t entry = {"AB": 14};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

// 15 unused

TEST_CASE( "roar ab 16 CRMD") {
  // Negative cases
  state_t state = {"ROAR": 0x49c, "CR": 0, "MD": 7};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "CR": 1, "MD": 11};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "CR": 2, "MD": 13};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "CR": 3, "MD": 14};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // Positive cases
  state_t state = {"ROAR": 0x49c, "CR": 0, "MD": 8};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "CR": 1, "MD": 4};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "CR": 2, "MD": 2};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "CR": 3, "MD": 1};
  entry_t entry = {"AB": 16};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "roar ab 17 W=0") {
  state_t state = {"ROAR": 0x49c, "W": 1};
  entry_t entry = {"AB": 17};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "W": 0};
  entry_t entry = {"AB": 17};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "roar ab 18 WL=0") {
  state_t state = {"ROAR": 0x49c, "WL": 1};
  entry_t entry = {"AB": 18};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "WL": 0};
  entry_t entry = {"AB": 18};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "roar ab 19 WR=0") {
  state_t state = {"ROAR": 0x49c, "WR": 1};
  entry_t entry = {"AB": 19};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "WR": 0};
  entry_t entry = {"AB": 19};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "roar ab 20 MD=FP") {
  for (var i = 0; i < 16; i++) {
    state_t state = {"ROAR": 0x49c, "MD": i};
  entry_t entry = {"AB": 20};
    roarAB(state, entry);
    if (i == 0 || i == 2 || i == 4 || i == 6) {
      REQUIRE( state.ROAR == 0x49c | 2);
    } else {
      REQUIRE( state.ROAR == 0x49c | 0);
    }
  }
}

TEST_CASE( "roar ab 21 MB=3") {
  state_t state = {"ROAR": 0x49c, "MB": 2};
  entry_t entry = {"AB": 21};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "MB": 3};
  entry_t entry = {"AB": 21};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "roar ab 22 G1=0") {
  state_t state = {"ROAR": 0x49c, "MD": 0xe};
  entry_t entry = {"AB": 22 /* MD3=0 */};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
  state = {"ROAR": 0x49c, "MD": 0xf};
  entry_t entry = {"AB": 22 /* MD3=0 */};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

TEST_CASE( "roar ab 23 G1=0") {
  state_t state = {"ROAR": 0x49c, "G1": 1};
  entry_t entry = {"AB": 23};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "G1": 0};
  entry_t entry = {"AB": 23};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 24 (G1NEG)") {
  state_t state = {"ROAR": 0x49c, "G1NEG": 0};
  entry_t entry = {"AB": 24};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "G1NEG": 1};
  entry_t entry = {"AB": 24};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 25 (G<4)") {
  // Negative cases
  state_t state = {"ROAR": 0x49c, "G1": 0, "G2": 4};
  entry_t entry = {"AB": 25};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "G1": 1, "G2": 1};
  entry_t entry = {"AB": 25};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // Positive cases
  state = {"ROAR": 0x49c, "G1": 0, "G2": 3};
  entry_t entry = {"AB": 25};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 26 (G1MBZ)") {
  state_t state = {"ROAR": 0x49c, "G1": 1, "MB": 1};
  entry_t entry = {"AB": 26};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state_t state = {"ROAR": 0x49c, "G1": 0};
  entry_t entry = {"AB": 26};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
  state_t state = {"ROAR": 0x49c, "G1": 1, "MB": 0};
  entry_t entry = {"AB": 26};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

// 27: I/O

// 28: I/O

TEST_CASE( "ab 29 R(31)") {
  state_t state = {"ROAR": 0x49c, "R": 0xfffffffe};
  entry_t entry = {"AB": 29};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "R": 1};
  entry_t entry = {"AB": 29};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 30 F(2)") {
  state_t state = {"ROAR": 0x49c, "F": 13};
  entry_t entry = {"AB": 30};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "F": 2};
  entry_t entry = {"AB": 30};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 31 L(0)") {
  state_t state = {"ROAR": 0x49c, "L": 0x7fffffff};
  entry_t entry = {"AB": 31};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "L": 0x80000000};
  entry_t entry = {"AB": 31};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 32 F=0") {
  state_t state = {"ROAR": 0x49c, "F": 1};
  entry_t entry = {"AB": 32};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "F": 0};
  entry_t entry = {"AB": 32};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 33 (UNORM)") {
  state_t state = {"ROAR": 0x49c, "T": 0xff0fffff, "S": [0]};
  entry_t entry = {"AB": 33};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2); // T8-11 == 0, not stat 0
  state = {"ROAR": 0x49c, "S": [1]};
  entry_t entry = {"AB": 33};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "T": 0xff1fffff, "S": [0]};
  entry_t entry = {"AB": 33};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

TEST_CASE("ab 34 TZ*BS") {
  // Negative cases
  state_t state = {"ROAR": 0x49c, "T": 0x05000000, "BS": [1, 0, 0, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state_t state = {"ROAR": 0x49c, "T": 0x00800000, "BS": [0, 1, 0, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state_t state = {"ROAR": 0x49c, "T": 0x00001000, "BS": [1, 0, 1, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state_t state = {"ROAR": 0x49c, "T": 0x00000004, "BS": [1, 1, 1, 1]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // Positive cases
  state_t state = {"ROAR": 0x49c, "T": 0x00ffffff, "BS": [1, 0, 0, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state_t state = {"ROAR": 0x49c, "T": 0xff00ffff, "BS": [0, 1, 0, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state_t state = {"ROAR": 0x49c, "T": 0xffff00ff, "BS": [0, 0, 1, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state_t state = {"ROAR": 0x49c, "T": 0xffffff00, "BS": [0, 0, 0, 1]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state_t state = {"ROAR": 0x49c, "T": 0xffffffff, "BS": [0, 0, 0, 0]};
  entry_t entry = {"AB": 34};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 35 EDITPAT", "[hide]") {
}

TEST_CASE( "ab 36 PROB") {
  state_t state = {"ROAR": 0x49c, "AMWP": 0xe};
  entry_t entry = {"AB": 36};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "AMWP": 1};
  entry_t entry = {"AB": 36};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE( "ab 37 TIMUP", "[hide]") {
}

// 38 unused

TEST_CASE( "ab 39 (GZ/MB3)") {
  state_t state = {"ROAR": 0x49c, "G1": 0, "G2": 0, "MB": 1};
  entry_t entry = {"AB": 39};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2); // G == 0
  state = {"ROAR": 0x49c, "G1": 1, "G2": 1, "MB": 3};
  entry_t entry = {"AB": 39};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2); // MB = 3
  state = {"ROAR": 0x49c, "G1": 0, "G2": 1, "MB": 2};
  entry_t entry = {"AB": 39};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0); // G != 0 and MB != 3
  state = {"ROAR": 0x49c, "G1": 2, "G2": 0, "MB": 0};
  entry_t entry = {"AB": 39};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0); // G != 0 and MB != 3
}


// 40 Unused

TEST_CASE("ab 41 LOG", "[hide]") {
}

TEST_CASE("ab 42 STC=0", "[hide]") {
}

TEST_CASE("ab 43 G2<=LB") {
  // Negative cases
  state_t state = {"ROAR": 0x49c, "G2": 3, "LB": 2};
  entry_t entry = {"AB": 43};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "G2": 1, "LB": 0};
  entry_t entry = {"AB": 43};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // Positive cases
  state = {"ROAR": 0x49c, "G2": 3, "LB": 3};
  entry_t entry = {"AB": 43};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "G2": 0, "LB": 1};
  entry_t entry = {"AB": 43};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "G2": 1, "LB": 3};
  entry_t entry = {"AB": 43};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "G2": 0, "LB": 0};
  entry_t entry = {"AB": 43};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

// 44 unused

TEST_CASE("ab 45 D(7)") {
  // Negative case
  state_t state = {"ROAR": 0x49c, "MS": {0x100: 0xfeffffff}, "SAR": 0x100};
  entry_t entry = {"AB": 45};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // Positive case
  state = {"ROAR": 0x49c, "MS": {0x100: 0xffffffff}, "SAR": 0x100};
  entry_t entry = {"AB": 45};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE("ab 46 SCPS") {
  state_t state = {"ROAR": 0x49c, "SCPS": 0};
  entry_t entry = {"AB": 46};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "SCPS": 1};
  entry_t entry = {"AB": 46};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE("ab 47 SCFS") {
  state_t state = {"ROAR": 0x49c, "SCFS": 0};
  entry_t entry = {"AB": 47};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "SCFS": 1};
  entry_t entry = {"AB": 47};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

// 48 unused?

// Note: sets A and B
TEST_CASE("ab 49 W(67)→AB") {
  state_t state = {"ROAR": 0x49c, "W": 0};
  entry_t entry = {"AB": 49, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "W": 9};
  entry_t entry = {"AB": 49, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1); // B set

  state = {"ROAR": 0x49c, "W": 6};
  entry_t entry = {"AB": 49, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2); // A set

  state = {"ROAR": 0x49c, "W": 7};
  entry_t entry = {"AB": 49, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 3); // A,B set
}

// 50-53 unused?

TEST_CASE("ab 54 CANG") {
  state = {"ROAR": 0x49c, "SAR": 0x100, "T": 0xfffffff8};
  entry_t entry = {"AB": 54, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "SAR": 0x101, "T": 0xfffffff8}; // IVA
  entry_t entry = {"AB": 54, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "SAR": 0x100, "T": 0xfffffffc}; // 29-31 bit set (CA)A
  entry_t entry = {"AB": 54, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE("ab 55 CHLOG", "[hide]") {
}

// Sets A and B
TEST_CASE("ab 56 I-FETCH") {
  // off-bounds fetch (i.e. halfword, not word aligned)
  state = {"ROAR": 0x49c, "IAR": 0x102, "REFETCH": 0};
  entry_t entry = {"AB": 56, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // off-bounds refetch
  state = {"ROAR": 0x49c, "IAR": 0x102, "REFETCH": 1};
  entry_t entry = {"AB": 56, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  // on-bounds
  state = {"ROAR": 0x49c, "IAR": 0x104, "REFETCH": 1};
  entry_t entry = {"AB": 56, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  // Invalid address
  state = {"ROAR": 0x49c, "IAR": 0x105, "REFETCH": 1};
  entry_t entry = {"AB": 56, "BB": 0};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 3);
}

TEST_CASE( "ab 57 IA(30)") {
  state_t state = {"ROAR": 0x49c, "IAR": 0x12340000};
  entry_t entry = {"AB": 57};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "IAR": 0x12340002};
  entry_t entry = {"AB": 57};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

TEST_CASE("ab 58 EXT,CHIRPT", "[hide]") {
}

// 59 not used?

TEST_CASE("ab 60 PSS") {
  state_t state = {"ROAR": 0x49c, "PSS": 0};
  entry_t entry = {"AB": 60};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "PSS": 1};
  entry_t entry = {"AB": 60};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);
}

// 61 not used?

// 62 not used

TEST_CASE( "ab 63 RX.S0") {
  state_t state = {"ROAR": 0x49c, "M": 0x30000000, "S":[0]};
  entry_t entry = {"AB": 63};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0); // Not M:01, not S0
  state = {"ROAR": 0x49c, "M": 0x70000000, "S":[0]};
  entry_t entry = {"AB": 63};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0); // M:01, not S0
  state = {"ROAR": 0x49c, "M": 0x70000000, "S":[1]};
  entry_t entry = {"AB": 63};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2); // M:01, S0
  state = {"ROAR": 0x49c, "M": 0x90000000, "S":[1]};
  entry_t entry = {"AB": 63};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0); // not M:01, S0
}
TEST_CASE("bb 0 0") {
  state_t state = {"ROAR": 0x49c};
  entry_t entry = {"BB": 0};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

TEST_CASE("bb 1 1") {
  state_t state = {"ROAR": 0x49c};
  entry_t entry = {"BB": 1};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 2 (S0)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 2};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [1, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 2};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 3 (S1)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 3};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 1, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 3};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 4 (S2)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 4};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 1, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 4};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 5 (S3)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 5};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 1, 0, 0, 0, 0]};
  entry_t entry = {"BB": 5};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 6 (S4)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 6};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 1, 0, 0, 0]};
  entry_t entry = {"BB": 6};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 7 (S5)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 7};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 1, 0, 0]};
  entry_t entry = {"BB": 7};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 8 (S6)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 8};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 1, 0]};
  entry_t entry = {"BB": 8};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 9 (S7)") {
  state_t state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"BB": 9};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "S": [0, 0, 0, 0, 0, 0, 0, 1]};
  entry_t entry = {"BB": 9};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 10 RSGNS") {
  state_t state = {"ROAR": 0x49c, "RSGNS": 0};
  entry_t entry = {"BB": 10};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "RSGNS": 1};
  entry_t entry = {"BB": 10};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

// 11: HSCH

TEST_CASE("bb 12 EXC") {
  state_t state = {"ROAR": 0x49c, "EXC": 0};
  entry_t entry = {"BB": 12};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "EXC": 1};
  entry_t entry = {"BB": 12};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 13 WR=0") {
  state_t state = {"ROAR": 0x49c, "WR": 1};
  entry_t entry = {"BB": 13};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "WR": 0};
  entry_t entry = {"BB": 13};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

// 14 unused

// Inexplicably, T13=0 seems to mean T bits 8 to 31 are 0 (i.e. fraction in a float)
TEST_CASE( "bb 15 (T13=0)") {
  state_t state = {"ROAR": 0x49c, "T": 0x00800000};
  entry_t entry = {"BB": 15};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "T": 0x00000001};
  entry_t entry = {"BB": 15};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "T": 0xff000000};
  entry_t entry = {"BB": 15};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 16 T(0)") {
  state_t state = {"ROAR": 0x49c, "T": 0x80000000};
  entry_t entry = {"BB": 16};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
  state = {"ROAR": 0x49c, "T": 0x7fffffff};
  entry_t entry = {"BB": 16};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

TEST_CASE( "bb 17 T=0") {
  state_t state = {"ROAR": 0x49c, "T": 0};
  entry_t entry = {"BB": 17};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
  state = {"ROAR": 0x49c, "T": 1};
  entry_t entry = {"BB": 17};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
}

TEST_CASE("bb 18 TZ*BS") {
  // Negative cases
  state_t state = {"ROAR": 0x49c, "T": 0x05000000, "BS": [1, 0, 0, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state_t state = {"ROAR": 0x49c, "T": 0x00800000, "BS": [0, 1, 0, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state_t state = {"ROAR": 0x49c, "T": 0x00001000, "BS": [1, 0, 1, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state_t state = {"ROAR": 0x49c, "T": 0x00000004, "BS": [1, 1, 1, 1]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  // Positive cases
  state_t state = {"ROAR": 0x49c, "T": 0x00ffffff, "BS": [1, 0, 0, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state_t state = {"ROAR": 0x49c, "T": 0xff00ffff, "BS": [0, 1, 0, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state_t state = {"ROAR": 0x49c, "T": 0xffff00ff, "BS": [0, 0, 1, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state_t state = {"ROAR": 0x49c, "T": 0xffffff00, "BS": [0, 0, 0, 1]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state_t state = {"ROAR": 0x49c, "T": 0xffffffff, "BS": [0, 0, 0, 0]};
  entry_t entry = {"BB": 18};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 19 W=1") {
  state_t state = {"ROAR": 0x49c, "W": 0}
  entry_t entry = {"BB": 19};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "W": 7}
  entry_t entry = {"BB": 19};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "W": 1}
  entry_t entry = {"BB": 19};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 20 LB=0") {
  state_t state = {"ROAR": 0x49c, "LB": 1}
  entry_t entry = {"BB": 20};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "LB": 0}
  entry_t entry = {"BB": 20};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 21 LB=3") {
  state_t state = {"ROAR": 0x49c, "LB": 1}
  entry_t entry = {"BB": 21};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "LB": 0}
  entry_t entry = {"BB": 21};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "LB": 3}
  entry_t entry = {"BB": 21};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 22 MD=0") {
  state_t state = {"ROAR": 0x49c, "MD": 1}
  entry_t entry = {"BB": 22};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "MD": 0}
  entry_t entry = {"BB": 22};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 23 G2=0") {
  state_t state = {"ROAR": 0x49c, "G2": 1}
  entry_t entry = {"BB": 23};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "G2": 0}
  entry_t entry = {"BB": 23};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 24 G2<0") {
  state_t state = {"ROAR": 0x49c, "G2NEG": 0}
  entry_t entry = {"BB": 24};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "G2NEG": 1}
  entry_t entry = {"BB": 24};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 25 G2LBZ") {
  state_t state = {"ROAR": 0x49c, "G2": 1, "LB": 1}
  entry_t entry = {"BB": 25};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "G2": 0, "LB": 1}
  entry_t entry = {"BB": 25};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
  state = {"ROAR": 0x49c, "G2": 1, "LB": 0}
  entry_t entry = {"BB": 25};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

// 26 I/O

TEST_CASE( "bb 27 (MD/JI)") {
  state_t state = {"ROAR": 0x49c, "MD": 2, "J": 4}; // FP register # must be 0, 2, 4, 6
  entry_t entry = {"BB": 27};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "MD": 2, "J": 5};
  entry_t entry = {"BB": 27};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state = {"ROAR": 0x49c, "MD": 2, "J": 8};
  entry_t entry = {"BB": 27};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state = {"ROAR": 0x49c, "MD": 1, "J": 4};
  entry_t entry = {"BB": 27};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state = {"ROAR": 0x49c, "MD": 12, "J": 4};
  entry_t entry = {"BB": 27};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE("bb 28 IVA", "[hide]") {
  state_t state = {"ROAR": 0x49c, "SAR": 0x102};
  entry_t entry = {"BB": 28};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "SAR": 0x101};
  entry_t entry = {"BB": 28};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

// 29 I/O

TEST_CASE( "bb 30 (CAR)") {
  state_t state = {"ROAR": 0x49c, "CAR": 0};
  entry_t entry = {"BB": 30};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "CAR": 1};
  entry_t entry = {"BB": 30};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "bb 31 (Z00)") {
  state_t state = {"ROAR": 0x49c, "T0": 0x7fffffff};
  entry_t entry = {"BB": 31};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);
  state = {"ROAR": 0x49c, "T0": 0x80000000};
  entry_t entry = {"BB": 31};
  roarBB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);
}

TEST_CASE( "roar ZN 1 SMIF") {
  state_t state = {};
  entry_t entry = {"ZP": 0x12, "ZF": 0x7, "ZN": 1};
  roar(state, entry);
  REQUIRE( state.ROAR == 0x49c);
}

TEST_CASE( "roar AB 56 I-FETCH") {
  state_t state = {"ROAR": 0x49c, "IAR": 0x12340000, "REFETCH": 0}; // word aligned (on-bounds), no refetch
  entry_t entry = {"AB": 56};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "IAR": 0x12340000, "REFETCH": 1}; // word aligned (on-bounds), refetch
  entry_t entry = {"AB": 56};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 2);

  state = {"ROAR": 0x49c, "IAR": 0x12340002, "REFETCH": 0}; // halfword aligned (off-bounds), no refetch
  entry_t entry = {"AB": 56};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 0);

  state = {"ROAR": 0x49c, "IAR": 0x12340002, "REFETCH": 1}; // halfword aligned (off-bounds), refetch
  entry_t entry = {"AB": 56};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 1);

  state = {"ROAR": 0x49c, "IAR": 0x12340001, "REFETCH": 0}; // alignment exception
  entry_t entry = {"AB": 56};
  roarAB(state, entry);
  REQUIRE( state.ROAR == 0x49c | 3);
}

// ----------- SS tests

// SS 1, 2: unused

TEST_CASE( "stat SS 3 D→CR*BS") {
  state_t state = {"SAR": 0x30, "MS": {}, "BS": [1, 0, 0, 0]};
  state.MS[0x30] = 0x81234567; // Leftmost bit of byte 0 set
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 1);

  state.MS[0x30] = 0x71234567; // Leftmost bit of byte 0 clear
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 0);

  state = {"SAR": 0x30, "MS": {}, "BS": [0, 1, 0, 0]};
  state.MS[0x30] = 0x81a34567; // Leftmost bit of byte 1 set
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 1);

  state.MS[0x30] = 0x81234567; // Leftmost bit of byte 1 clear
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 0);

  state = {"SAR": 0x30, "MS": {}, "BS": [0, 0, 1, 0]};
  state.MS[0x30] = 0x8123c567; // Leftmost bit of byte 2 set
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 1);

  state.MS[0x30] = 0x81234567; // Leftmost bit of byte 2 clear
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 0);

  state = {"SAR": 0x30, "MS": {}, "BS": [0, 0, 0, 1]};
  state.MS[0x30] = 0x812345f7; // Leftmost bit of byte 3 set
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 1);

  state.MS[0x30] = 0x81234567; // Leftmost bit of byte 3 clear
  entry_t entry = {"SS": 3};
  stat(state, entry);
  REQUIRE( state.CR == 0);

}

TEST_CASE( "stat SS 4 E→SCANCTL", "[hide]") {
}

TEST_CASE( "stat SS 5 L,RSGNS") {
  for (var i = 0; i < 16; i++) {
    state_t state = {"U": 0x40 | i}; // 4 is arbitrary
    if (i < 10) {
  entry_t entry = {"SS": 5})};
      assert.throws(function() { stat(state, entry);
    } else if (i == 0xb || i == 0xd) {
  entry_t entry = {"SS": 5};
      stat(state, entry);
      REQUIRE( state.LSGNS == 1, "LSGNS " + i, i); // Negative
      REQUIRE( state.RSGNS == 1, "RSGNS " + i, i); // Flipped
    } else {
  entry_t entry = {"SS": 5};
      stat(state, entry);
      REQUIRE( state.LSGNS == 0, "LSGNS " + i, i); // Positive
      REQUIRE( state.RSGNS == undefined, "RSGNS " + i, i); // Unchanged
    }
  }
}

TEST_CASE( "stat SS 6 IVD/RSGNS") {
  for (var i = 0; i < 16; i++) {
    state_t state = {"RSGNS": 1, "U": 0x40 | i}; // 4 is arbitrary
    if (i < 10) {
  entry_t entry = {"SS": 6})};
      assert.throws(function() { stat(state, entry);
    } else if (i == 0xb || i == 0xd) {
  entry_t entry = {"SS": 6};
      stat(state, entry);
      REQUIRE( state.RSGNS == 0, i); // Cleared
    } else {
  entry_t entry = {"SS": 6};
      stat(state, entry);
      REQUIRE( state.RSGNS == 1, i); // Unchanged
    }
  }
}

TEST_CASE( "stat SS 7 EDITSGN", "[hide]") {
}

TEST_CASE( "stat8 E→S03") {
  state_t state = {"S": [1, 0, 0, 1, 0, 0, 0, 1]};
  entry_t entry = {"CE": 3, "SS": 8};
  stat(state, entry);
  assert.deepEqual(state.S, [0, 0, 1, 1, 0, 0, 0, 1]);
}

TEST_CASE( "stat9 S03ΩE,1→LSGN") {
  state_t state = {"S": [1, 0, 0, 1, 0, 0, 0, 1]};
  entry_t entry = {"CE": 3, "SS": 9};
  stat(state, entry);
  assert.deepEqual(state.S, [1, 0, 1, 1, 0, 0, 0, 1]);
  REQUIRE( state.LSGNS == 1);
}

TEST_CASE( "stat10 S03ΩE") {
  state_t state = {"S": [1, 0, 0, 1, 0, 0, 0, 1]};
  entry_t entry = {"CE": 3, "SS": 10};
  stat(state, entry);
  assert.deepEqual(state.S, [1, 0, 1, 1, 0, 0, 0, 1]);
}

TEST_CASE( "stat11 S03ΩE,0→BS") {
  state_t state = {"S": [1, 0, 0, 1, 0, 0, 0, 1], "BS": []};
  entry_t entry = {"CE": 3, "SS": 11};
  stat(state, entry);
  assert.deepEqual(state.S, [1, 0, 1, 1, 0, 0, 0, 1]);
  assert.deepEqual(state.pending["BS"], [0, 0, 0, 0]);
}

// Unclear exactly which half of the word X0 and B0 come from
TEST_CASE( "stat12: X0,B0,1SYL") {
  // X=0, B=0
  state_t state = {"T": 0x02305678, "S": []};
  entry_t entry = {"SS": 12};
  stat(state, entry);
  REQUIRE( state.S[0] == 1); // X=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 1); // B=0, i.e. T(0-3)

  // X=4, B=0
  state = {"T": 0x02340678, "S": []};
  entry_t entry = {"SS": 12};
  stat(state, entry);
  REQUIRE( state.S[0] == 0); // X!=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 1); // B=0, i.e. T(0-3)

  // X=4, B=5
  state = {"T": 0x12345678, "S": []};
  entry_t entry = {"SS": 12};
  stat(state, entry);
  REQUIRE( state.S[0] == 0); // X!=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 0); // B!=0, i.e. T(0-3)

  // X=0, B=5
  state = {"T": 0x12305678, "S": []};
  entry_t entry = {"SS": 12};
  stat(state, entry);
  REQUIRE( state.S[0] == 1); // X=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 0); // B=0, i.e. T(0-3)

  // Now test 1SYL
  for (var i = 0; i < 16; i++) {
    state = {"T": i << 28, "S": []};
  entry_t entry = {"SS": 12};
    stat(state, entry);
    if (i <= 3) {
      REQUIRE( state.1SYL == 1);
    } else {
      REQUIRE( state.1SYL == 0);
    }
  }
}

// Tests if value is floating point zero (ignoring sign, exponent)
TEST_CASE( "stat SS 13: FPZERO") {
  testFpzero(13, assert);
}

function testFpzero(ss, assert) {
  state_t state = {"T": 0x12000000, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 1);

  state_t state = {"T": 0x82000000, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 1);

  state_t state = {"T": 0x00000000, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 1);

  state_t state = {"T": 0x00000001, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 0);

  state_t state = {"T": 0x00800000, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 0);

  state_t state = {"T": 0xff000001, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 0);

  state_t state = {"T": 0x00000001, "S": [0, 0, 0, 1, 0, 0, 0, 0], "F": 1}; // Need F=0
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 0);

  state_t state = {"T": 0x00000001, "S": [0, 0, 0, 0, 0, 0, 0, 0], "F": 0}; // Need S3
  entry_t entry = {"SS": ss};
  stat(state, entry);
  REQUIRE( state.S[0] == 0);
};

TEST_CASE( "stat SS 14: FPZERO,E→FN") {
  testFpzero(14, assert);

  state_t state = {"T": 0x00000001, "S": [0, 0, 0, 0, 0, 0, 0, 0], "F": 0};
  entry_t entry = {"SS": 14, "CE": 7};
  stat(state, entry);
  REQUIRE( state.FN == 3);
}

TEST_CASE( "stat15: B0,1SYL") {
  // X=0, B=0
  state_t state = {"T": 0x02305678, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"SS": 15};
  stat(state, entry);
  REQUIRE( state.S[0] == 0); // X=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 1); // B=0, i.e. T(0-3)

  // X=4, B=0
  state_t state = {"T": 0x02340678, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"SS": 15};
  stat(state, entry);
  REQUIRE( state.S[0] == 0); // X!=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 1); // B=0, i.e. T(0-3)

  // X=4, B=5
  state_t state = {"T": 0x12345678, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"SS": 15};
  stat(state, entry);
  REQUIRE( state.S[0] == 0, "X=4,B=5:S0"); // X!=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 0, "X=4,B=5:S1"); // B!=0, i.e. T(0-3)

  // X=0, B=5
  state_t state = {"T": 0x12305678, "S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"SS": 15};
  stat(state, entry);
  REQUIRE( state.S[0] == 0); // X=0, i.e. T(12-15)
  REQUIRE( state.S[1] == 0, "X=0,B=5:S1"); // B=0, i.e. T(0-3)

  // Now test 1SYL
  for (var i = 0; i < 16; i++) {
    state = {"T": i << 28, "S": []};
  entry_t entry = {"SS": 15};
    stat(state, entry);
    if (i <= 3) {
      REQUIRE( state.1SYL == 1);
    } else {
      REQUIRE( state.1SYL == 0);
    }
  }
}

TEST_CASE( "stat16: S03.¬E") {
  state_t state = {"S": [0, 0, 1, 1, 0, 0, 0, 1]};
  entry_t entry = {"CE": 6, "SS": 16};
  stat(state, entry);
  assert.deepEqual(state.S, [0, 0, 0, 1, 0, 0, 0, 1]);

  state = {"S": [1, 1, 1, 1, 1, 1, 1, 1]};
  entry_t entry = {"CE": 15, "SS": 16};
  stat(state, entry);
  assert.deepEqual(state.S, [0, 0, 0, 0, 1, 1, 1, 1]);
}

TEST_CASE( "stat SS 17: (T=0)→S3") {
  state_t state = {"S": [0, 0, 0, 0, 0, 0, 0, 0], "T": 0};
  entry_t entry = {"SS": 17};
  stat(state, entry);
  REQUIRE( state.S[3] == 1);
}

TEST_CASE( "stat18: E→BS,T30→S3") {
  state_t state = {"S": [0, 0, 1, 1, 0, 0, 0, 1], "T": 0, "BS": [0, 0, 0, 0]};
  entry_t entry = {"CE": 6, "SS": 18};
  stat(state, entry);
  assert.deepEqual(state.pending["BS"], [0, 1, 1, 0]);
  assert.deepEqual(state.S, [0, 0, 1, 0, 0, 0, 0, 1]);

  state = {"S": [0, 0, 1, 1, 0, 0, 0, 1], "T": 2, "BS": [0, 0, 0, 0]};
  entry_t entry = {"CE": 15, "SS": 18};
  stat(state, entry);
  assert.deepEqual(state.pending["BS"], [1, 1, 1, 1]);
  assert.deepEqual(state.S, [0, 0, 1, 1, 0, 0, 0, 1]);
}

TEST_CASE( "stat SS 19: E→BS") {
  state_t state = {"BS": [0, 0, 0, 0]};
  entry_t entry = {"CE": 15, "SS": 19};
  stat(state, entry);
  assert.deepEqual(state.pending["BS"], [1, 1, 1, 1]);

  state_t state = {"BS": [0, 0, 0, 0]};
  entry_t entry = {"CE": 3, "SS": 19};
  stat(state, entry);
  assert.deepEqual(state.pending["BS"], [0, 0, 1, 1]);
}

TEST_CASE( "stat20: 1→BS*MB") {
  state_t state = {"BS": [0, 0, 0, 0,], "MB": 2};
  entry_t entry = {"SS": 20};
  stat(state, entry);
  REQUIRE( state.pending["BS"][2] == 1);
}

// SS 21: unused

// SS 22: unused

TEST_CASE( "stat SS 23: MANUAL→STOP", "[hide]") {
}

TEST_CASE( "stat24: E→S47") {
  state_t state = {"S": [0, 0, 1, 1, 0, 0, 0, 1]};
  entry_t entry = {"CE": 6, "SS": 24};
  stat(state, entry);
  assert.deepEqual(state.S, [0, 0, 1, 1, 0, 1, 1, 0]);
}

TEST_CASE( "stat25: S47ΩE") {
  state_t state = {"S": [0, 0, 1, 1, 0, 0, 0, 1]};
  entry_t entry = {"CE": 6, "SS": 25};
  stat(state, entry);
  assert.deepEqual(state.S, [0, 0, 1, 1, 0, 1, 1, 1]);
}

TEST_CASE( "stat26: S47.¬E") {
  state_t state = {"S": [0, 0, 1, 1, 0, 0, 1, 1]};
  entry_t entry = {"CE": 6, "SS": 26};
  stat(state, entry);
  assert.deepEqual(state.S, [0, 0, 1, 1, 0, 0, 0, 1]);
}

TEST_CASE( "stat SS 27: S47,ED*FP", "[hide]") {
}

TEST_CASE( "stat SS 28: OPPANEL→S47", "[hide]") {
}

TEST_CASE( "stat29: CAR,(T≠0)→CR") {
  state_t state = {"CAR": 0, "T": 0};
  entry_t entry = {"CE": 6, "SS": 29};
  stat(state, entry);
  assert.deepEqual(state.CR, 0);
  state = {"CAR": 0, "T": 0x10000};
  entry_t entry = {"CE": 6, "SS": 29};
  stat(state, entry);
  assert.deepEqual(state.CR, 1);
  state = {"CAR": 1, "T": 0};
  entry_t entry = {"CE": 6, "SS": 29};
  stat(state, entry);
  assert.deepEqual(state.CR, 2);
  state = {"CAR": 1, "T": 0xffffffff};
  entry_t entry = {"CE": 6, "SS": 29};
  stat(state, entry);
  assert.deepEqual(state.CR, 3);
}

TEST_CASE( "stat30: KEY→F") {
  state_t state = {"SAR": 0x12345670, "KEYS": {}};
  state.KEYS[0x12345670 & 0x00fff100] = 4;
  entry_t entry = {"SS": 30};
  stat(state, entry);
  REQUIRE( state.F == 4);
}

TEST_CASE( "stat31: F→KEY") {
  state_t state = {"F": 4, "SAR": 0x12345670, "KEYS": {}};
  entry_t entry = {"SS": 31};
  stat(state, entry);
  REQUIRE( state.KEYS[0x12345670 & 0x00fff100] == 4);
}

TEST_CASE( "stat32: 1→LSGNS") {
  state_t state = {};
  entry_t entry = {"SS": 32};
  stat(state, entry);
  assert.deepEqual(state.LSGNS, 1);
}

TEST_CASE( "stat33: 0→LSGNS") {
  state_t state = {};
  entry_t entry = {"SS": 33};
  stat(state, entry);
  assert.deepEqual(state.LSGNS, 0);
}

TEST_CASE( "stat34: 1→RSGNS") {
  state_t state = {};
  entry_t entry = {"SS": 34};
  stat(state, entry);
  assert.deepEqual(state.RSGNS, 1);
}

TEST_CASE( "stat35: 0→RSGNS") {
  state_t state = {};
  entry_t entry = {"SS": 35};
  stat(state, entry);
  assert.deepEqual(state.RSGNS, 0);
}

TEST_CASE( "stat36: L(0)→LSGNS") {
  state_t state = {"L": 0x76543210};
  entry_t entry = {"SS": 36};
  stat(state, entry);
  assert.deepEqual(state.LSGNS, 0);
  state = {"L": 0x86543210};
  entry_t entry = {"SS": 36};
  stat(state, entry);
  assert.deepEqual(state.LSGNS, 1);
}

TEST_CASE( "stat37: R(0)→RSGNS") {
  state_t state = {"R": 0x76543210};
  entry_t entry = {"SS": 37};
  stat(state, entry);
  assert.deepEqual(state.RSGNS, 0);
  state = {"R": 0x86543210};
  entry_t entry = {"SS": 37};
  stat(state, entry);
  assert.deepEqual(state.RSGNS, 1);
}

TEST_CASE( "stat38: E(13)→WFN") {
  state_t state = {};
  entry_t entry = {"SS": 38, "CE": 0xe};
  stat(state, entry);
  REQUIRE( state.WFN == 6);
}

TEST_CASE( "stat SS 39: E(23)→FN") {
  state_t state = {};
  entry_t entry = {"SS": 39, "CE": 0xe};
  stat(state, entry);
  REQUIRE( state.FN == 2);
}

TEST_CASE( "stat SS 40: E(23)→CR") {
  state_t state = {};
  entry_t entry = {"SS": 40, "CE": 0xe};
  stat(state, entry);
  REQUIRE( state.CR == 2);
}

TEST_CASE( "stat41: SETCRALG") {
  state_t state = {"T": 0};
  entry_t entry = {"SS": 41, "CE": 0xe};
  stat(state, entry);
  REQUIRE( state.CR == 0); // Zero

  state = {"T": 0x80000001};
  entry_t entry = {"SS": 41, "CE": 0xe};
  stat(state, entry);
  REQUIRE( state.CR == 1); // Negative

  state = {"T": 0x7fffffff};
  entry_t entry = {"SS": 41, "CE": 0xe};
  stat(state, entry);
  REQUIRE( state.CR == 2); // Positive
}

TEST_CASE( "stat SS 42: SETCRLOG") {
  state_t state = {"T": 0x00110022, "BS": [1, 0, 1, 0], "c0": 1};
  entry_t entry = {"SS": 42};
  stat(state, entry);
  REQUIRE( state.CR == 0); // Zero

  state = {"T": 0x00110022, "BS": [1, 0, 1, 1], "c0": 0};
  entry_t entry = {"SS": 42};
  stat(state, entry);
  REQUIRE( state.CR == 1); // First lower

  state = {"T": 0x00110022, "BS": [0, 0, 0, 1], "c0": 1};
  entry_t entry = {"SS": 42};
  stat(state, entry);
  REQUIRE( state.CR == 2); // First higher
}

TEST_CASE( "stat SS 43: ¬S4,S4→CR") {
  state_t state = {"S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"SS": 43};
  stat(state, entry);
  REQUIRE( state.CR == 2);

  state_t state = {"S": [0, 0, 0, 0, 1, 0, 0, 0]};
  entry_t entry = {"SS": 43};
  stat(state, entry);
  REQUIRE( state.CR == 1);
}

TEST_CASE( "stat SS 44: S4,¬S4→CR") {
  state_t state = {"S": [0, 0, 0, 0, 0, 0, 0, 0]};
  entry_t entry = {"SS": 44};
  stat(state, entry);
  REQUIRE( state.CR == 1);

  state_t state = {"S": [0, 0, 0, 0, 1, 0, 0, 0]};
  entry_t entry = {"SS": 44};
  stat(state, entry);
  REQUIRE( state.CR == 2);
}

TEST_CASE( "stat SS 45: 1→REFETCH") {
  state_t state = {};
  entry_t entry = {"SS": 45};
  stat(state, entry);
  REQUIRE( state.REFETCH == 1);
}

TEST_CASE( "stat SS 46: SYNC→OPPANEL", "[hide]") {
}

TEST_CASE( "stat SS 47: SCAN*E,10", "[hide]") {
}

// SS 48, 49: I/O

TEST_CASE( "stat SS 50: E(0, "[hide]")→IBFULL") {
}

// SS 51: unused

TEST_CASE( "stat SS 52: E→CH", "[hide]") {
}

// SS 53: unused

TEST_CASE( "stat SS 54: 1→TIMERIRPT", "[hide]") {
}

// T to AMWP bits
TEST_CASE( "stat55  T→PSW,IPL→T") {
  state_t state = {"T": 0x12345678};
  entry_t entry = {"SS": 55};
  stat(state, entry);
  REQUIRE( state.AMWP == 4);
  REQUIRE( state.T == 0x0c000000); // Hardwored card reader IPl
}

// T to AMWP bits
TEST_CASE( "stat56 T→PSW") {
  state_t state = {"T": 0x123f5678};
  entry_t entry = {"SS": 56};
  stat(state, entry);
  REQUIRE( state.AMWP == 0xf);
}

TEST_CASE( "stat57") {
  // 57: SCAN*E00
  state_t state = {};
  entry_t entry = {"SS": 57, "CE": 0x3};
  stat(state, entry);
  REQUIRE( state.SCANCTRL == 0x0c);
}

TEST_CASE( "stat SS 58: 1→IOMODE", "[hide]") {
}

// SS 59-63: I/O

// ----- AL tests

// test shifter

TEST_CASE("sr1") {
  // Start with right field empty
  assert.deepEqual(sr1(0, 0x12345678, 0), [0x091a2b3c, 0]);
  assert.deepEqual(sr1(0, 0x12345679, 0), [0x091a2b3c, 8]);
  assert.deepEqual(sr1(1, 0x12345678, 0), [0x891a2b3c, 0]);
  assert.deepEqual(sr1(1, 0x12345679, 0), [0x891a2b3c, 8]);
  // Now with content in right field
  assert.deepEqual(sr1(0, 0x82345678, 3), [0x411a2b3c, 1]);
  assert.deepEqual(sr1(0, 0x82345679, 5), [0x411a2b3c, 0xa]);
  assert.deepEqual(sr1(1, 0x82345678, 8), [0xc11a2b3c, 4]);
  assert.deepEqual(sr1(1, 0x82345679, 0xf), [0xc11a2b3c, 0xf]);
}

TEST_CASE("sl1") {
  // Start with dest (left) field empty
  assert.deepEqual(sl1(0, 0x12345678, 0), [0x2468acf0, 0]);
  assert.deepEqual(sl1(0, 0x92345678, 0), [0x2468acf0, 1]);
  assert.deepEqual(sl1(8, 0x12345678, 0), [0x2468acf1, 0]);
  assert.deepEqual(sl1(8, 0x92345678, 0), [0x2468acf1, 1]);
  // Now with contents in dest field
  assert.deepEqual(sl1(0, 0x12345678, 0xf), [0x2468acf0, 0xe]);
  assert.deepEqual(sl1(0, 0x92345678, 0x8), [0x2468acf0, 1]);
  assert.deepEqual(sl1(8, 0x12345678, 0x5), [0x2468acf1, 0xa]);
  assert.deepEqual(sl1(8, 0x92345678, 0x2), [0x2468acf1, 5]);
}

TEST_CASE("sr4") {
  assert.deepEqual(sr4(0, 0x12345678), [0x01234567, 8]);
  assert.deepEqual(sr4(0xf, 0x12345673), [0xf1234567, 3]);
}

TEST_CASE("sl4") {
  assert.deepEqual(sl4(0x1, 0x12345678), [0x23456781, 1]);
  assert.deepEqual(sl4(0xf, 0x12345678), [0x2345678f, 1]);
  assert.deepEqual(sl4(0, 0xff345678), [0xf3456780, 0xf]);
}

TEST_CASE( "al1 Q→SR1→F") {
  state_t state = {"T0": 0x12345679, "Q": 1, "F": 5};
  entry_t entry = {"AL": 1, "DG": 0};
  adderAL(state, entry);
  REQUIRE( state.T == (0x80000000 | (0x12345678 >> 1)) >>> 0);
  REQUIRE( state.F == 0xa);
}

TEST_CASE( "al 2 L0,¬S4→") {
  state_t state = {"T0": 0x12345678, "L": 0x78901234, "S": {4: 0}};
  entry_t entry = {"AL": 2};
  adderAL(state, entry);
  REQUIRE( state.T == 0xf8345678);

  state_t state = {"T0": 0x12345678, "L": 0x78901234, "S": {4: 1}};
  entry_t entry = {"AL": 2};
  adderAL(state, entry);
  REQUIRE( state.T == 0x78345678);
}

TEST_CASE( "al3 +SGN→") {
  state_t state = {"T0": 0x12345678};
  entry_t entry = {"AL": 3};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12345678);
}

TEST_CASE( "al4 -SGN→") {
  state_t state = {"T0": 0x12345678};
  entry_t entry = {"AL": 4};
  adderAL(state, entry);
  REQUIRE( state.T == 0x92345678);
}

TEST_CASE( "al4 -SGN→") {
  state_t state = {"T0": 0x92345678};
  entry_t entry = {"AL": 4};
  adderAL(state, entry);
  REQUIRE( state.T == 0x92345678);
}

TEST_CASE( "al5 L0,S4→") {
  state_t state = {"T0": 0x12345678, "L": 0x78901234, "S": {4: 0}};
  entry_t entry = {"AL": 5};
  adderAL(state, entry);
  REQUIRE( state.T == 0x78345678);

  state_t state = {"T0": 0x12345678, "L": 0x78901234, "S": {4: 1}};
  entry_t entry = {"AL": 5};
  adderAL(state, entry);
  REQUIRE( state.T == 0xf8345678);
}

TEST_CASE( "al6 IA→H") {
  state_t state = {"IAR": 0x12345678};
  entry_t entry = {"AL": 6};
  adderAL(state, entry);
  REQUIRE( state.H == 0x12345678);
}

TEST_CASE( "al7 Q→SL→-F") {
  state_t state = {"T0": 0x12345678, "Q": 0, "F": 0xf};
  entry_t entry = {"AL": 7};
  adderAL(state, entry);
  REQUIRE( state.T == 0x2468acf0);
  REQUIRE( state.F == 0xf); // 0 inverted, shifted in

  state = {"T0": 0x92345678, "Q": 0, "F": 0xf};
  entry_t entry = {"AL": 7};
  adderAL(state, entry);
  REQUIRE( state.T == 0x2468acf0);
  REQUIRE( state.F == 0xe);

  state = {"T0": 0x12345678, "Q": 1, "F": 0xf};
  entry_t entry = {"AL": 7};
  adderAL(state, entry);
  REQUIRE( state.T == 0x2468acf1);
  REQUIRE( state.F == 0xf);
}

TEST_CASE( "al8 Q→SL1→F") {
  state_t state = {"Q": 0, "T0": 0x72345678, "F": 0xc}; // Shift 0 in, 0 out
  entry_t entry = {"AL": 8};
  adderAL(state, entry);
  REQUIRE( state.T == (0x72345678 << 1) >>> 0);
  REQUIRE( state.F == 0x8); // 1100 -> 1000

  state = {"Q": 1, "T0": 0x72345678, "F": 0xc}; // Shift 1 in, 0 out
  entry_t entry = {"AL": 8};
  adderAL(state, entry);
  REQUIRE( state.T == ((0x72345678 << 1) | 1) >>> 0);
  REQUIRE( state.F == 0x8);

  state = {"Q": 0, "T0": 0x92345678, "F": 0xc}; // Shift 0 in, 1 out
  entry_t entry = {"AL": 8};
  adderAL(state, entry);
  REQUIRE( state.T == (0x92345678 << 1) >>> 0);
  REQUIRE( state.F == 0x9);

  state = {"Q": 1, "T0": 0x92345678, "F": 0xc}; // Shift 1 in, 1 out
  entry_t entry = {"AL": 8};
  adderAL(state, entry);
  REQUIRE( state.T == ((0x92345678 << 1) | 1) >>> 0);
  REQUIRE( state.F == 0x9);
}

// Overflow bits from T spill into F, which is shifted into T.
TEST_CASE( "al9 F→SL1→F") {
  state_t state = {"T0": 0x92345678, "F": 0xc};
  entry_t entry = {"AL": 9};
  adderAL(state, entry);
  REQUIRE( state.T == (((0x92345678 << 1) | 1) & 0xffffffff) >>> 0, state["T"].toString(16));
  REQUIRE( state.F == 0x9);
  state.T0 = state["T"];
  entry_t entry = {"AL": 9};
  adderAL(state, entry);
  REQUIRE( state.T == (((0x92345678 << 2) | 3) & 0xffffffff) >>> 0, state["T"].toString(16));
  REQUIRE( state.F == 0x2);
  state.T0 = state["T"];
  entry_t entry = {"AL": 9};
  adderAL(state, entry);
  REQUIRE( state.T == (((0x92345678 << 3) | 6) & 0xffffffff) >>> 0, state["T"].toString(16));
  REQUIRE( state.F == 0x4);
  state.T0 = state["T"];
  entry_t entry = {"AL": 9};
  adderAL(state, entry);
  REQUIRE( state.T == (((0x92345678 << 4) | 0xc) & 0xffffffff) >>> 0, state["T"].toString(16));
  REQUIRE( state.F == 0x9);
}

TEST_CASE( "al10 SL1→Q") {
  state_t state = {"T0": 0x92345678};
  entry_t entry = {"AL": 10};
  adderAL(state, entry);
  REQUIRE( state.T == (0x92345678 << 1) & 0xffffffff, state["T"].toString(16));
  REQUIRE( state.Q == 0x1);
}


TEST_CASE( "al11 Q→SL1") {
  state_t state = {"T0": 0x92345678, "Q": 0};
  entry_t entry = {"AL": 11};
  adderAL(state, entry);
  REQUIRE( state.T == 0x2468acf0);

  state = {"T0": 0x92345678, "Q": 1};
  entry_t entry = {"AL": 11};
  adderAL(state, entry);
  REQUIRE( state.T == 0x2468acf1);
}

TEST_CASE( "al12 SR1→F") {
  state_t state = {"T0": 0x12345679, "F": 3};
  entry_t entry = {"AL": 12};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12345679 >> 1);
  REQUIRE( state.F == 9);
}

TEST_CASE( "al13 SR1→Q") {
  state_t state = {"T0": 0x12345679};
  entry_t entry = {"AL": 13};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12345679 >> 1);
  REQUIRE( state.Q == 0x1);
}

TEST_CASE( "al14 Q→SR1→Q") {
  state_t state = {"T0": 0x92345679, "Q": 0};
  entry_t entry = {"AL": 14};
  adderAL(state, entry);
  REQUIRE( state.T == 0x491a2b3c);
  REQUIRE( state.Q == 0x1);

  state_t state = {"T0": 0x92345678, "Q": 1};
  entry_t entry = {"AL": 14};
  adderAL(state, entry);
  REQUIRE( state.T == 0xc91a2b3c);
  REQUIRE( state.Q == 0x0);
}

TEST_CASE( "al15 F→SL1→Q") {
  state_t state = {"T0": 0x12345678, "F": 0x9, "Q": 0};
  entry_t entry = {"AL": 15};
  adderAL(state, entry);
  REQUIRE( state.F == 9); // Assuming unchanged
  REQUIRE( state.T == 0x2468acf1);
  REQUIRE( state.Q == 0x0);

  state = {"T0": 0x92345678, "F": 0x7, "Q": 0};
  entry_t entry = {"AL": 15};
  adderAL(state, entry);
  REQUIRE( state.F == 0x7); // Assuming unchanged
  REQUIRE( state.T == 0x2468acf0);
  REQUIRE( state.Q == 0x1);
}

TEST_CASE( "al16 SL4→F") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 16};
  adderAL(state, entry);
  REQUIRE( state.T == 0x23456780);
  REQUIRE( state.F == 0x1);
}

TEST_CASE( "al17 F→SL4→F") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 17};
  adderAL(state, entry);
  REQUIRE( state.T == 0x23456783);
  REQUIRE( state.F == 0x1);
}

TEST_CASE( "al18 FPSL4") {
  state_t state = {"T0": 0x12345678, "F": 0xf};
  entry_t entry = {"AL": 18};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12456780); // Preserve sign, exponent top byte
  REQUIRE( state.F == 0xf);
  REQUIRE( state.LB == 1);
}

TEST_CASE( "al18 FPSL4 0") {
  state_t state = {"T0": 0x12045678, "F": 0xf};
  entry_t entry = {"AL": 18};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12456780); // Preserve sign, exponent top byte
  REQUIRE( state.F == 0xf);
  REQUIRE( state.LB == 0);
}

TEST_CASE( "al19 F→FPSL4") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 19};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12456783);
  REQUIRE( state.F == 0x3);
  REQUIRE( state.LB == 1);
}

TEST_CASE( "al19 F→FPSL4 0") {
  state_t state = {"T0": 0x12045678, "F": 0x3};
  entry_t entry = {"AL": 19};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12456783);
  REQUIRE( state.F == 0x3);
  REQUIRE( state.LB == 0);
}

TEST_CASE( "al20 SR4→F") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 20};
  adderAL(state, entry);
  REQUIRE( state.T == 0x01234567);
  REQUIRE( state.F == 0x8);
}

TEST_CASE( "al21") {
  // F->SR4->F: guess as to function
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 21};
  adderAL(state, entry);
  REQUIRE( state.T == 0x31234567);
  REQUIRE( state.F == 0x8);
}

TEST_CASE( "al22 FPSR4→F") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 22};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12034567);
  REQUIRE( state.F == 0x8);
}

TEST_CASE( "al23 1→FPSR4→F") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 23};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12134567);
  REQUIRE( state.F == 0x8);
}

TEST_CASE( "al24 SR4→H", "[hide]") {
}

TEST_CASE( "al25 F→SR4") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 25};
  adderAL(state, entry);
  REQUIRE( state.T == 0x31234567);
  REQUIRE( state.F == 0x3);
}

TEST_CASE( "al26 E→FPSL4") {
  state_t state = {"T0": 0x12345678, "F": 0x3};
  entry_t entry = {"AL": 26, "CE": 0x4};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12456784);
  REQUIRE( state.F == 0x3);
  REQUIRE( state.LB == 1);
}

TEST_CASE( "al26 E→FPSL4 0") {
  state_t state = {"T0": 0x12045678, "F": 0x3};
  entry_t entry = {"AL": 26, "CE": 0x4};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12456784);
  REQUIRE( state.F == 0x3);
  REQUIRE( state.LB == 0);
}

TEST_CASE( "al27 F→SR1→Q") {
  state_t state = {"T0": 0x92345678, "F": 0};
  entry_t entry = {"AL": 27};
  adderAL(state, entry);
  REQUIRE( state.T == 0x491a2b3c);
  REQUIRE( state.Q == 0);

  state = {"T0": 0x92345679, "F": 0xe};
  entry_t entry = {"AL": 27};
  adderAL(state, entry);
  REQUIRE( state.T == 0x491a2b3c);
  REQUIRE( state.Q == 1);

  state_t state = {"T0": 0x92345678, "F": 3};
  entry_t entry = {"AL": 27};
  adderAL(state, entry);
  REQUIRE( state.T == 0xc91a2b3c);
  REQUIRE( state.Q == 0);
}

TEST_CASE( "al28 DKEY→", "[hide]") {
}

// al 29 is I/O

TEST_CASE( "al30 D→") {
  state_t state = {"SAR": 0x30};
  state.MS = [];
  state.MS[0x30] = 0x12345678;
  entry_t entry = {"AL": 30, "CE": 0x4};
  adderAL(state, entry);
  REQUIRE( state.T == 0x12345678);
}

TEST_CASE "al31 AKEY→", "[hide]") {
}
